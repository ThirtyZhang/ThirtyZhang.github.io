<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>npm命令释义</title>
      <link href="/2020/04/26/npm-ming-ling-shi-yi/"/>
      <url>/2020/04/26/npm-ming-ling-shi-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="本片为转载-底部附带原文地址"><a href="#本片为转载-底部附带原文地址" class="headerlink" title="本片为转载 - 底部附带原文地址"></a>本片为转载 - 底部附带原文地址</h2><p>备注：&lt;=&gt; 意为等价于；</p><p>1、npm install &lt;=&gt; npm i</p><pre><code> --save   &lt;=&gt; -S      --save-dev  &lt;=&gt; -D   npm run start &lt;=&gt; npm start  // 对应&quot;scripts&quot;里的&quot;start&quot;命令  少敲几下键盘，何乐而不为</code></pre><p>2、npm i –save-dev  <packname>  </packname></p><pre><code>  工程构建（开发时、“打包”时）依赖 ；例：xxx-cli , less-loader , babel-loader...</code></pre><p>3、npm i –save <packname> </packname></p><pre><code>  项目（运行时、发布到生产环境时）依赖；例：antd , element,react...</code></pre><p>4、对应关系如下（至于我们啥时候用–save、啥时候用–save-dev 感觉是个规范问题，用反了项目一样可以跑起来（对于安装依赖正确时），但会给其他看你项目的人带来误解、可能会导致一些bug的出现，还有一些配置的错乱等）</p><p>5、使用 npm i 安装package.json里的依赖时，两部分的包都会pull下来</p><pre><code> 5-1、使用 --prod、          npm i --prod &lt;=&gt; npm i --production  // 仅会拉取dependencies中的依赖 5-2、设置NODE_DEV=production时            // 效果同上，仅会拉取dependencies中的依赖 (注意等号两边没空格)          5-2-1、命令行设置（注意不同环境时的&quot;分割符&quot;）                      window =&gt; cmd ：set NODE_ENV=production &amp;&amp; xxxx                      mac      =&gt; shell  : NODE_ENV=production 空格 xxxx          5-2-2、package.json=&gt;script命令中设置</code></pre><p>彩蛋：在新建package.json文件时，我们可以使用npm init -y 快速创建（yes 表示一路默认创建，还有 -f 表示 force）</p><p>————————————————<br>版权声明：本文为CSDN博主「willon_」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/jwl_willon/article/details/81054978" target="_blank" rel="noopener">https://blog.csdn.net/jwl_willon/article/details/81054978</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 分支协作</title>
      <link href="/2020/04/21/git-fen-zhi-xie-zuo/"/>
      <url>/2020/04/21/git-fen-zhi-xie-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-分支协作"><a href="#Git-分支协作" class="headerlink" title="Git 分支协作"></a>Git 分支协作</h1><blockquote><p>创建分支, 然后切换分支</p></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># 创建</span>git branch dev<span class="token comment" spellcheck="true"># 切换</span>git checkout dev<span class="token comment" spellcheck="true"># 创建并切换 , 相当于上面的两句</span>git checkout <span class="token operator">-</span>b dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>使用<code>git branch</code> 命令查看当前分支 ,  <code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p></blockquote><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 分支协作</title>
      <link href="/2020/04/21/flex-bu-ju/"/>
      <url>/2020/04/21/flex-bu-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h1><blockquote><p>相关知识</p><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><blockquote><p>em 是相对于父元素字体大小<br>rem (root em) 是相对于 html的字字大小, 所以可以通过修改html里面的文字大小来控制整体页面元素</p></blockquote><h2 id="媒体查询-Media-Query"><a href="#媒体查询-Media-Query" class="headerlink" title="媒体查询 - (Media Query)"></a>媒体查询 - (Media Query)</h2><blockquote><p>可以根据不同的屏幕尺寸设置不同的样式</p><pre class="line-numbers language-html"><code class="language-html">@media screen and (max-width: 800px){}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面代码的意思就是: 在屏幕上,并且最大宽度是 800 像素 , 在大括号里面设置我们想要的样式</p></blockquote></blockquote><blockquote><p>分为主轴和侧轴</p><p>默认 X 轴为主轴 Y 轴为侧轴</p></blockquote><h2 id="flex-direction-主轴方向"><a href="#flex-direction-主轴方向" class="headerlink" title="flex-direction - 主轴方向"></a>flex-direction - 主轴方向</h2><blockquote><p><code>flex-direction</code> 属性决定主轴的方向</p></blockquote><pre class="line-numbers language-css"><code class="language-css"><span class="token property">flex-direction</span><span class="token punctuation">:</span> row | row-reverse | column | column-reverse<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul></blockquote><h2 id="flex-wrap-是否换行"><a href="#flex-wrap-是否换行" class="headerlink" title="flex-wrap - 是否换行"></a>flex-wrap - 是否换行</h2><blockquote><p><code>flex-direction</code>属性决定是否换行, 默认不换行</p></blockquote><pre class="line-numbers language-css"><code class="language-css"><span class="token property">flex-wrap</span><span class="token punctuation">:</span> nowrap | wrap | wrap-reverse<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><ul><li><code>nowrap</code> (默认值) : 不换行</li><li><code>wrap</code> : 换行, 第一行在上方</li><li><code>wrap-reverse</code> : 换行, 第一行在下方</li></ul></blockquote><h2 id="flex-flow-流动"><a href="#flex-flow-流动" class="headerlink" title="flex-flow - 流动"></a>flex-flow - 流动</h2><blockquote><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code> </p></blockquote><h2 id="justify-content-内容的主轴对齐方式"><a href="#justify-content-内容的主轴对齐方式" class="headerlink" title="justify-content - 内容的主轴对齐方式"></a>justify-content - 内容的主轴对齐方式</h2><blockquote><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式 </p></blockquote><pre class="line-numbers language-css"><code class="language-css"><span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></blockquote><h3 id="align-items-侧轴对齐方式"><a href="#align-items-侧轴对齐方式" class="headerlink" title="align-items - 侧轴对齐方式"></a>align-items - 侧轴对齐方式</h3><blockquote><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p></blockquote><pre class="line-numbers language-css"><code class="language-css">   <span class="token property">align-items</span><span class="token punctuation">:</span> flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></blockquote><h3 id="align-content-多轴线对齐方式"><a href="#align-content-多轴线对齐方式" class="headerlink" title="align-content - 多轴线对齐方式"></a>align-content - 多轴线对齐方式</h3><blockquote><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p></blockquote><pre class="line-numbers language-css"><code class="language-css">  <span class="token property">align-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around | stretch<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>less</title>
      <link href="/2020/04/21/less/"/>
      <url>/2020/04/21/less/</url>
      
        <content type="html"><![CDATA[<h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><pre class="line-numbers language-less"><code class="language-less"><span class="token comment" spellcheck="true">// 定义</span><span class="token variable">@color<span class="token punctuation">:</span></span> blue<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用</span><span class="token selector">body</span> <span class="token punctuation">{</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token variable">@color</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>变量名 @ 前缀 , 不能有特殊字符, 数字不能开头 , 区分大小写字母</p></blockquote><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><blockquote><p>安装 vscode 插件 Easy LESS , 保存后自动将 less 文件编译成 css</p></blockquote><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><blockquote><pre class="line-numbers language-less"><code class="language-less"><span class="token selector">.header</span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token selector">a</span> <span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>        <span class="token selector">&amp;:hover</span> <span class="token punctuation">{</span>            <span class="token property">color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>伪类伪元素加 &amp; 符号去空格;</p></blockquote><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><blockquote><pre class="line-numbers language-less"><code class="language-less"><span class="token selector">div</span> <span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 150px</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">200</span>px <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">10</span>  <span class="token comment" spellcheck="true">// 390px</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运算符两侧必须敲一个空格</p><p>两个数参与运算,  如果只有一个数有单位. 最后结果就以这个单位为准</p><p>两个数参与运算, 如果两个数都有单位,  并且是不一样的单位, 以第一单位为准</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> less </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react-base-1</title>
      <link href="/2020/04/21/react-base-1/"/>
      <url>/2020/04/21/react-base-1/</url>
      
        <content type="html"><![CDATA[<h2 id="创建启动"><a href="#创建启动" class="headerlink" title="创建启动"></a>创建启动</h2><p><a href="https://github.com/ThirtyZhang/myreactdemo" target="_blank" rel="noopener">GitHub 地址</a></p><p>初始化项目，命令： <code>npx create-react-app myreact</code></p><p>切换到项目根目录: <code>cd myreact</code></p><p>启动: <code>npm start</code></p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><code>src/index.js</code> 在文件中输入以下内容</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 引入 react 和 react-dom</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token keyword">let</span> loading <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">function</span> <span class="token function">my</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>loading<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>      加载中<span class="token operator">...</span><span class="token punctuation">.</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>      加载完成<span class="token operator">...</span><span class="token punctuation">.</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 把方法的返回结果渲染到 public/index.html 中</span>ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token function">my</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在浏览器中查看结果</p><pre><code>加载完成....</code></pre><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>在style里面我们通过对象的方式传递数据</p><pre class="line-numbers language-react"><code class="language-react"><li key={item.id} style={{'color': 'red',"backgroundColor": 'pink'}}>{item.name}</li><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种方式比较的麻烦，不方便进行阅读，而且还会导致代码比较的繁琐</p><p>创建CSS文件编写样式代码</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.container</span> </span><span class="token punctuation">{</span>    <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在js中进行引入，然后设置类名即可</p><pre class="line-numbers language-react"><code class="language-react">import './css/index.css'<li className='container' key={item.id} style={{'color': 'red',"backgroundColor": 'pink'}}>{item.name}</li><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><h3 id="定义样式"><a href="#定义样式" class="headerlink" title="定义样式"></a>定义样式</h3><p><code>src/css/list.css</code></p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector"><span class="token class">.list</span></span><span class="token punctuation">{</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">500</span>px<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">10</span>px auto<span class="token punctuation">;</span>     <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">......</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定义组件并导出"><a href="#定义组件并导出" class="headerlink" title="定义组件并导出"></a>定义组件并导出</h3><p><code>src/components/list.js</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span> <span class="token comment" spellcheck="true">// 引入react</span><span class="token keyword">import</span> <span class="token string">'../css/list.css'</span>  <span class="token comment" spellcheck="true">// 引入样式</span><span class="token comment" spellcheck="true">// 定义组件</span><span class="token keyword">class</span> <span class="token class-name">List</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 定义数据</span>    state <span class="token operator">=</span> <span class="token punctuation">{</span>        comments<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'jack'</span><span class="token punctuation">,</span> content<span class="token punctuation">:</span> <span class="token string">'沙发！！！'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'rose'</span><span class="token punctuation">,</span> content<span class="token punctuation">:</span> <span class="token string">'板凳~'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'tom'</span><span class="token punctuation">,</span> content<span class="token punctuation">:</span> <span class="token string">'楼主好人'</span> <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">'list'</span><span class="token operator">></span>            <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">'text'</span> placeholder<span class="token operator">=</span><span class="token string">"请输入评论人"</span> <span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>input<span class="token operator">></span>            <span class="token operator">&lt;</span>textarea<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>textarea<span class="token operator">></span>            <span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">'submit'</span><span class="token operator">></span>提交评论<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>            <span class="token operator">&lt;</span>ul<span class="token operator">></span>                <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>comments<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span>                    <span class="token operator">&lt;</span>li key<span class="token operator">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>id<span class="token punctuation">}</span><span class="token operator">></span>                        <span class="token operator">&lt;</span>h3<span class="token operator">></span>评论人：<span class="token punctuation">{</span>item<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">></span>                        <span class="token operator">&lt;</span>p<span class="token operator">></span>评论内容：<span class="token punctuation">{</span>item<span class="token punctuation">.</span>content<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>                    <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span><span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 导出组件</span><span class="token keyword">export</span> <span class="token keyword">default</span> List<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引入组件"><a href="#引入组件" class="headerlink" title="引入组件"></a>引入组件</h2><p><code>src/index.js</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> List <span class="token keyword">from</span> <span class="token string">'./components/list'</span> <span class="token comment" spellcheck="true">// 引入</span><span class="token comment" spellcheck="true">// 把方法的返回结果渲染到 public/index.html 中</span>ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>List<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>List<span class="token operator">></span><span class="token punctuation">,</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 点击函数</span>  addCount<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 注意：在react中 修改值 必须用  this.setState</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//名字:新值 </span>        count<span class="token punctuation">:</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token operator">+</span><span class="token number">1</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>         <span class="token operator">&lt;</span>h1<span class="token operator">></span>count的值是<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>         <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>addCount<span class="token punctuation">}</span><span class="token operator">></span>点我<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span> <span class="token comment" spellcheck="true">// 绑定事件</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><blockquote><ul><li>在子组件对应的子组件标签中添加属性<code>&lt;Child age = {this.state.age} arr={this.state.arr}&gt;&lt;/Child&gt;</code></li><li>然后子组件通过<code>this.state.age</code> 接收</li></ul></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>    state<span class="token operator">=</span> <span class="token punctuation">{</span>        age<span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">,</span>        arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 通过属性传值给子组件 age = {this.state.age}</span>    render <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">&lt;</span>div className <span class="token operator">=</span> <span class="token string">"parent"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>p<span class="token operator">></span>父组件<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>            <span class="token operator">&lt;</span>Child age <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>age<span class="token punctuation">}</span> arr<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>arr<span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">></span>  <span class="token comment" spellcheck="true">//</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 子组件</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>    state <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 子组件通过 this.props.age 使用</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token punctuation">(</span>             <span class="token operator">&lt;</span>div<span class="token operator">></span>                <span class="token operator">&lt;</span>p<span class="token operator">></span>子组件<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>                <span class="token operator">&lt;</span>p<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>age<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>                <span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> <span class="token punctuation">(</span>                        <span class="token operator">&lt;</span>p key<span class="token operator">=</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>                        <span class="token punctuation">)</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">}</span>            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>         <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token keyword">default</span> Parent<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><blockquote><p>和父传子相似, 只不过在父组件中定义一个方法传到子, 子组件通过 <code>this.props.方法名(参数)</code> </p><p>把自己的数据通过参数传给父组件的方法</p></blockquote><h3 id="兄弟组件传递"><a href="#兄弟组件传递" class="headerlink" title="兄弟组件传递"></a>兄弟组件传递</h3><ul><li><p>将共享状态(数据)提升到最近的公共父组件中，由公共父组件管理这个状态</p></li><li><p>这个称为状态提升</p></li><li><p>公共父组件职责：1. 提供共享状态 2.提供操作共享状态的方法</p></li><li><p>要通讯的子组件只需要通过props接收状态或操作状态的方法</p></li><li><p><strong>个人感觉就像是 父传子 子传父 的结合 , 父组件把参数传递给其中一个子组件, 在定义一个操作这个数据的方法传给另一个子组件 , 通过方法传参修改, 然后另外一个子组件对应会做更新</strong></p></li><li><h4 id="示例demo"><a href="#示例demo" class="headerlink" title="示例demo"></a>示例demo</h4><ul><li>定义布局结构，一个Counter里面包含两个子组件，一个是计数器的提示，一个是按钮</li></ul><pre class="line-numbers language-react"><code class="language-react">class Counter extends React.Component {    render() {        return (<div>            <Child1 />            <Child2 />        </div>        )    }}class Child1 extends React.Component {    render() {        return (            <h1>Child1 儿子1 计数器：</h1>        )    }}class Child2 extends React.Component {    render() {        return (            <button>Child2儿子2 +1</button>        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在父组件里定义共享状态，把这个状态传递给第一个子组件</li></ul><pre class="line-numbers language-react"><code class="language-react">class Counter extends React.Component {    // 提供共享的状态    state = {        count: 0    }    render() {        return (<div>            {/* 把状态提供给第一个子组件 */}            <Child1 count={this.state.count}/>            <Child2 />        </div>        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在第一个子组件里面就能通过props获取到</li></ul><pre class="line-numbers language-react"><code class="language-react">class Child1 extends React.Component {    render() {        return (            <h1>计数器：{this.props.count}</h1>        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在父组件中提供共享方法，通过属性传递给第二个子组件，方便第二个子组件来进行调用</li></ul><pre class="line-numbers language-react"><code class="language-react">    // 提供共享方法    onIncrement = (res) => {        // 只要第二个子组件调用了这个函数，就会执行里面代码        this.setState({            count: this.state.count + res        })    }    render() {        return (<div>            ...            {/* 把共享方法提供给第二个子组件 */}            <Child2 onIncrement={this.onIncrement} />        </div>        )    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在第二个子组件里面通过props来获取到对应函数，然后进行调用</li></ul><pre class="line-numbers language-react"><code class="language-react">class Child2 extends React.Component {    handleClick = () => {        // 这里一旦调用，就会执行父组件里面 onIncrement函数        this.props.onIncrement(2)    }    render() {        return (            <button onClick={this.handleClick}>+</button>        )    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="render-props模式-就是父传子类似（★★★）"><a href="#render-props模式-就是父传子类似（★★★）" class="headerlink" title="render-props模式 -就是父传子类似（★★★）"></a>render-props模式 -就是父传子类似（★★★）</h3><blockquote><p>就是通过父传子传递函数到子, 函数 return 对应的 html 代码, </p><p>函数名叫 render , 然后对应子组件通过 <code>this.props.render()</code> 调用渲染到子组件上</p></blockquote><h3 id="复杂的传值建议直接使用-redux"><a href="#复杂的传值建议直接使用-redux" class="headerlink" title="复杂的传值建议直接使用 redux"></a>复杂的传值建议直接使用 redux</h3><blockquote><p>类似于 vue 中的 vuex</p></blockquote><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><code>componentWillMount</code> 挂载前 用来数据初始化</p><p><code>componentDidMount</code> 挂载后 用来发送异步请求</p><blockquote><p>用的最多的，一般用在进入页面后，数据初始化 </p></blockquote><pre class="line-numbers language-js"><code class="language-js">componentWillMount <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>            selectedTab<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>location<span class="token punctuation">.</span>pathname  <span class="token comment" spellcheck="true">// 根据请求地址, 重新给选中的Tab赋值, 解决浏览器刷新后, tab栏高亮的值与地址也不一致</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><blockquote><p>个人理解就是把组件放在函数里, 这个函数的返回值是一个组件, 哪里需要就调用这个函数就好了</p></blockquote><h2 id="好客租房项目"><a href="#好客租房项目" class="headerlink" title="好客租房项目"></a>好客租房项目</h2><h3 id="控制台报错"><a href="#控制台报错" class="headerlink" title="控制台报错"></a>控制台报错</h3><p><code>[Intervention] Unable to preventDefault inside passive event listener due to target being treated as</code></p><blockquote><p>解决办法: </p><p>在<code>index.js</code> 中引入公共样式添加以下</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">* </span><span class="token punctuation">{</span>    <span class="token property">touch-action</span><span class="token punctuation">:</span> pan-y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://www.fxyh97.com/index.php/archives/173/" target="_blank" rel="noopener">https://www.fxyh97.com/index.php/archives/173/</a> </p></blockquote><h3 id="0-优化开发篇"><a href="#0-优化开发篇" class="headerlink" title="0. 优化开发篇"></a>0. 优化开发篇</h3><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">// 将要更新UI的时候会执行这个钩子函数</span>    <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span>nextState<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// 判断一下当前生成的 值是否与页面的值相等 , 来决定页面时候重现渲染</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>nextState<span class="token punctuation">.</span>number <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>number<span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token boolean">true</span>         <span class="token punctuation">}</span>         <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-项目搭建"><a href="#1-项目搭建" class="headerlink" title="1.项目搭建"></a>1.项目搭建</h3><p>使用脚手架初始化项目 - 项目名称不能使用大写字母</p><ol><li><p><code>npx create-react-app my-hkzf</code>  </p><blockquote><p>如果安装过程中不动了, 可能用于鼠标在窗口滑动导致暂停了, 点击一下窗口, 并按一次 <code>Ctrl + C</code> 让项目开始</p></blockquote></li><li><p><code>cd my-hkzf</code> </p></li><li><p><code>npm start</code></p></li><li><p>浏览器<code>localhost:3000</code>打开 - 多个项目可能会发生端口占用, 输入 y 即可自动切换端口号 <code>3001</code></p></li><li><p>后面写react项目 发送ajax 请求 <a href="http://api-haoke-dev.itheima.net/" target="_blank" rel="noopener">http://api-haoke-dev.itheima.net/</a> 拿数据</p></li></ol><h4 id="谷歌上网助手"><a href="#谷歌上网助手" class="headerlink" title="谷歌上网助手"></a>谷歌上网助手</h4><p>链接：<a href="https://pan.baidu.com/s/15nBX-Wc7yCsVUKA37j6hsw" target="_blank" rel="noopener">https://pan.baidu.com/s/15nBX-Wc7yCsVUKA37j6hsw</a><br>提取码：k7vn </p><blockquote><p>简单易用的《谷歌上网助手》，可以解决chrome扩展无法自动更新的问题，同时可以访问谷歌google搜索，gmail邮箱，google+等谷歌服务。</p><p>不用设置任何主页即可免费使用 – google.com 谷歌搜索  – mail.google.com gmail邮箱  – chrome商店访问；</p><p><strong>注意：使用此插件会和本地ss、vpn冲突，请关闭其他代理后在使用。</strong></p></blockquote><p><strong>操作使用方法：</strong></p><blockquote><p>1.下载安装</p><p>2.注册登录后自动开启加速</p><p>3.访问网站 谷歌搜索、邮箱、商店</p></blockquote><h4 id="react-devtools-安装"><a href="#react-devtools-安装" class="headerlink" title="react-devtools 安装"></a>react-devtools 安装</h4><p><strong>在线安装</strong></p><ul><li>有条件的直接打开 <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi</a> 点击添加至Chrome</li></ul><p><strong>离线安装</strong></p><ul><li><strong>可以直接拿到文件夹中的 unpacked目录 直接使用</strong><ul><li>链接：<a href="https://pan.baidu.com/s/1iRgSjPP0Pp6fK7e1_jAmlQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1iRgSjPP0Pp6fK7e1_jAmlQ</a><br>提取码：1ft4</li></ul></li></ul><hr><ul><li>1 打开Chrome输入 chrome://extensions/ 进入扩展程序设置页面</li><li>2 开启 开发者模式</li><li>3 加载已解压的扩展程序 选择第4步的unpacked目录， 确认安装即可</li></ul><h4 id="VSCode-插件"><a href="#VSCode-插件" class="headerlink" title="VSCode - 插件"></a>VSCode - 插件</h4><p><code>Simple React Snippets</code>  </p><h3 id="2-项目目录结构"><a href="#2-项目目录结构" class="headerlink" title="2.项目目录结构"></a>2.项目目录结构</h3><blockquote><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>public/</td><td>公共资源</td></tr><tr><td>index.html</td><td>首页页面(必须)</td></tr><tr><td>manifest.json</td><td>PWA 应用的元数据</td></tr><tr><td>src/</td><td>项目源码, 写项目功能代码</td></tr><tr><td>assets/</td><td>资源(图片, 字体图标等)</td></tr><tr><td>components/</td><td>公共组件</td></tr><tr><td>utils/</td><td>工具</td></tr><tr><td>App.js</td><td>根组件(配置路由信息)</td></tr><tr><td>index.css</td><td>全局样式(去除浏览器自带样式)</td></tr><tr><td>index.js</td><td>项目入口文件(渲染根组件, 导入组件库等)</td></tr></tbody></table></blockquote><h3 id="3-antd-mobile-组件库"><a href="#3-antd-mobile-组件库" class="headerlink" title="3.antd-mobile 组件库"></a>3.antd-mobile 组件库</h3><ul><li>react 移动端 UI组件库</li></ul><p><a href="https://mobile.ant.design/index-cn" target="_blank" rel="noopener">antd-mobile 组件库文档</a></p><blockquote><p>vue  移动端 vant mint-ui（饿了么vue移动端）</p><p>vue pc端 element-ui 后台管理系统经常用</p><p><strong>ant  design</strong></p><p>react  移动端   antd-mobile  阿里巴巴  蚂蚁金服   </p></blockquote><p><strong>快速上手</strong></p><ul><li><p>安装</p><ul><li>cnpm i antd-mobile -S</li></ul></li><li><p>使用</p><ul><li>导入组件</li><li>在index.js导入样式 </li></ul><pre><code>// 引入 antd-mobile的样式  // 引入写在 组件导入的前边, 写后边的话有可能覆盖自己写的样式import &#39;antd-mobile/dist/antd-mobile.css&#39;; </code></pre><ul><li>App.js使用Button</li></ul><pre class="line-numbers language-react"><code class="language-react">// 导入组件import { Button } from 'antd-mobile';  // 按需引入 <Button type="primary">按钮啊啊啊</Button><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="4-路由配置"><a href="#4-路由配置" class="headerlink" title="4.  路由配置"></a>4.  路由配置</h3><p><strong>下载</strong></p><p><code>cnpm i react-router-dom -S</code></p><p><strong>导入</strong></p><p>App.js</p><p><code>import { BrowserRouter as Router, Route, Link} from &#39;react-router-dom&#39;</code> </p><p>– 这里引入时给 BrowserRouter 起个别名 Router 名字简短些</p><p><strong>使用</strong></p><p>App.js</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>            <span class="token operator">&lt;</span>Router<span class="token operator">></span> <span class="token comment" spellcheck="true">// 使用Router包裹</span>                <span class="token operator">&lt;</span>div<span class="token operator">></span>                <span class="token operator">&lt;</span>Link to<span class="token operator">=</span><span class="token string">"/home"</span><span class="token operator">></span>点击显示首页<span class="token operator">&lt;</span><span class="token operator">/</span>Link<span class="token operator">></span>                 <span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">"/home"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>Home<span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Route<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">/</span>Router<span class="token operator">></span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重定向</strong></p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>Route    exact    path<span class="token operator">=</span><span class="token string">"/"</span>    render<span class="token operator">=</span><span class="token punctuation">{</span>props <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// console.log('render-props模式：', props)</span>    <span class="token comment" spellcheck="true">// Redirect 组件：是路由的重定向组件，通过 to 属性，来指定要重定向到的路由地址</span>    <span class="token keyword">return</span> <span class="token operator">&lt;</span>Redirect to<span class="token operator">=</span><span class="token string">"/home"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>编程式导航</strong></p><p><code>this.props.history.push(&quot;/home&quot;)</code></p><p><strong>默认地址</strong></p><p><code>&lt;Route path=&quot;/&quot; component={Home}&gt;&lt;/Route&gt;</code></p><p><strong>精确匹配</strong></p><p><code>exact</code></p><p><strong>路由参数</strong></p><p><code>&lt;Route path=&quot;/home/:id&quot; component={Home}&gt;&lt;/Route&gt;</code></p><p>地址栏输入<code>/home/1</code></p><p> 在<code>Home</code> 组件中 通过<code>this.props.match.params</code>接收 </p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>match<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>嵌套路由</strong></p><p><code>App.js</code>  – 父</p><pre class="line-numbers language-ks"><code class="language-ks"> import Home from './pages/home/home' import { BrowserRouter as Router, Route, Link} from 'react-router-dom'  render() {        return (            <Router>                <div>                <Route exact path="/" component={Home}></Route>                <Route path="/home" component={Home}></Route>            </div>            </Router>        );    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>home.js</code> – 子</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Route <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router-dom'</span><span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">"/home/index"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>Index<span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Route<span class="token operator">></span><span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">"/home/news"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>News<span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Route<span class="token operator">></span><span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">"/home/profile"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>Profile<span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Route<span class="token operator">></span><span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">"/home/houselist"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>HouseList<span class="token punctuation">}</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>Route<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-图标库"><a href="#5-图标库" class="headerlink" title="5.  图标库"></a>5.  图标库</h3><p><a href="https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2" target="_blank" rel="noopener">阿里妈妈 - iconfont</a></p><blockquote><ol><li>登录后搜索对应图标</li><li>加入购物车</li><li>添加到项目</li><li>下载到本地 - 解压 - 前面两个 <code>demo</code> 文件可以删除掉</li><li>放到 <code>src</code> 下的静态文件夹</li><li>在 <code>index.js</code> 中引入 <code>import &#39;./assets/fonts/iconfont.css&#39;</code></li><li>使用</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>i <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"iconfont"</span><span class="token operator">></span><span class="token operator">&amp;</span>#x33<span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">></span><span class="token comment" spellcheck="true">// 或者</span><span class="token operator">&lt;</span>i <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"iconfont icon-xxx"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="6-使用-axios-进行接口请求调取数据"><a href="#6-使用-axios-进行接口请求调取数据" class="headerlink" title="6.使用 axios 进行接口请求调取数据"></a>6.使用 axios 进行接口请求调取数据</h3><blockquote><ul><li><code>cnpm i axios -S</code>  - 安装到运行时依赖</li><li>在Index组件中导入axios  <code>import axios from &#39;axios&#39;</code></li></ul></blockquote><h3 id="7-使用-sass–less-CSS扩展语言"><a href="#7-使用-sass–less-CSS扩展语言" class="headerlink" title="7.使用 sass–less  CSS扩展语言"></a>7.使用 sass–less  CSS扩展语言</h3><blockquote><p><strong>使用步骤</strong></p><p>1  下载 <code>cnpm i node-sass -S</code></p><p>2  新建<code>xx.scss</code>文件  sass文件 在里面和less一样写样式  – 注意文件后缀名是 <code>.scss</code></p><p>3 在哪用就导入即可</p></blockquote><h3 id="8-百度地图API"><a href="#8-百度地图API" class="headerlink" title="8.百度地图API"></a>8.百度地图API</h3><blockquote><ul><li><a href="http://lbsyun.baidu.com/apiconsole/key/create" target="_blank" rel="noopener">访问地址</a></li><li>注册账号</li><li>申请AK<ul><li>应用名称: 随便填, 不能与之前的重复</li><li>应用里类型: 浏览器端</li><li>Referer 白名单: 上线的话请填写域名, 如果只是测试可以直接填 * 表示全都可以</li></ul></li><li>AK<ul><li><code>N2YsAtKhLtggksmM1mfXofWnT0UzPozr</code></li></ul></li></ul></blockquote><h3 id="9-引入图片"><a href="#9-引入图片" class="headerlink" title="9. 引入图片"></a>9. 引入图片</h3><blockquote><p><code>import nav1 from &#39;../../assets/images/nav-1.png&#39;</code></p><p>react 图片不能直接使用现对路径, 需要引入, 或者直接使用服务器地址</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app 基础知识</title>
      <link href="/2020/04/21/uni-app-ji-chu-zhi-shi/"/>
      <url>/2020/04/21/uni-app-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="回顾-小程序-演示ugo"><a href="#回顾-小程序-演示ugo" class="headerlink" title="回顾 小程序-演示ugo"></a>回顾 小程序-演示ugo</h3><p>1 页面 结构   样式 我们会写  </p><p>2 点击事件  绑定和修改数据 等  我们会写</p><p>3 发送请求 我们会写 </p><p>4 顶部导航与底部tab栏 我们会配置</p><p>5 页面跳转 会写</p><p>我们完全可以用原生的小程序语法 来写一个完整的小程序 </p><p>但是 没有那么方便  1  比如 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html" target="_blank" rel="noopener">基本都是success回调</a>  还需要自己去封装promise 2 没有v-model等等 </p><p>所以就出现了 框架  给我们封装了  写起来比较方便</p><h3 id="几个框架的介绍"><a href="#几个框架的介绍" class="headerlink" title="几个框架的介绍"></a>几个框架的介绍</h3><p><a href="https://tencent.github.io/wepy/document.html#/" target="_blank" rel="noopener">wepy</a>     腾讯团队 组件化开发框架WePY–  只能开发微信小程序</p><p><a href="https://taro.aotu.io/" target="_blank" rel="noopener">taro</a>      <strong>Taro</strong> 是一套遵循 <a href="https://reactjs.org/" target="_blank" rel="noopener">React</a> 语法规范的 <strong>多端开发</strong> 解决方案。</p><p><a href="http://mpvue.com/" target="_blank" rel="noopener">mpvue</a>  是一个使用 <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue.js</a> 开发小程序的前端框架–只能开发微信小程序</p><p><a href="https://uniapp.dcloud.io/README" target="_blank" rel="noopener">uni-app</a>  是一个使用 <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue.js</a> 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。</p><h3 id="uni-app的基本使用"><a href="#uni-app的基本使用" class="headerlink" title="uni-app的基本使用"></a>uni-app的基本使用</h3><p>项目：黑马商城项目</p><h5 id="uni-app介绍-官方网页"><a href="#uni-app介绍-官方网页" class="headerlink" title="uni-app介绍 官方网页"></a>uni-app介绍 <a href="https://uniapp.dcloud.io/README" target="_blank" rel="noopener">官方网页</a></h5><p><code>uni-app</code> 是一个使用 <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue.js</a> 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。</p><p>即使不跨端，<code>uni-app</code>同时也是更好的小程序开发框架。</p><p>具有vue和微信小程序的开发经验，可快速上手uni-app</p><p>为什么要去学习uni-app？</p><p>相对开发者来说，减少了学习成本，因为只学会uni-app之后，即可开发出iOS、Android、H5、以及各种小程序的应用，不需要再去学习开发其他应用的框架，相对公司而言，也大大减少了开发成本。</p><h5 id="框架的工作原理"><a href="#框架的工作原理" class="headerlink" title="框架的工作原理"></a>框架的工作原理</h5><p>写好 vue代码  —-&gt; webpack babel打包 –&gt;转换成  小程序 或者 网页等等..</p><h3 id="开发uni项目的两种方式"><a href="#开发uni项目的两种方式" class="headerlink" title="开发uni项目的两种方式"></a>开发uni项目的两种方式</h3><h4 id="1-编辑器-HbuilderX"><a href="#1-编辑器-HbuilderX" class="headerlink" title="1 编辑器-HbuilderX"></a>1 编辑器-HbuilderX</h4><p>安装编辑器<strong>HbuilderX-App开发版</strong>  <a href="https://www.dcloud.io/hbuilderx.html" target="_blank" rel="noopener">下载地址</a></p><p>HBuilderX是通用的前端开发工具，但为<code>uni-app</code>做了特别强化。</p><p>下载App开发版，可开箱即用</p><p>安装微信开发者工具 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">下载地址</a></p><h5 id="利用HbuilderX初始化项目"><a href="#利用HbuilderX初始化项目" class="headerlink" title="利用HbuilderX初始化项目"></a>利用HbuilderX初始化项目</h5><ul><li><p>点击HbuilderX菜单栏文件&gt;项目&gt;新建</p></li><li><p>选择uni-app,填写项目名称，项目创建的目录</p><p><img src="create.jpg" alt></p></li></ul><h5 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h5><p>在菜单栏中点击运行，运行到浏览器，选择浏览器即可运行</p><p>在hbuilderX工具里运行：进入hello-uniapp项目，点击工具栏的运行 -&gt; 运行到小程序模拟器 -&gt; 微信开发者工具，即可在微信开发者工具里面体验uni-app</p><p>在hbuilderX工具里运行：进入hello-uniapp项目，点击工具栏的运行 -&gt; 运行到手机或模拟器 -&gt; 选择调式的手机</p><p><strong><a href="https://uniapp.dcloud.io/quickstart" target="_blank" rel="noopener">注意：</a></strong></p><ul><li><strong>如果是第一次使用，需要先配置小程序ide的相关路径，才能运行成功</strong></li><li><strong>微信开发者工具在  设置-&gt;安全设置，服务端口  开启</strong></li><li>修改一下 测试</li></ul><h4 id="2-命令行-我们用这种"><a href="#2-命令行-我们用这种" class="headerlink" title="2 命令行-我们用这种"></a>2 命令行-我们用这种</h4><p>​     首先安装vue脚手架   npm install -g @vue/cli</p><p>​     uni就是 vue语法项目</p><p>​    <strong>1 初始化 项目</strong>  </p><pre><code>    vue create -p dcloudio/uni-preset-vue my-project</code></pre><p>​    <strong>2  选择  默认模板-上下箭头操作</strong></p><p>​        <img src="%E9%80%89%E6%8B%A9%E6%A8%A1%E6%9D%BF.png" alt></p><p>​    <strong>3  运行 或者  打包</strong></p><pre><code>npm run dev:%PLATFORM%npm run build:%PLATFORM%</code></pre><p><strong><code>%PLATFORM%</code> 可取值如下</strong>：</p><table><thead><tr><th>值</th><th>平台</th></tr></thead><tbody><tr><td>h5</td><td>H5</td></tr><tr><td>mp-alipay</td><td>支付宝小程序</td></tr><tr><td>mp-baidu</td><td>百度小程序</td></tr><tr><td>mp-weixin</td><td>微信小程序</td></tr><tr><td>mp-toutiao</td><td>字节跳动小程序</td></tr><tr><td>mp-qq</td><td>qq 小程序</td></tr></tbody></table><p>   4 <strong>微信开发者工具 查看效果  ：</strong> 导入 dist-&gt;dev-&gt;mp-weixin </p><pre><code>```</code></pre><p>可以测试 其他打包<br>    ```</p><h4 id="介绍项目目录和文件作用"><a href="#介绍项目目录和文件作用" class="headerlink" title="介绍项目目录和文件作用"></a>介绍项目目录和文件作用</h4><p><code>pages.json</code> 文件用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar 等</p><p><code>manifest.json</code> <strong>打包安卓ios需要 小程序不用管它</strong>文件是应用的配置文件，用于指定应用的名称、图标、权限等。</p><p><code>App.vue</code>是我们的跟组件，所有页面都是在<code>App.vue</code>下进行切换的，是页面入口文件，可以调用应用的生命周期函数。</p><p><code>main.js</code>是我们的项目入口文件，主要作用是初始化<code>vue</code>实例并使用需要的插件。</p><p><code>uni.scss</code>文件的用途是为了方便整体控制应用的风格。比如按钮颜色、边框风格，<code>uni.scss</code>文件里预置了一批scss变量预置。</p><p><code>dist</code> 就是运行打包目录，在这里有各个平台的打包文件</p><p><code>pages</code> 所有的页面存放目录</p><p><code>static</code> 静态资源目录，例如图片等</p><p>为了实现多端兼容，综合考虑编译速度、运行性能等因素，<code>uni-app</code> 约定了如下开发规范：</p><ul><li>页面文件遵循 <a href="https://vue-loader.vuejs.org/zh/spec.html" target="_blank" rel="noopener">Vue 单文件组件 (SFC) 规范</a></li><li>组件标签靠近小程序规范，详见<a href="https://uniapp.dcloud.io/component/README" target="_blank" rel="noopener">uni-app 组件规范</a></li><li>接口能力（JS API）靠近微信小程序规范，但需将前缀 <code>wx</code> 替换为 <code>uni</code>，详见<a href="https://uniapp.dcloud.io/api/README" target="_blank" rel="noopener">uni-app接口规范</a></li><li>数据绑定及事件处理同 <code>Vue.js</code> 规范，同时补充了App及页面的生命周期</li><li>为兼容多端运行，建议使用flex布局进行开发</li></ul><h3 id="uni-app的语法介绍"><a href="#uni-app的语法介绍" class="headerlink" title="uni-app的语法介绍"></a>uni-app的语法介绍</h3><p><strong>对比小程序–uni他帮我们封装了成了vue语法 更方便</strong></p><h4 id="全局配置和页面配置"><a href="#全局配置和页面配置" class="headerlink" title="全局配置和页面配置"></a>全局配置和页面配置</h4><h5 id="通过globalStyle进行全局配置"><a href="#通过globalStyle进行全局配置" class="headerlink" title="通过globalStyle进行全局配置"></a>通过globalStyle进行全局配置</h5><p>用于设置应用的状态栏、导航条、标题、窗口背景色等。<a href="https://uniapp.dcloud.io/collocation/pages?id=globalstyle" target="_blank" rel="noopener">详细文档</a></p><table><thead><tr><th>属性</th><th>类型</th><th>默认值</th><th>描述</th><th></th><th></th></tr></thead><tbody><tr><td>navigationBarBackgroundColor</td><td>HexColor</td><td>#F7F7F7</td><td>导航栏背景颜色（同状态栏背景色）</td><td></td><td></td></tr><tr><td>navigationBarTextStyle</td><td>String</td><td>white</td><td>导航栏标题颜色及状态栏前景颜色，仅支持 black/white</td><td></td><td></td></tr><tr><td>navigationBarTitleText</td><td>String</td><td></td><td>导航栏标题文字内容</td><td></td><td></td></tr></tbody></table><h5 id="通过pages来配置页面-先了解一会项目用"><a href="#通过pages来配置页面-先了解一会项目用" class="headerlink" title="通过pages来配置页面-先了解一会项目用"></a>通过pages来配置页面-先了解一会项目用</h5><table><thead><tr><th>属性</th><th>类型</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>path</td><td>String</td><td></td><td>配置页面路径</td></tr><tr><td>style</td><td>Object</td><td></td><td>配置页面窗口表现，配置项参考 <a href="https://uniapp.dcloud.io/collocation/pages?id=style" target="_blank" rel="noopener">pageStyle</a></td></tr></tbody></table><p>pages    数组数组中第一项表示应用启动页</p><p>​                通过style修改页面的标题和导航栏背景色</p><pre class="line-numbers language-html"><code class="language-html">"pages": [ 、        {            "path": "pages/index/index",            "style": {                "navigationBarTitleText": "uni-app"            }        }    ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="配置tabbar–先了解-一会项目用"><a href="#配置tabbar–先了解-一会项目用" class="headerlink" title="配置tabbar–先了解 一会项目用"></a>配置tabbar–先了解 一会项目用</h5><p>tabBar 配置项   指定 底部tab 栏</p><p>案例代码：</p><pre class="line-numbers language-js"><code class="language-js"><span class="token string">"tabBar"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">"list"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span>                <span class="token string">"text"</span><span class="token punctuation">:</span> <span class="token string">"首页"</span><span class="token punctuation">,</span>                <span class="token string">"pagePath"</span><span class="token punctuation">:</span><span class="token string">"pages/index/index"</span><span class="token punctuation">,</span>                <span class="token string">"iconPath"</span><span class="token punctuation">:</span><span class="token string">"static/tabs/home.png"</span><span class="token punctuation">,</span>                <span class="token string">"selectedIconPath"</span><span class="token punctuation">:</span><span class="token string">"static/tabs/home-active.png"</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                <span class="token string">"text"</span><span class="token punctuation">:</span> <span class="token string">"信息"</span><span class="token punctuation">,</span>                <span class="token string">"pagePath"</span><span class="token punctuation">:</span><span class="token string">"pages/message/message"</span><span class="token punctuation">,</span>                <span class="token string">"iconPath"</span><span class="token punctuation">:</span><span class="token string">"static/tabs/message.png"</span><span class="token punctuation">,</span>                <span class="token string">"selectedIconPath"</span><span class="token punctuation">:</span><span class="token string">"static/tabs/message-active.png"</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span>                <span class="token string">"text"</span><span class="token punctuation">:</span> <span class="token string">"我们"</span><span class="token punctuation">,</span>                <span class="token string">"pagePath"</span><span class="token punctuation">:</span><span class="token string">"pages/contact/contact"</span><span class="token punctuation">,</span>                <span class="token string">"iconPath"</span><span class="token punctuation">:</span><span class="token string">"static/tabs/contact.png"</span><span class="token punctuation">,</span>                <span class="token string">"selectedIconPath"</span><span class="token punctuation">:</span><span class="token string">"static/tabs/contact-active.png"</span>            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="组件标签的基本使用"><a href="#组件标签的基本使用" class="headerlink" title="组件标签的基本使用"></a>组件标签的基本使用</h4><p>uni-app提供了丰富的基础组件 view  text image 等等..</p><p>uni-app中的组件，就像 <code>HTML</code> 中的 <code>div</code> 、<code>p</code>、<code>span</code> 等标签的作用一样，用于搭建页面的基础结构</p><h4 id="uni-app中的数据绑定"><a href="#uni-app中的数据绑定" class="headerlink" title="uni-app中的数据绑定"></a>uni-app中的数据绑定</h4><p>在页面中需要定义数据，和我们之前的vue一摸一样，直接在data中定义数据即可</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      msg<span class="token punctuation">:</span> <span class="token string">'hello-uni'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="插值表达式的使用"><a href="#插值表达式的使用" class="headerlink" title="插值表达式的使用"></a>插值表达式的使用</h5><ul><li><p>利用插值表达式渲染基本数据</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>view</span><span class="token punctuation">></span></span>{{msg}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>view</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="v-for的使用"><a href="#v-for的使用" class="headerlink" title="v-for的使用"></a>v-for的使用</h5><p>data中定以一个数组，最终将数组渲染到页面上</p><pre class="line-numbers language-js"><code class="language-js">data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    arr<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'刘能'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">29</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'赵四'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">39</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'宋小宝'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">49</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'小沈阳'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">59</span> <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用v-for进行循环</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>view v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"(item,i) in arr"</span> <span class="token punctuation">:</span>key<span class="token operator">=</span><span class="token string">"i"</span><span class="token operator">></span>名字：<span class="token punctuation">{</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">-</span>年龄：<span class="token punctuation">{</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>age<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>view<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="uni中的事件"><a href="#uni中的事件" class="headerlink" title="uni中的事件"></a>uni中的事件</h4><h5 id="事件绑定与修改数据"><a href="#事件绑定与修改数据" class="headerlink" title="事件绑定与修改数据"></a>事件绑定与修改数据</h5><p>在uni中事件绑定和vue中是一样的，通过v-on进行事件的绑定，也可以简写为@</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tapHandle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点我啊<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>事件函数定义在methods中</p><pre class="line-numbers language-js"><code class="language-js">data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>     msg<span class="token punctuation">:</span><span class="token string">"你好"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>  tapHandle <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'真的点我了'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 修改数据 </span>    <span class="token keyword">this</span><span class="token punctuation">.</span>msg<span class="token operator">=</span><span class="token string">"msg修改了"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="事件传参"><a href="#事件传参" class="headerlink" title="事件传参"></a>事件传参</h5><ul><li><p>默认如果没有传递参数，事件函数第一个形参为事件对象</p><pre><code>// template&lt;button @click=&quot;tapHandle&quot;&gt;点我啊&lt;/button&gt;// scriptmethods: {  tapHandle (e) {    console.log(e)  }}</code></pre></li><li><p>如果给事件函数传递参数了，则对应的事件函数形参接收的则是传递过来的数据</p><pre><code>// template&lt;button @click=&quot;tapHandle(1)&quot;&gt;点我啊&lt;/button&gt;// scriptmethods: {  tapHandle (num) {    console.log(num)  }}</code></pre></li><li><p>如果获取事件对象也想传递参数</p><pre><code>// template&lt;button @click=&quot;tapHandle(1,$event)&quot;&gt;点我啊&lt;/button&gt;// scriptmethods: {  tapHandle (num,e) {    console.log(num,e)  }}</code></pre></li></ul><h4 id="uni的生命周期"><a href="#uni的生命周期" class="headerlink" title="uni的生命周期"></a>uni的生命周期</h4><p>uni-app 的生命周期 把 vue  与 小程序的 结合起来了</p><h5 id="应用的生命周期"><a href="#应用的生命周期" class="headerlink" title="应用的生命周期"></a>应用的生命周期</h5><p>生命周期的概念：一个对象从创建、运行、销毁的整个过程被成为生命周期。</p><p>生命周期函数：在生命周期中每个阶段会伴随着每一个函数的触发，这些函数被称为生命周期函数</p><p><code>uni-app</code> 支持如下应用生命周期函数：</p><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>onLaunch</td><td>当<code>uni-app</code> 初始化完成时触发（全局只触发一次）</td></tr><tr><td>onShow</td><td>当 <code>uni-app</code> 启动，或从后台进入前台显示</td></tr><tr><td>onHide</td><td>当 <code>uni-app</code> 从前台进入后台</td></tr><tr><td>onError</td><td>当 <code>uni-app</code> 报错时触发</td></tr></tbody></table><h5 id="页面的生命周期"><a href="#页面的生命周期" class="headerlink" title="页面的生命周期"></a>页面的生命周期</h5><p><code>uni-app</code> 支持如下页面生命周期函数：</p><table><thead><tr><th>函数名</th><th>说明</th><th>平台差异说明</th><th>最低版本</th></tr></thead><tbody><tr><td>onLoad</td><td>监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参），参考<a href="https://uniapp.dcloud.io/api/router?id=navigateto" target="_blank" rel="noopener">示例</a></td><td></td><td></td></tr><tr><td>onShow</td><td>监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面</td><td></td><td></td></tr><tr><td>onReady</td><td>监听页面初次渲染完成。</td><td></td><td></td></tr><tr><td>onHide</td><td>监听页面隐藏</td><td></td><td></td></tr><tr><td>onUnload</td><td>监听页面卸载</td><td></td><td></td></tr></tbody></table><h4 id="uniapp使用其他问题"><a href="#uniapp使用其他问题" class="headerlink" title="uniapp使用其他问题"></a>uniapp使用其他问题</h4><p>我们平时开发vue  经常下一些 包来使用 比如 element ui  vant等等普通页面ui框架</p><p><a href="https://ask.dcloud.net.cn/article/35489" target="_blank" rel="noopener"><strong>uniapp使用其他组件</strong></a>    </p><p><a href="https://uniapp.dcloud.io/component/README" target="_blank" rel="noopener">uni-自带的ui</a></p><p><a href="https://ext.dcloud.net.cn/" target="_blank" rel="noopener">各种插件</a></p><pre><code>缺点：基本上 只能使用它自己官网的  其他的不行为什么?  因为支持 8 种代码 编译各种小程序 ios 安卓 h5        很多其他组件 是支持一个不支持一个的  使用 基本都使用uniapp自带的</code></pre><p><strong>使用 uniapp写代码 自己写   有特殊需要 去他官网找</strong></p><p>  如果公司非要用 uniapp      用来写 小程序 比较多</p><p>注意：平时 大部分 肯定是正常  vue 写pc端 写移动端</p><h3 id="开发的一般流程"><a href="#开发的一般流程" class="headerlink" title="开发的一般流程"></a>开发的一般流程</h3><p>产品提出需求 画出原型图–&gt; 开会评审–&gt;安排工期(各部门商量)—</p><p>​                        —&gt;ui设计图–&gt;前端开发(后端开发 顺序不一定)–&gt;搞完 测试 —&gt;上线—&gt;回测—&gt;维护项目</p><h3 id="ugo黑马优购项目介绍"><a href="#ugo黑马优购项目介绍" class="headerlink" title="ugo黑马优购项目介绍"></a>ugo黑马优购项目介绍</h3><p>小程序资料–&gt;看图（打开ugo）</p><h3 id="ps的基本使用"><a href="#ps的基本使用" class="headerlink" title="ps的基本使用"></a>ps的基本使用</h3><p>psd 文件–&gt;公司 ui给你这个  –我在小程序资料 准备了elem-psd</p><p>图片  辛苦点  我们目前就用他</p><h4 id="测量-宽高距离"><a href="#测量-宽高距离" class="headerlink" title="测量 宽高距离"></a>测量 宽高距离</h4><p><img src="%E9%87%8F%E8%B7%9D%E7%A6%BB%E5%AE%BD%E9%AB%98.png" alt></p><h4 id="切片切图"><a href="#切片切图" class="headerlink" title="切片切图"></a>切片切图</h4><p>步骤：</p><p>​    ① 利用切片选中图片 ：利用切片工具手动划出</p><p><img src="1498466173246.png" alt="1571301270696"> </p><p>​    ② 导出选中的图片：文件菜单  →  存储为 web 设备所用格式  →  选择我们要的图片格式 →  存储 </p><p><strong>测试切 底部图标</strong></p><h3 id="接下来-项目直接上手"><a href="#接下来-项目直接上手" class="headerlink" title="接下来 项目直接上手"></a>接下来 项目直接上手</h3><p>配置 顶部导航栏 与底部tabbar标签切换</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组织结构图插件</title>
      <link href="/2020/04/20/zu-zhi-jie-gou-tu-cha-jian/"/>
      <url>/2020/04/20/zu-zhi-jie-gou-tu-cha-jian/</url>
      
        <content type="html"><![CDATA[<p><a href="https://spiritree.github.io/vue-orgchart/#/zh-cn/quickstart" target="_blank" rel="noopener">vue-orgchart</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v-show 绑定list.length时失效</title>
      <link href="/2020/04/16/uni-app-v-show-bang-ding-list.length-shi-shi-xiao/"/>
      <url>/2020/04/16/uni-app-v-show-bang-ding-list.length-shi-shi-xiao/</url>
      
        <content type="html"><![CDATA[<h1 id="uni-app-微信小程序bug-v-show-绑定list-length时失效"><a href="#uni-app-微信小程序bug-v-show-绑定list-length时失效" class="headerlink" title="uni-app 微信小程序bug: v-show 绑定list.length时失效"></a>uni-app 微信小程序bug: v-show 绑定list.length时失效</h1><h2 id="源头"><a href="#源头" class="headerlink" title="源头"></a>源头</h2><p><a href="https://developers.weixin.qq.com/community/develop/doc/000c8ee47d87a0d5b6685a8cb57000" target="_blank" rel="noopener">点击访问</a></p><h2 id="我的解决办法"><a href="#我的解决办法" class="headerlink" title="我的解决办法"></a>我的解决办法</h2><blockquote><ol><li>使用 <code>v-if</code> 代替</li><li>嵌套一层<code>view</code> 在<code>view</code>中写<code>v-show</code></li><li>写在计算属性中, 总体思路是转化成布尔值<code>Boolean</code></li></ol><pre class="line-numbers language-js"><code class="language-js">v<span class="token operator">-</span>show<span class="token operator">=</span><span class="token string">"show"</span>computed<span class="token punctuation">:</span><span class="token punctuation">{</span>      <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">.</span>length      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue部分相关的面试题</title>
      <link href="/2020/04/07/vue-xiang-guan-yi-nan/"/>
      <url>/2020/04/07/vue-xiang-guan-yi-nan/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue部分相关的面试题"><a href="#Vue部分相关的面试题" class="headerlink" title="Vue部分相关的面试题"></a>Vue部分相关的面试题</h1><h2 id="如何在组件中监听Vuex的数据变化"><a href="#如何在组件中监听Vuex的数据变化" class="headerlink" title="如何在组件中监听Vuex的数据变化"></a>如何在组件中监听Vuex的数据变化</h2><blockquote><p>分析:   此题考查Vuex的应用及 Vue内部的监听数据变化的机制  </p></blockquote><blockquote><p><strong><code>解答</code></strong>:  首先确定 Vuex是为了解决什么问题而出现的 ?  Vuex是为了解决组件间状态共享而出现的一个框架.</p><p>其中有几个要素 是组成Vuex的关键,  state(状态)  mutations  actions  ,</p><p>state 表示 需要共享的状态数据</p><p>mutations  表示 更改 state的方法集合  只能是同步更新 不能写ajax等异步请求</p><p>actions  如果需要做异步请求  可以在actions中发起 然后提交给 mutations mutation再做同步更新</p></blockquote><p>也就是 state 负责管理状态 ,  mutation负责同步更新状态 action负责 异步获取数据 同提交给mutation</p><blockquote><p>所以 组件监听Vuex数据变化 就是 监听 Vuex中state的变化, </p></blockquote><p><strong><code>第一种方案</code></strong>  我们可以在组件中通过组件的 watch方法来做, 因为组件可以将state数据映射到 组件的计算属性上,</p><p>然后 监听 映射的计算属性即可 代码如下</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// vuex中的state数据</span>  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>    count<span class="token punctuation">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//  A组件中映射 state数据到计算属性</span>  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'count'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// A组件监听 count计算属性的变化</span>   watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>    count <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 用本身的数据进行一下计数</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>changeCount<span class="token operator">++</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20200217103409496.png" alt="image-20200217103409496"></p><p><strong><code>第二种方案</code></strong>   vuex中store对象本身提供了<strong><code>watch</code></strong>函数 ,可以利用该函数进行监听</p><ul><li><strong>watch(fn: Function, callback: Function, options?: Object): Function</strong></li></ul><p>响应式地侦听 <code>fn</code> 的返回值，当值改变时调用回调函数。<code>fn</code> 接收 store 的 state 作为第一个参数，其 getter 作为第二个参数。最后接收一个可选的对象参数表示 Vue 的 <a href="https://cn.vuejs.org/v2/api/#vm-watch" target="_blank" rel="noopener"><code>vm.$watch</code></a> 方法的参数。</p><p>代码</p><pre class="line-numbers language-js"><code class="language-js">  created <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> getters<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> state<span class="token punctuation">.</span>count    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>changeCount<span class="token operator">++</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>以上代码 均在示例有体现</p></blockquote><p>vue-cli项目 中router  </p><p>history模式  /地址  =&gt; 一定会引起向服务端发请求 ,需要服务器配合,需要服务器做配合, 无论地址怎么变化, 返回都是一个页面,这样页面就不会强制刷新, 开发时  用的脚手架本身支持, 如果上线, 需要ngix 服务器配置,单页应用 无论地址怎么变化 </p><p>hash模式    #/地址  =&gt; #的变化不会引起 页面的刷新</p><blockquote><p> 脚手架中 可能会频繁遇到环境变量</p></blockquote><p>dev环境    测试环境   预发布环境  生产环境 </p><p>每个环境的地址 和域名可能不一样,如果你的项目需要上线,  不需要手动的 根据环境 来切换参数</p><p>把一些需要根据环境变化的参数 变成环境变量, 运维会在不同的环境中将 不同的环境变量写入, 此时你的代码 编译之后就是带当时的环境变量的了</p><h2 id="Vue单页面和多页面的混合使用"><a href="#Vue单页面和多页面的混合使用" class="headerlink" title="Vue单页面和多页面的混合使用"></a>Vue单页面和多页面的混合使用</h2><blockquote><p>分析: 首先分析,单页面应用和 多页面应用的根本区别 </p><p><strong><code>解答</code></strong>:  单页面即所有的模块统统置于一个html文件之上,切换模块,不会重新对html文件和资源进行再次请求,服务器不会对我们<strong><code>换页面</code></strong>的动作 产生任何反应, 所以我们感觉不到任何的刷新动作,速度和体验很畅快</p><p>多页面应用 即多个html页面 共同的使用, 可以认为一个页面即一个模块,但是不排除 多个单页应用混合到一起的组合情况 ,  多页面切换一定会造成 页面资源的重新加载, 这也就意味着 如果 多页面之间切换,一定会造成很数据的<strong><code>重置</code></strong></p><p>​    所以在 Vue的单页面 和多页面混合使用的时候,需要注意, 如果 不论是单页  跳到多页 ,还是多页跳到单页,都会造成页面内容的重置. 多页面我们不用关心,因为重置本就是多页面的特性,但是单页不一样, 很多变量或者数据 可能会因为 重置归零或者重置,所以我们应该 重点检查 单页每个页面的业务 在刷新页面之后, 能否保证业务的连贯性,  这些都可以通过<strong><code>导航守卫</code></strong>来进行处理, 也就是一进入单页的路由,就检查业务的连贯性.</p></blockquote><h2 id="vuex怎么合理规范管理数据-及mutations和actions区别"><a href="#vuex怎么合理规范管理数据-及mutations和actions区别" class="headerlink" title="vuex怎么合理规范管理数据,及mutations和actions区别"></a>vuex怎么合理规范管理数据,及mutations和actions区别</h2><blockquote><p>解析: 此题考查 vuex中数据的管理和数据结构的设计,还有mutations 和actions的区别</p></blockquote><blockquote><p><strong><code>解答</code></strong> : 首先要明确一个特别重要的原则, 就是 不是所有的数据都要放在vuex中, 因为vuex有一句名言:假如你并不知道为什么要使用vuex,那就不要使用它 !</p><p> 那么什么样式的数据需要放在vuex中呢 ? 首先这个数据肯定要被多个组件频繁用到, 如果只是被一个组件 用到, 那完全没有任何必要为了使用vuex和使用vuex</p></blockquote><p>举例:  一个网站用户的昵称,账号,资料,像这种系统级别的信息 随时可能在业务中展示,使用, 如果在组件中存储, 那么要获取N次, 所以<strong><code>系统级别的数据</code></strong>是需要放置在vuex中的, 那么系统级别数据 也不能随意的放置,为了让数据看着更有层级结构感,可以按照像下面这样设计,  </p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    // 系统消息    system<span class="token operator">:</span> <span class="token punctuation">{</span>        user<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        setting<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上面这种结构,一看 便知道我们应该哪里获取系统数据即 设置数据</p></blockquote><p>如果有些业务数据,也需要共享,最好按照模块的具体业务含义分类 , 比如下面</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    // 系统消息    system<span class="token operator">:</span> <span class="token punctuation">{</span>        user<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        setting<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    product<span class="token operator">:</span> <span class="token punctuation">{</span>        productList<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> // 商品信息列表        productOrders<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> // 商品订单啊列表    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如上图代码所示,我们很清晰的能够分清楚 每个模块的数据,这样不会导致数据管理的混乱</p></blockquote><h3 id="mutations和-actions-的区别"><a href="#mutations和-actions-的区别" class="headerlink" title="mutations和 actions 的区别"></a>mutations和 actions 的区别</h3><blockquote><p>不同于redux只有一个action, vuex单独拎出了一个mutations,  它认为 更新数据必须是同步的, 也就是只要调用了 提交数据方法, 就会得到一个当前的<strong><code>状态快照</code></strong>,提交一个mutation就会得到一个<strong><code>快照</code></strong></p><p>那么如果我们想做 异步请求,怎么做?  这里 vuex提供了专门做异步请求的模块,action, 当然action中也可以做同步操作, 只不过 分工更加明确, 所有的数据操作 不论是同步还是异步 都可以在action中完成, </p><p>mutation只负责接收状态, 同步完成 <strong><code>数据快照</code></strong></p><p>所以可以认为 </p><p>state =&gt; 负责存储状态 </p><p>mutations =&gt; 负责同步更新状态</p><p>actions =&gt; 负责获取 处理数据, 提交到mutation进行状态更新</p></blockquote><h2 id="vuex模块化管理-使用的时候有注意事项"><a href="#vuex模块化管理-使用的时候有注意事项" class="headerlink" title="vuex模块化管理,使用的时候有注意事项"></a>vuex模块化管理,使用的时候有注意事项</h2><blockquote><p>分析: 此题考查 当vuex维护的数据越来越复杂的时候, 模块化的解决方案</p><p><strong><code>解析</code></strong>:使用单一的状态树，应用的所有状态都会<strong><code>集中在一个比较大的对象</code></strong>上面，随着项目需求的不断增加，状态树也会变得越来越臃肿，增加了状态树维护的复杂度,而且代码变得沉长；因此我们需要<strong><code>modules(模块化)</code></strong>来为我们的状态树<strong><code>分隔</code></strong>成不同的模块，每个模块拥有自己的state，getters，mutations，actions；而且允许每个module里面嵌套子module；如下：</p><pre><code> store    ├── index.js          # 我们组装模块并导出 store 的地方    ├── actions.js        # 根级别的 action    ├── mutations.js      # 根级别的 mutation    ├── state.js          # 根级别的 state    └── modules        ├── module1.js   # 模块1的state树        └── module2.js   # 模块2的state树</code></pre></blockquote><p>上面的设计中, 每个vuex子模块都可以定义 state/mutations/actions</p><blockquote><p>需要注意的是  我们原来使用<strong><code>vuex辅助函数</code></strong>  mapMutations/mapActions  引入的是 全局的的mutations 和actions , 并且我们vuex子模块  也就是module1,module2 … 这些模块的aciton /mutation 也注册了全局, </p><p>也就是如果 module1 中定义了 updateUser , module2中也定义了 updateUser, 此时, mutation就冲突了</p><p>如果重名,就报错了…..</p><p>如果不想冲突, 各个模块管理自己的action 和 mutation ,需要 给我们的子模块一个 属性 <strong><code>namespaced: true</code></strong></p></blockquote><p>那么 组件中怎么使用子模块的action 和 mutations</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文</span>methods <span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'updateUser'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 引用A模块的mptations方法 </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>此题具体考查 Vuex虽然是一个公共状态, 但是公共状态还可以切分成若干个子状态模块, 也就是moudels,</p><p>解决当我们的状态树过于庞大和复杂时的一种解决方案.  但是笔者认为, 一旦用了vuex, 几乎 就认定该项目是较为复杂的</p></blockquote><p><a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener">参考文档</a></p><h2 id="封装Vue组件的步骤"><a href="#封装Vue组件的步骤" class="headerlink" title="封装Vue组件的步骤"></a>封装Vue组件的步骤</h2><blockquote><p>分析: 本题考查 对于Vue组件化开发的熟练程度</p><p><strong><code>解析</code></strong>: 首先明确 组件是本质是什么?  </p><p>组件就是一个单位的HTML结构 + 数据逻辑 + 样式的 操作单元 </p><p>Vue的组件 继承自Vue对象, Vue对象中的所有的属性和方法,组件可自动继承. </p><p>组件的要素  template  =&gt;  作为页面的模板结构 </p><p>script  =&gt; 作为数据及逻辑的部分</p><p>style  =&gt; 作为该组件部分的样式部分</p></blockquote><p>要封装一个组件,首先要明确该组件要做的具体业务和需求,  什么样的体验特征, 完成什么样的交互, 处理什么样的数据</p><blockquote><p>明确上述要求之后, 着手模板的结构设计及搭建,也就是 常说的html结构部分,  先完成 静态的html结构</p><p>结构完成, 着手数据结构的设计及开发, 数据结构一般存储于组件的data属性 或者 vuex 状态共享的数据结构</p><p>数据设计完成/ 结构完成  接下来 完成数据和模块的结合 , 利用vuejs中指令和 插值表达式的特性 将静态结构 <strong><code>动态化</code></strong></p><p>展现的部分完成, 接下来完成<strong><code>交互部分</code></strong>,即利用 组件的生命周期的钩子函数 和 事件驱动 来完成 逻辑及数据的处理与操作</p></blockquote><p>最后组件完成,进行测试及使用</p><p>常用的组件属性 =&gt; data/ methods/filters/ components/watch/created/mounted/beforeDestroy/computed/props</p><p>常用组件指令: v-if/v-on/v-bind/v-model/v-text/v-once</p><h2 id="Vue中的data是以函数的形式还是对象的形式表示"><a href="#Vue中的data是以函数的形式还是对象的形式表示" class="headerlink" title="Vue中的data是以函数的形式还是对象的形式表示"></a>Vue中的data是以函数的形式还是对象的形式表示</h2><blockquote><p>分析: 此题考查 data的存在形式</p></blockquote><blockquote><p><strong><code>解析</code></strong>: 我们在初步学习Vue实例化的时候写的代码时这个样子</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>        name<span class="token punctuation">:</span> <span class="token string">'hello world'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中的data 是一个对象, 但是我们在开发组件的时候要求data必须是一个带返回值的函数</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'张三'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>为什么组件要求必须是带返回值的函数?  因为 我们的组件在实例化的时候, 会直接将data数据作用在视图上, </p><p>对组件实例化, 会导致我们组件的data数据进行共享, 好比  现在有两辆新车, 你一踩油门, 不光你的车往前走,另辆车也和你一样往前冲!   这显然不符合我们的程序设计要求, 我们希望组件内部的数据是相互独立的,且互不响应,所以 采用   <strong><code>return {}</code></strong>  每个组件实例都返回新对象实例的形式,保证每个组件实例的唯一性</p></blockquote><h2 id="使用Proxy代理跨域"><a href="#使用Proxy代理跨域" class="headerlink" title="使用Proxy代理跨域"></a>使用Proxy代理跨域</h2><blockquote><p>分析: 本题考查如何解决跨域问题</p><p>解析: 解决跨域问题的方式有几种,一种是服务端设置 all-control-origin * , 但这种方式依赖服务端的设置,在前后分离的场景下 ,不太方便</p><p>还有一种jsonp形式, 可以利用script标签 的特性解决同源策略带来的跨域问题,但这是这种方案对于请求的类型有限制,只能get/post</p><p>还有一种就可以在开发环境(本地调试)期间,进行代理, 说白了 就是通过 在本地通过nodejs 启动一个微型服务, </p><p>然后我们先请求我们的微型服务, 微型服务是服务端, 服务端<strong><code>代我们</code></strong>去请求我们想要的跨域地址, 因为服务端是不受<strong><code>同源策略</code></strong>的限制的, 具体到开发中,打包工具webpack集成了代理的功能,可以采用配置webpack的方式进行解决, 但是这种仅限于 本地开发期间, 等项目上线时,还是需要另择代理 ngix</p></blockquote><p>以下为webpack配置代理的配置 </p><pre class="line-numbers language-json"><code class="language-json"> // 代理设置 proxy<span class="token operator">:</span> <span class="token punctuation">{</span>    '/api'<span class="token operator">:</span> <span class="token punctuation">{</span>        target<span class="token operator">:</span> 'http<span class="token operator">:</span>//www.baidu.com/'<span class="token punctuation">,</span>        changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        pathRewrite<span class="token operator">:</span> <span class="token punctuation">{</span>            '^/api'<span class="token operator">:</span> ''        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>target</code></strong>：接口域名；</p><p> <strong><code>changeOrigin</code></strong>： 如果设置为<code>true</code>,那么本地会虚拟一个服务端接收你的请求并代你发送该请求；</p><p> <strong><code>pathRewrite</code></strong>：如果接口中是没有api的，那就直接置空（如上）如果接口中有api，就需要写成{‘^/api’:‘/api’}</p><p>真实访问地址  <a href="http://www.baidu.com/test" target="_blank" rel="noopener">http://www.baidu.com/test</a> </p><p>/api/test  =&gt;  /api 就是 表示  <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>  =&gt;webpack 后台 发出的请求(<a href="http://www.baidu.com/test" target="_blank" rel="noopener">http://www.baidu.com/test</a> )=&gt;  返回结果  =&gt; 前端</p><p>反向代理  =&gt;   前端   =&gt; 后台 不让你访问 (跨域)</p><p>   前端 =&gt; webpack后台 (代理)(仅限于本地开发模式)     =&gt;后台</p><h2 id="Vue中的watch如何深度监听某个对象"><a href="#Vue中的watch如何深度监听某个对象" class="headerlink" title="Vue中的watch如何深度监听某个对象"></a>Vue中的watch如何深度监听某个对象</h2><blockquote><p>分析: 此题考查Vue的选项watch的应用方式</p><p>解析:  watch最基本的用法是 </p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'张三'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>        name <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中: 有个原则监听谁,写谁的名字,然后是对应的执行函数, 第一个参数为最新的改变值,第二个值为上一次改变的值, 注意: 除了监听 data,也可以监听<strong><code>计算属性</code></strong> 或者一个 函数的计算结果</p><p>那怎么深度监听对象 ,两种方式</p><ol><li>字符串嵌套方式</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>           a<span class="token punctuation">:</span> <span class="token punctuation">{</span>               b<span class="token punctuation">:</span> <span class="token punctuation">{</span>                   c <span class="token punctuation">:</span><span class="token string">'张三'</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">"a.b.c"</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>启用深度监听方式</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>           a<span class="token punctuation">:</span> <span class="token punctuation">{</span>               b<span class="token punctuation">:</span> <span class="token punctuation">{</span>                   c <span class="token punctuation">:</span><span class="token string">'张三'</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>        a<span class="token punctuation">:</span> <span class="token punctuation">{</span>            deep<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// deep 为true  意味着开启了深度监听 a对象里面任何数据变化都会触发handler函数,</span>            <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// handler是一个固定写法</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></blockquote><h2 id="Vue-keep-alive使用"><a href="#Vue-keep-alive使用" class="headerlink" title="Vue keep-alive使用"></a>Vue keep-alive使用</h2><blockquote><p>分析: 此题考查Vue中组件缓存的使用 </p><p>解析:  keep-alive是 Vue提供的一个全局组件, Vue的组件是有销毁机制的,比如条件渲染, 路由跳转时 组件都会经历<strong><code>销毁</code></strong>, 再次回到页面时,又会回到 <strong><code>重生</code></strong>, 这一过程保证了生命周期钩子函数各个过程都会在这一生命周期中执行.</p><p>但是,我们辛辛苦苦获取的数据 滑动的页面 会因为组件的销毁 重生 而 <strong><code>归零</code></strong>,这影响了交互的体验, 所以 keep-alvie出现了, 可以帮助我们缓存想要缓存的组件实例, 只用用keep-alive <strong><code>包裹</code></strong>你想要缓存的组件实例, 这个时候, 组件创建之后,就不会再进行 销毁, 组件数据和状态得以保存</p><p>但是,没有了销毁,也就失去了重生的环节, 我们失去了 原有的钩子函数, 所以keep-alive包裹的组件 都获取了另外两个事件 </p><p>唤醒 activited 重新唤醒休眠组件实例时 执行</p><p>休眠 unactiived  组件实例进入休眠状态时执行</p></blockquote><p>但是我们不能缓存所有的组件实例, 如果是针对 组件容器 router-view 这个组件进行的缓存, 一般的策略是在路由的元信息 meta对象中设置是否缓存的标记,  然后根据标记决定是否进行缓存</p><pre class="line-numbers language-js"><code class="language-js">  <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 里面是当需要缓存时 <span class="token operator">--</span><span class="token operator">></span>      <span class="token operator">&lt;</span>router<span class="token operator">-</span>view  v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"$route.meta.isAlive"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">></span>     <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 外面是不需要缓存时 <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>router<span class="token operator">-</span>view  v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"!$route.meta.isAlive"</span> <span class="token operator">/</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有需要注意的问题是:  被缓存的组件中如果还有子组件, 那么子组件也会一并拥有 激活和唤醒事件,并且这些事件会在同时执行</p><h2 id="vue的双向数据绑定原理是什么"><a href="#vue的双向数据绑定原理是什么" class="headerlink" title="vue的双向数据绑定原理是什么"></a>vue的双向数据绑定原理是什么</h2><blockquote><p>分析 :此题考查 Vue的MVVM原理</p><p><strong><code>解答</code></strong>:  Vue的双向绑定原理其实就是MVVM的实现原理, Vuejs官网已经说明, 实际就是通过 Object.defineProperty方法 完成了对于Vue实例中数据的 <strong><code>劫持</code></strong>, 通过对于 data中数据 set的监听,</p><p>然后通过<strong><code>观察者模式</code></strong>, 通知 对应的绑定节点 进行节点数据更新, 完成数据驱动视图的更新</p></blockquote><p>我们实现的MVVM是一个简易版本</p><p>我们并没有做虚拟DOM, 虚拟DOM的问题</p><p>虚拟DOM,并不是真正的DOM, 数据驱动视图, 数据变化  =&gt;  数据 切换成 虚拟DOM, </p><p>新的虚拟DOM 会和 旧的虚拟DOM 进行 diff比较算法, 比较 得出 需要更新的结果, 反映到dom上</p><p>diff比较 =&gt;  其实就是 用一种时间时间复杂度比较低的方式去更新</p><p>新节点    和 旧节点 完成 比较 ,时间复杂度 O(n^n^n), </p><p>diff 比较算法 时间复杂度 是 O(n)  =&gt;   diff 比较算法 只比较同级的节点, 如果同级节点不一致, 就不再比较子级了,</p><p>性能比较高的算法.</p><blockquote><p><a href="https://www.jianshu.com/p/af0b398602bc" target="_blank" rel="noopener">虚拟dom和diff比较</a>    此问题 仅仅存于面试</p></blockquote><p>Vue/React  不推荐 移动节点, 不推荐改变节点的名称, </p><p>旧节点</p><blockquote><p>同理, 通过对于节点的表单值改变事件的监听,  执行对于数据的修改</p></blockquote><p>简单概述 : 通过Object.defineProperty 完成对于数据的劫持, 通过观察者模式, 完成对于节点的数据更新</p><h2 id="页面刷新了之后vuex中的数据消失怎么解决"><a href="#页面刷新了之后vuex中的数据消失怎么解决" class="headerlink" title="页面刷新了之后vuex中的数据消失怎么解决"></a>页面刷新了之后vuex中的数据消失怎么解决</h2><blockquote><p>分析:此题考查 如果将vuex数据进行本地持久化</p><p><strong><code>解析</code></strong>: vuex数据位于内存, 页面的刷新重置会导致数据的<strong><code>归零</code></strong>,也就是所谓的消失,  本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage ,  </p><p>如果需要保持的更长久 ,浏览器关掉 再打开依然存有数据,需要使用后者 </p><p>实施方案:  state的持久化 也就是分别需要在 state数据初始化 /更新 的时候 进行读取和设置本地存储操作</p><p>代码如下 </p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>   state<span class="token punctuation">:</span> <span class="token punctuation">{</span>       user<span class="token punctuation">:</span> localStorge<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 初始化时读取 本地存储</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>   mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>       updateUser <span class="token punctuation">(</span>state<span class="token punctuation">,</span> payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>           state<span class="token punctuation">.</span>user <span class="token operator">=</span> payload<span class="token punctuation">.</span>user           localStoregae<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">,</span>payload<span class="token punctuation">.</span>user<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 数据更新时 设置本地存储</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="vue做服务端渲染"><a href="#vue做服务端渲染" class="headerlink" title="vue做服务端渲染"></a>vue做服务端渲染</h2><blockquote><p>分析: 为什么要做服务端渲染, 首先要明白 服务端渲染解决什么问题</p><p><strong><code>解析</code></strong>: vuejs 官网说的很明白, 要做服务端渲染首先必须是有对应的需求,即对 实时到达时间(页面访问时间)的绝对需求.  如果只是简单的一个管理系统, 区区几百毫秒的优化 显得十分小题大做.</p><p>服务端渲染这里 有一个成熟优秀的框架 nuxt.js , 正如next.js对于react,nuxt是vue服务端渲染的优秀解决方案</p></blockquote><p>我们几乎可以像原来一样的去开发组件,页面, nuxt帮我们集成了原有项目的插件,模块, 提供了预加载数据事件</p><p>asyncData, 在客户端实现对于服务端内容的<strong><code>完美接管</code></strong></p><p>只不过 这里我们的路由开发方式,需要遵循nuxt.js制定的特殊规范,比如,动态 路由需要 <strong><code>下划线前缀</code></strong>, 嵌套路由需要</p><p>同名组件的文件下下建立组件,并在 同名组件中 加入 nuxt-child 作为 容器  ….</p><blockquote><p>nuxt的出现可以让渲染内容完全服务端化,解决seo不够友好, 首屏渲染速度不够迅速的问题,</p><p>但是这里需要注意: 并不是所有页面都需要服务端渲染, 因为服务端渲染比重多大 对于服务器的访问处理能力 要求也会急剧增大</p></blockquote><p><a href="https://zh.nuxtjs.org/" target="_blank" rel="noopener">nuxt.js官网</a></p><h2 id="双向数据绑定和vuex冲突解决方案"><a href="#双向数据绑定和vuex冲突解决方案" class="headerlink" title="双向数据绑定和vuex冲突解决方案"></a>双向数据绑定和vuex冲突解决方案</h2><blockquote><p>分析: 此题考查 当Vuex数据想要进行逆向操作,也就是 双向数据流向的解决方案</p><p><strong><code>解析</code></strong>:   vuex的数据对于组件来说,默认是不可改的, 但是如果我们就是想改, 可以利用 computed计算属性的另一个方法 , 我们知道计算属性 默认是数据的getter实现, 但是我们可以采用 对于 计算属性 同时get/set的实现,</p><p>双向数据流 中 当对 计算属性设置时 ,就可以通过 store对象进行再次的mutations提交 </p><p>具体代码如下</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>state<span class="token punctuation">:</span> <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token string">''</span> <span class="token comment" spellcheck="true">// 定义value数据 作为vuex状态数据</span><span class="token punctuation">}</span><span class="token punctuation">,</span>mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span> addCount <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>   state<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 定义mutations方法 作为 提交mutations的方法</span> updateValue <span class="token punctuation">(</span>state<span class="token punctuation">,</span> payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>   state<span class="token punctuation">.</span>value <span class="token operator">=</span> payload<span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>actions<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>modules<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue"><code class="language-vue"><template><div>   <div>vuex的双向数据流</div>   <input type="text" v-model="value">   <div>Vuex数据属性: {{value }}</div></div></template><script>import { mapMutations } from 'vuex'export default {methods: { ...mapMutations(['updateValue'])},    // 计算属性的get/setcomputed: { value: {   get () {       // 获取state公共数据     return this.$store.state.value   },    // 通过对 计算属性的set监听 将 数据提交mutations     // 当input中数据变化时 就会调用set中的方法  value就是最新值   set (value) {     this.updateValue({ value: value })  // 在set中提交mutations   } }}}</script><style></style><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="vue-router传参"><a href="#vue-router传参" class="headerlink" title="vue-router传参"></a>vue-router传参</h2><blockquote><p>分析:考查vue-router的传值方式</p><p><strong><code>解析</code></strong>  vue-router 传值 可以通过 地址传值</p><p>最简单的就是url传值, url传值又两种, params 和 query参数传值</p><p>params传值 是指的动态路由传值 </p><pre class="line-numbers language-vue"><code class="language-vue">{  path: '/user/:id' }  // 定义一个路由参数<router-link to="/user/123"></router-link>  // 传值this.$route.params.id   // 取值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>query传值,指通过?后面的拼接参数传值</p><pre class="line-numbers language-vue"><code class="language-vue"><router-link to="/user?id=123"></router-link>  // 传值this.$route.query.id   // 取值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="前端鉴权一般思路"><a href="#前端鉴权一般思路" class="headerlink" title="前端鉴权一般思路"></a>前端鉴权一般思路</h2><blockquote><p>分析: 考查前后分离的鉴权思路</p></blockquote><p><strong><code>解析</code></strong>: 首先要明白 为什么要在前端鉴权? 因为传统项目都是在后端鉴权, 然后通过进行拦截 跳转 对应操作</p><p>因为 我们做的并不是传统的项目,而是前后分离项目,也就是前端项目和后端服务进行了<strong><code>剥离</code></strong>, 后端没有办法用session来存储你任意一个前端项目域名下的身份信息, 所以jwt 鉴权模式应运而生. </p><p>​    也就是后端不再提供会话的身份存储,而是通过一个鉴权接口将用户的身份,登录时间,请求端口,协议头..等等信息 组装成一个加密的串 返给前端请求,  前端拿到了这个串,就可以认为自己登录成功</p><p>那么这个<strong><code>加密串</code></strong>就成了 前端用户是否登录的成功标志, 这就是我们的token , 那么在接下来的接口请求中,我们几乎都要携带这个加密串,因为它是<strong><code>唯一</code></strong>能<strong><code>证明我们身份</code></strong>的信息.</p><p>为了方便,我们会一般在请求工具 axios(举例)的拦截器中<strong><code>统一注入token</code></strong>, 减少代码的重复</p><p>token 同时具有时效性,我们也需要在此时对token过期进行处理,一旦出现过期的请求码, 就需要进行 换取新token 或者重新登录的解决方案</p><p>除此之外,我们还需要依据<strong><code>有无加密串</code></strong> 在前端对于某些页面的访问进行限制, 这个会用到我们的Vue-Router中的导航守卫.</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex</title>
      <link href="/2020/04/07/vuex/"/>
      <url>/2020/04/07/vuex/</url>
      
        <content type="html"><![CDATA[<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>npm install vues --save</code></p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p><code>import Vuex from &#39;vuex&#39;</code></p><p><code>Vue.use(Vuex)</code></p><h2 id="创建store对象"><a href="#创建store对象" class="headerlink" title="创建store对象"></a>创建store对象</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// state 中存放的就是全局共享的数0据</span>    state<span class="token punctuation">:</span> <span class="token punctuation">{</span>        count<span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="将store对象挂载到-vue-实例中"><a href="#将store对象挂载到-vue-实例中" class="headerlink" title="将store对象挂载到 vue 实例中"></a>将store对象挂载到 vue 实例中</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Veu</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>    render<span class="token punctuation">:</span> h <span class="token operator">=</span><span class="token operator">></span> <span class="token function">h</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">,</span>    router<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//将创建的共享数据对象, 挂载到 Vue 实例中</span>    <span class="token comment" spellcheck="true">//所有的组件, 就可以直接从 store 中获取全局的数据了</span>    store<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><blockquote><p>命令行输入 <code>vue ui</code></p><p>选择路径</p><p>点击创建 </p><p>project folder 输入项目名称</p><p>package manageer 选择包管理工具 <code>npm</code></p><p>git repository 输入首次提交git的信息</p><p>点击下一步</p><p>选择手动选择依赖包 <code>Manual</code></p><p>点击下一步</p><p>选择 <code>babel -- router -- linter/formatter --use config files</code></p><p>点击下一步</p><p>选择lint on save , 右侧下拉选择standard config</p><p>点击 create</p><p>是否存为预设</p></blockquote><h2 id="组件中访问-State-中数据的方式"><a href="#组件中访问-State-中数据的方式" class="headerlink" title="组件中访问 State 中数据的方式"></a>组件中访问 State 中数据的方式</h2><p>第一种方式</p><blockquote><p><code>this.$store.state.数据名称</code></p></blockquote><p>第二种方式</p><blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 1. 从 vuex 中按需导入 mapState 函数</span><span class="token keyword">import</span> <span class="token punctuation">{</span> mapState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过导入的 mapState 函数, 将当前组件需要的全局数据, 映射为当前组件的computed 计算属性</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 2. 将全局数据, 映射为当前组件的计算属性</span>computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'count'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="组件中变更-store-中的数据"><a href="#组件中变更-store-中的数据" class="headerlink" title="组件中变更 store 中的数据"></a>组件中变更 store 中的数据</h2><blockquote><p>只能通过mutation 变更 store 数据 , 不可以直接操作 store 中的数据</p><p>通过这种方式虽然操作起来稍微繁琐一些, 但是可以集中监控所有的数据变化</p><pre><code>// 定义 Mutationconst store = new Veux.Store({    state: {        count: 0    },    mutations: {        add(state) {            // 变更状态            state.count++        }    }})</code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 触发 mutation</span>methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    handle <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 触发 mutations 的第一种方式</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'add'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="调用-mutation-时传递参数"><a href="#调用-mutation-时传递参数" class="headerlink" title="调用 mutation 时传递参数"></a>调用 mutation 时传递参数</h2><blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 定义 mutation</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>state<span class="token punctuation">:</span> <span class="token punctuation">{</span>      count<span class="token punctuation">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token function">addN</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> step<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 变更状态</span>          state<span class="token punctuation">.</span>count <span class="token operator">+</span><span class="token operator">=</span> step      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 触发 mutation</span>methods<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token function">handle2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 调用 commit 函数,</span>      <span class="token comment" spellcheck="true">// 触发 mutations 时携带参数</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'addN'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// commit 的作用就是调用某个 mutation 函数</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="调用-mutations-的第二种方式–-mapMutations"><a href="#调用-mutations-的第二种方式–-mapMutations" class="headerlink" title="调用 mutations 的第二种方式– mapMutations"></a>调用 mutations 的第二种方式– mapMutations</h2><blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 从 vuex 中按需导入 mapMutations 函数</span><span class="token keyword">import</span> <span class="token punctuation">{</span> mapMutations <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 将指定的 mutations 函数, 映射为当前组件的 methods 函数</span>methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'add'</span><span class="token punctuation">,</span> <span class="token string">'addN'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><blockquote><p>mutation 不支持异步操作 ,  必须通过 action 用于处理异步任务, 但是在 action 中还是要通过触发 mutation 的方式间接变更数据, 没有直接修改 state 数据的权限</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 定义 action</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...省略一下其他代码</span>    mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">add</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>            state<span class="token punctuation">.</span>count<span class="token operator">++</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">addAsunc</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>            setTimeout <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'add'</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 触发 action</span>methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 触发 actions 的第一种方式</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'addAsync'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这里的dispatch 函数, 专门用来触发 action</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="触发-Action-异步任务时携带参数"><a href="#触发-Action-异步任务时携带参数" class="headerlink" title="触发 Action 异步任务时携带参数"></a>触发 Action 异步任务时携带参数</h2><blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 定义 action</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...省略一下其他代码</span>    metations<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">addN</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> step<span class="token punctuation">)</span> <span class="token punctuation">{</span>            state<span class="token punctuation">.</span>count <span class="token operator">+</span><span class="token operator">=</span> step        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token function">addNAsync</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> step<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                context<span class="token punctuation">,</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'addN'</span><span class="token punctuation">,</span> step<span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 触发 action</span>methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>    handle <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 调用 dispatch 函数,</span>        <span class="token comment" spellcheck="true">// 触发 actions 时携带参数</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'addNAsync'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="触发-Action-异步任务的另外一种方式"><a href="#触发-Action-异步任务的另外一种方式" class="headerlink" title="触发 Action 异步任务的另外一种方式"></a>触发 Action 异步任务的另外一种方式</h2><blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 1. 从 vuex 中按需导入 mapActions 函数</span><span class="token keyword">import</span> <span class="token punctuation">{</span> mapActions <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 2. 将指定的 actions 函数, 因设为当前组件的 methods 函数</span>method<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'addAsync'</span><span class="token punctuation">,</span> <span class="token string">'addNAsync'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 映射后就相当于组件自己的方法, 可以直接使用</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><blockquote><p>getter 用于对 store 中的数据进行加工处理形成新的数据</p><blockquote><p>getter 可以对 store 中已有的数据加工处理之后形成新的数据, 类似于 Vue 的计算属性</p><p>store 中数据发生变化, getter的数据也会跟着变化</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 定义 getter</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    state<span class="token punctuation">:</span> <span class="token punctuation">{</span>        count<span class="token punctuation">:</span> <span class="token number">0</span>     <span class="token punctuation">}</span><span class="token punctuation">,</span>    getters<span class="token punctuation">:</span> <span class="token punctuation">{</span>        showNum<span class="token punctuation">:</span> state <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">'当前最新的数量是['</span> <span class="token operator">+</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span><span class="token string">']'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 使用方式第一种</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>showNum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 使用方式第二种</span><span class="token keyword">import</span> <span class="token punctuation">{</span> mapGetters <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'showNum'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-router</title>
      <link href="/2020/04/07/vuerouter-lu-you/"/>
      <url>/2020/04/07/vuerouter-lu-you/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h1><h2 id="路由的概念与原理"><a href="#路由的概念与原理" class="headerlink" title="路由的概念与原理"></a>路由的概念与原理</h2><blockquote><p>路由的本质就是对应关系</p></blockquote><h3 id="后端路由"><a href="#后端路由" class="headerlink" title="后端路由"></a>后端路由</h3><blockquote><p>概念: 根据不同的URL请求, 返回不同的内容</p><p>本质: URL 请求地址与服务器资源之间的对应关系</p></blockquote><h3 id="SPA-Single-Page-Application"><a href="#SPA-Single-Page-Application" class="headerlink" title="SPA ( Single Page Application)"></a>SPA ( Single Page Application)</h3><blockquote><p>后端渲染 会造成页面的频繁刷新</p><p>Ajax前端渲染 提高性能, 但是不支持浏览器的前进后退</p><p>SPA 单页面应用程序: 整个网站只有一个页面, 内容变化通过Ajax实现, 同时支持浏览器前进后退操作</p><p>SPA实现原理之一: 基于URL地址的<code>hash(锚链接)</code> (hash的变化会导致浏览器记录访问历史变化, 但是hash的变化不会触发新的URL请求)</p><p>实现SPA过程中, 最核心的技术点就是前端路由</p></blockquote><h3 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h3><blockquote><p>概念: 根据不同的<code>用户事件</code>, 显示不同的页面内容</p><p>本质: <code>用户事件</code>与<code>事件处理函数</code>之间的对应关系</p></blockquote><h4 id="简易前端路由"><a href="#简易前端路由" class="headerlink" title="简易前端路由"></a>简易前端路由</h4><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 监听 window 的 onhashchange 事件, 根据获取到的最新的 hash 值, 切换要显示的组件的名称</span>window<span class="token punctuation">.</span>onhashchange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//通过 location.hash 获取到最新的 hash 值</span>    location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 去掉第一个字符 #</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><blockquote><p>Vue.js 官方的<code>路由管理器</code></p><p>它和Vue.js 的核心深度集成</p></blockquote><blockquote><p>Vue Router 支持的功能有:</p><blockquote><p>HTML5历史模式或hash模式</p><p>嵌套路由</p><p>路由参数</p><p>编程式路由</p><p>命名路由</p></blockquote></blockquote><h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><blockquote><p><strong>引入相关的库文件</strong></p><blockquote><p>导入vue文件 , 为全局window 对象挂载 Vue 构造函数</p><p><code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code></p><p>导入 vue-router 文件, 为全局 window 对象挂载 VueRouter 构造函数</p></blockquote><p><strong>添加路由连接</strong></p><blockquote><p>router-link 是 vue 中提供的标签, 默认会被渲染为 a 标签</p><p>to 属性默认会被渲染为 href属性</p><p>to 属性的值默认会被渲染为 # 开头的hash 地址</p><p><code>&lt;router-link to=&quot;/user&quot;&gt;User&lt;/router-link</code></p></blockquote><p><strong>添加路由填充位</strong></p><blockquote><p>路由填充位(也叫<code>路由占位符</code>)</p><p>将来通过路由规则匹配到的组件, 将会被渲染到 router-view 所在的位置</p><p><code>&lt;router-view&gt;&lt;/router-view&gt;</code></p></blockquote><p><strong>定义路由组件</strong></p><pre><code>const User = {    template: &#39;&lt;div&gt;User&lt;/div&gt;&#39;}</code></pre><p><strong>配置路由规则并创建路由实例</strong></p><pre><code>// 创建路由实例对象var router = new VueRouter({    // routers 是路由规则数组    routes: [    // 每个路由规则都是一个配置对象. 至少包含 path 和 component 两个属性:    // path 表示当前路由规则匹配的 hash 地址    // component 表示当前路由规则对应要展示的组件    {path: &#39;/user&#39;, component: User}    ]})</code></pre><p><strong>把路由挂载到Vue 根实例中</strong> </p><pre><code>new Vue ({    el: &#39;#app&#39;,    // 为了能够让路由规则生效, 必须把路由对象挂载到 vue 实例对象上    router: router //把创建的实例对象赋值给 Vue 实例的属性router , 也可以直接简写成一个 router})</code></pre></blockquote><h5 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h5><blockquote><p>访问 地址 A 的时候 , 强制跳转到 B   – redirect</p><pre><code>var router = new VueRouter({    routes:[        {path: &#39;/&#39;, redirect: &#39;/user&#39;},        {path: &#39;/&#39;, component: User}    ]})</code></pre></blockquote><h5 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h5><blockquote><p>父级路由连接显示的模板内容中又有子级路由连接, 点击子路由连接显示子级模板内容</p><blockquote><p>先在父路由组件中添加子路由连接和容器</p><p>然后定义子路由组件</p><p>最后将子路由组件添加到父路由规则的 children 属性中</p></blockquote><pre><code>const User = {    template: `&lt;div&gt;        &lt;h1&gt;User 组件&lt;/h1&gt;        &lt;hr/&gt;        &lt;!-- 子路由连接 --&gt;        &lt;router-link to = &quot;/user/tab1&quot;&gt;tab1&lt;/router-link&gt;        &lt;router-link to = &quot;/user/tab2&quot;&gt;tab2&lt;/router-link&gt;        &lt;!-- 子路由占位符 --&gt;        &lt;router-view/&gt;    &lt;/div&gt;`}</code></pre><pre><code>const Tab1= {    template: &#39;&lt;h3&gt;Tab1子组件&lt;/h3&gt;&#39;}const Tab2= {    template: &#39;&lt;h3&gt;Tab2子组件&lt;/h3&gt;&#39;}</code></pre><pre><code>const router = new VueRouter({    routes:[        {path: &#39;/&#39;, redirect: &#39;/user&#39;},        // children 数组表示子路由规则        {path: &#39;/&#39;, component: User, children:[        {path:&#39;user/tab1&#39;,component: Tab1},        {path:&#39;user/tab2&#39;, component: Tab2}        ]}    ]})</code></pre></blockquote><h5 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h5><blockquote><p>如果路由连接一部分相同一部分是变化的, 我们可以把变化的部分设置成路由参数, </p><p>多个路由共用一个规则,  减少路由规则定义的数量</p><p>设置路由规则:</p><pre><code>var router = new VueRouter({    routes: [        //动态路径参数, 以冒号开头        {path: &#39;/user/:id&#39;, component: User}    ]})</code></pre><p>获取路由参数</p><pre><code>const User = {    // 路由组件中通过$route.params 获取路由参数    template : &#39;&lt;div&gt;User {{ $route.params.id }} &lt;/div&gt;&#39;}</code></pre><p>使用 props </p><pre><code>const router = new VueRouter({    routes: [        // 如果props 被设置为 true, route.params 将会被设置为组件属性        { path: &#39;/user/:id, component: User, props: true}        //props 也可以传递动态参数 props: { uname: &#39;list&#39;, age: 20}    ]})const User= {    props: [&#39;id&#39;], // 使用props 接收路由参数    // props: [&#39;name&#39;,&#39;age&#39;]    templata: &#39;&lt;div&gt;用户ID:{{id}}&lt;/div&gt;&#39; //使用路由参数}</code></pre></blockquote><p>props 的值为函数类型</p><blockquote><pre><code>const router = newVueRouter({    toutes: [        //如果 props 是一个函数, 则这个函数接收route 对象为自己的形参        {        path: &#39;/user/:id&#39;,        component: User,        props: route =&gt; ({ uname:&#39;zs, age: 20, id: route.params.id})        }    ]})const User = {     props: [&#39;uname&#39;,&#39;age&#39;,&#39;id&#39;],    template: `&lt;div&gt;用户信息:{{uname + age + id}}&lt;/div&gt;}</code></pre></blockquote><h5 id="命名路由导航"><a href="#命名路由导航" class="headerlink" title="命名路由导航"></a>命名路由导航</h5><blockquote><pre><code>&lt;router-link :to: &quot;{ name: &#39;user&#39;, params: { id: 3} }&quot;&gt;User3&lt;/router-link&gt;</code></pre><pre><code>给路由规则添加一个 name: &#39;user&#39; 属性</code></pre></blockquote><h5 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h5><blockquote><p>通过点击链接试下导航的方式, 叫做声明式导航</p><p>例如 : a 连接 或者 vue 中的<router-link></router-link> </p><p>通过调用 JavaScript 形式的API 实现导航的方式, 叫做编程式导航</p><p>例如 : 普通网页中的 location.href</p><blockquote><p>this.$router.push(‘hash地址’) // 跳转到对应的地址</p><p>this.$router.go(1)  // 前进或者后退 , 正数表示前进, 负数表示后退</p></blockquote><pre><code>//字符串(路径名称)router.push(&#39;/home&#39;)//对象router.push({ path: &#39;/home&#39;})//命名路由(传递参数)router.push({ name: &#39;/user&#39;, params: {userid: 123}})//带查询参数, 变成 /user?uname=zhangleirouter.push({ path: &#39;/user&#39;, query: { uname: &#39;zhanglei&#39;}})</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode-效率提升</title>
      <link href="/2020/03/01/vscode-xiao-lu-ti-sheng/"/>
      <url>/2020/03/01/vscode-xiao-lu-ti-sheng/</url>
      
        <content type="html"><![CDATA[<h1 id="vscode效率提升"><a href="#vscode效率提升" class="headerlink" title="vscode效率提升"></a>vscode效率提升</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="行-的操作："><a href="#行-的操作：" class="headerlink" title="行 的操作："></a><strong>行</strong> 的操作：</h3><blockquote><ul><li>重开一行：光标在行尾的话，回车即可；不在行尾，<code>Ctrl + enter</code> 向下重开一行；<code>shift + Ctrl + enter</code> 则是在上一行重开一行</li><li>删除一行：光标没有选择内容时，<code>ctrl + x</code> 剪切一行；<code>shift + Ctrl + k</code> 直接删除一行</li><li>移动一行：<code>alt + ↑</code> 向上移动一行；<code>alt + ↓</code> 向下移动一行</li><li>复制一行：<code>shift + alt + ↓</code> 向下复制一行；<code>shift + alt + ↑</code> 向上复制一行</li></ul></blockquote><h3 id="对于-词-的操作："><a href="#对于-词-的操作：" class="headerlink" title="对于 词 的操作："></a>对于 <strong>词</strong> 的操作：</h3><blockquote><ul><li><strong>选中一个词：<code>Ctrl + d</code></strong></li><li>跳转到单词起始位置<code>Ctrl + ←</code> </li><li>跳转到单词末尾位置<code>Ctrl  + →</code></li></ul></blockquote><h3 id="搜索或者替换："><a href="#搜索或者替换：" class="headerlink" title="搜索或者替换："></a>搜索或者替换：</h3><blockquote><ul><li><code>cmd + f</code> ：搜索</li><li><code>cmd + alt + f</code>： 替换</li><li><code>cmd + shift + f</code>：在项目内搜索</li></ul></blockquote><h3 id="格式调整"><a href="#格式调整" class="headerlink" title="格式调整"></a>格式调整</h3><blockquote><ul><li>代码行缩进C<code>trl+[， Ctrl+]   ,</code>或者<code>Tab , Shift+Tab</code></li><li><strong>折叠打开代码块 Ctrl+Shift+[， Ctrl+Shift+]</strong></li><li>Ctrl+C Ctrl+V如果不选中，默认复制或剪切一整行</li><li><strong>代码格式化：<code>Shift+Alt+F</code></strong></li></ul></blockquote><h3 id="同时打开多个编辑器（查看多个文件）"><a href="#同时打开多个编辑器（查看多个文件）" class="headerlink" title="同时打开多个编辑器（查看多个文件）"></a>同时打开多个编辑器（查看多个文件）</h3><blockquote><ul><li>新建文件 Ctrl+N</li><li>历史打开文件之间切换<code>Ctrl+Tab，Alt+Left，Alt+Right</code></li><li>切出一个新的编辑器（最多3个）Ctrl+\，也可以按住Ctrl鼠标点击Explorer里的文件名</li><li>左中右3个编辑器的快捷键Ctrl+1 Ctrl+2 Ctrl+3</li><li><strong>3个编辑器之间循环切换 Ctrl+`</strong></li><li><em>*编辑器换位置，Ctrl+k然后按Left或Right</em></li></ul></blockquote><h3 id="显示相关"><a href="#显示相关" class="headerlink" title="显示相关"></a><strong>显示相关</strong></h3><blockquote><ul><li>全屏：F11</li><li>放大效果：Ctrl +  / Ctrl  -</li><li>侧边栏显/隐：<code>Ctrl+B</code></li><li><strong>预览markdown <code>Ctrl+Shift+V</code></strong></li></ul></blockquote><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><blockquote><p>Ctrl + / –  行注释</p><p>Shift + Alt + A  – 注释选中内容</p></blockquote><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="Chinese-Simplified-Language-Pack-for-Visual-Studio-Code"><a href="#Chinese-Simplified-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="Chinese (Simplified) Language Pack for Visual Studio Code"></a>Chinese (Simplified) Language Pack for Visual Studio Code</h3><blockquote><p>VS Code的中文（简体）语言包。安装后，同时按下Ctrl + Shift + P打开命令面板，之后输入”config”，配置显示语言即可。</p></blockquote><h3 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a><code>Live Server</code></h3><blockquote><p>保存代码后自动刷新页面</p></blockquote><h3 id="Material-Theme"><a href="#Material-Theme" class="headerlink" title="Material Theme"></a>Material Theme</h3><blockquote><p>VS Code最受欢迎、最悠久的主题插件。</p></blockquote><h3 id="Material-Icon-Theme"><a href="#Material-Icon-Theme" class="headerlink" title="Material Icon Theme"></a><strong>Material Icon Theme</strong></h3><blockquote><p>文件管理器（左侧）的 icon 小图标</p></blockquote><h3 id="Markdown插件"><a href="#Markdown插件" class="headerlink" title="Markdown插件"></a>Markdown插件</h3><p><code>Markdown All in One</code></p><p><code>Markdown Preview Github Styling</code>  </p><blockquote><p>第一个插件，是一个组合包，一股脑把最常用的Markdown优化都给你装好；第二个插件，则是Github使用的Markdown渲染样式，不是特别华丽，很朴素，很简洁的样式，因为很多人用Markdown都是为了使用Github Pages，所以这个样式特别受欢迎。使用这个样式，在本地就能预览Markdown文件最终在Github Pages中显示的效果。 </p></blockquote><h2 id="设置代码片段"><a href="#设置代码片段" class="headerlink" title="设置代码片段"></a>设置代码片段</h2><h3 id="创建自己的代码片段"><a href="#创建自己的代码片段" class="headerlink" title="创建自己的代码片段"></a>创建自己的代码片段</h3><blockquote><p>为提高开发效率可创建自己的代码片段</p><p>1、点击设置，打开用户代码片段即可开始创建自己的代码片段；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-预编译</title>
      <link href="/2020/02/22/javascript-yu-bian-yi/"/>
      <url>/2020/02/22/javascript-yu-bian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h1><h2 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h2><blockquote><p><code>imply globle</code> 暗示全局变量 :  未声明直接赋值的的变量归<code>window</code>所有 </p></blockquote><blockquote><p>一切声明的全局变量 , 全是<code>window</code>的属性.</p></blockquote><blockquote><p><code>window</code>就是全局的域</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//window  {</span><span class="token comment" spellcheck="true">//       a :123</span><span class="token comment" spellcheck="true">//}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token operator">===</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote><p>预编译发生在函数执行的前一刻</p><p>四部曲:</p><blockquote><ol><li><p>创建AO 对象 Activation Object (执行期上下文)</p></li><li><p>找形参和变量声明 , 将变量和形参名作为AO属性名,值为<code>undefined</code></p></li><li><p>将实参和形参统一</p></li><li><p>在函数体里面找函数声明, 值赋予函数体 </p></li></ol></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> fn <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//123</span>    <span class="token keyword">function</span> a <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//123 </span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function</span>    <span class="token keyword">function</span> d <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><blockquote><p>预编译发生在全局执行的前一刻</p><p>三部曲</p><p>全局预编译    GO === window</p><ol><li>创建GO</li><li>变量名作为AO的属性名, 值为<code>undefined</code></li><li>在函数体里面找函数声明, 值赋予函数体 </li></ol></blockquote><pre class="line-numbers language-js"><code class="language-js">global <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>global<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//undefined</span>    global <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>global<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//200</span>    <span class="token keyword">var</span> global <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> global<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-正则表达式</title>
      <link href="/2020/02/18/javascript-zheng-ze-biao-da-shi/"/>
      <url>/2020/02/18/javascript-zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式-RegExp"><a href="#正则表达式-RegExp" class="headerlink" title="正则表达式(RegExp)"></a>正则表达式(RegExp)</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/abc/igm</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//字面量定义规则</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true   //正则表达式的方法 , 参数为字符串 , 如果符合则返回true</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//["abc"]  // 字符串的方法,参数为正则表达式 , 返回找到的字符串</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">"abc"</span> <span class="token punctuation">,</span> <span class="token string">"igm"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 构造函数定义规则</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>i</code> 忽略大小写</p><p><code>g</code> 全局匹配</p><p><code>m</code> 多行匹配</p><blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/^a/gm</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ^a 以a开头  g 全局查找  m 换行匹配</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"abc\na"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// `\n`表示换行 ,</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//["a", "a"]  //有m则返回两个a , 去掉则返回一个a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><p><code>^</code>以什么打头 如果放到 []里面则表示非</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/[^a]/</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//非a 查找不是a的单个字符</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token regex">/abc/</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ["b"]   如果加上 g 则返回["b" , "c"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>()</code>优先计算     子表达式    会把括号中匹配的信息也返回</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/(abc|bcd)/</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//匹配abc或者bcd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>$</code> 以什么结尾</p></blockquote></blockquote><h2 id="表达式-和-元字符"><a href="#表达式-和-元字符" class="headerlink" title="表达式 和 元字符"></a>表达式 和 元字符</h2><blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/[能取到的范围]/</span><span class="token punctuation">;</span> \w <span class="token operator">===</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span>9A<span class="token operator">-</span>z_<span class="token punctuation">]</span> \W <span class="token operator">===</span>\w\s <span class="token comment" spellcheck="true">//空白字符 空格 \n换行符  \f换页符  \r回车符  \t制表符 \v垂直制表符</span>\S <span class="token comment" spellcheck="true">//非空白字符  </span>\d  <span class="token operator">===</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span>\D  <span class="token comment" spellcheck="true">//非数字</span>\b  <span class="token comment" spellcheck="true">//单词边界</span>\B  <span class="token comment" spellcheck="true">//非单词边界</span><span class="token comment" spellcheck="true">//存在字符\w和\W相邻,那么这两个字符之间就有单词边界 , 包括字符串首尾</span>    <span class="token keyword">var</span> str6 <span class="token operator">=</span> <span class="token string">"abc_d,123中文_d3=efg汉字a"</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> reg6 <span class="token operator">=</span> <span class="token regex">/[\d\D]\b/g</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str6<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//["d", ",", "3", "文", "3", "=", "g", "字", "a"]  // 匹配的是 右边存在单词边界的字符</span> <span class="token punctuation">.</span>  <span class="token operator">===</span> <span class="token punctuation">[</span><span class="token operator">^</span>\r\n<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">//非回车换行符的任意字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><blockquote><p><code>+</code>  一次以上 <code>{1,}</code></p><p><code>*</code> 任意次   <code>{0,}</code></p><p><code>?</code>  0 个 或 1个 <code>{0,1}</code></p><p>默认贪婪匹配 量词后边 用 <code>?</code>修饰表示非贪婪</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><blockquote><p><code>reg.exec();</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/ab/g</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 不加 g lastIndex不会变 , 每次匹配的都是第一个ab</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"abababab"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[ab] //第一个ab  reg.lastIndex 变为2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[ab] //从游标为2的地方匹配第二个ab   reg.lastIndex 变为4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><blockquote><p><code>str.split(reg)</code>    – 按正则表达式拆分字符串</p><p><code>str.replace</code></p><pre class="line-numbers language-js"><code class="language-js">str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span>  <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//把字符串中找到的第一个 a 替换成 b</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/a/g</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg <span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这样可以实现把所有的 a 替换成 b 如果把 g 去掉 也只能替换第一个 a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>str.toUpperCase()</code>  //把字符串 str中的字母全变成大写</p><p><code>str.toLowerCase()</code> //字符串字母变小写</p></blockquote><h2 id="正向预查-或者-正向断言"><a href="#正向预查-或者-正向断言" class="headerlink" title="正向预查  或者  正向断言"></a>正向预查  或者  正向断言</h2><blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"abaaaa"</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/a(?=b)/g</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// (?=b)不参与选择 , 只参与限定 限定 a 的后边要跟着b </span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/a(?!b)/g</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// (?=b)不参与选择 , 只参与限定 限定 a 的后边不是 b </span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ["a"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><blockquote><p>检验字符串首尾是否含有数字</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/^\d | \d$/</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>匹配四个重复值</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/(\w)\1\1\1/g</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// \1 引用第一个表达式中匹配的值  \2 就是第二个 依次类推</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把 <code>aabb</code> 这种形式的字符串反过来变成 <code>bbaa</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"aabb"</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg  <span class="token operator">=</span> <span class="token regex">/(\w)\1(\w)\2/g</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg <span class="token punctuation">,</span> <span class="token string">"$2$2$1$1"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这里如果就是要替换成 $ 的话 要写 $$ ,类似于转义</span><span class="token comment" spellcheck="true">//另外的方法</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/(\w)\1(\w)\2/g</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>$ <span class="token punctuation">,</span> $<span class="token number">1</span> <span class="token punctuation">,</span> $<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//三个参数一次接收 整个表达式返回结果 , 第一个子表达式结果 , 第二个子表达式结果</span>    <span class="token keyword">return</span> $<span class="token number">2</span> <span class="token operator">+</span> $<span class="token number">2</span> <span class="token operator">+</span> $<span class="token number">1</span> <span class="token operator">+</span> $<span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把 // the-first-name 变成小驼峰命名式 // theFirstName</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"the-first-name"</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/-(\w)/g</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>$ <span class="token punctuation">,</span> $<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> $<span class="token number">1</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串去重</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"aaaabbbccc"</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/(\w)\1*/g</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token string">"$1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把 1000000 变成 1.000.000</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"1000000"</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">=</span><span class="token punctuation">(</span>\B<span class="token punctuation">)</span><span class="token punctuation">(</span>\d<span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">+</span>$<span class="token punctuation">)</span><span class="token operator">/</span>g  <span class="token comment" spellcheck="true">//匹配后边跟的是一个非单词边界和3的倍数个数字的空白字符</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS定时器</title>
      <link href="/2020/02/13/javascript-ding-shi-qi/"/>
      <url>/2020/02/13/javascript-ding-shi-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><blockquote><p>都是全局对象window上的方法 , 内部函数this指向window</p><p>注意:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token string">"console.log('a');"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//每隔1000毫秒会打印一次字符串a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><blockquote><p>设置循环定时器</p><p><code>setInterval</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定时器时间不准</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>清除循环定时器</p><p><code>clearInterval</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>设置单次执行定时器</p><p><code>setTimeout</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//延时1000毫秒执行,只执行一次</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>清除单次执行定时器</p><p><code>clearTimeout</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScripe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript模式</title>
      <link href="/2020/02/05/javascript-mo-shi/"/>
      <url>/2020/02/05/javascript-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript模式"><a href="#JavaScript模式" class="headerlink" title="JavaScript模式"></a>JavaScript模式</h1><h2 id="for循环优化"><a href="#for循环优化" class="headerlink" title="for循环优化"></a>for循环优化</h2><blockquote><p>每次访问数组的长度是非常耗时的 , 所以我们将已经遍历过的数组或容器的长度缓存起来,如以下代码//</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>max <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i <span class="token operator">&lt;</span> max <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//对arr进行处理    </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>第二种 : 使用最少的变量 , 逐步减至0</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> i <span class="token punctuation">,</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//省略第三个参数,通过用 i-- 至 0 来终止循环</span>    <span class="token comment" spellcheck="true">//处理arr</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//while循环实现</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//梳理arr[i]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>我们提倡用正常的for循环来处理数组 , 用for - in 循环来处理对象</p></blockquote><h2 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h2><blockquote><p>Object的<code>hasOwnProperty()</code>方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。 </p></blockquote><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//查看person对象是否包含自身(非继承)属性 : name;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="圣杯模式"><a href="#圣杯模式" class="headerlink" title="圣杯模式"></a>圣杯模式</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">inherit</span><span class="token punctuation">(</span>Target<span class="token punctuation">,</span>Origin<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//定义一个空方法</span>    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Origin<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//让空方法的原型等于父亲的原型</span>    Target<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//需要实现继承的方法的原型指向 new F();  -- 这样就实现了对象值传递</span>    Target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constuctor <span class="token operator">=</span> Target<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果不更改构造器的话,Target的构造器会指向Origin , 所以手动更改指向为自身</span>    Target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>uber <span class="token operator">=</span> Origin<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//添加 uber 属性指明真实继承自哪里</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>利用闭包实现变量私有化</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> inherit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> F <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//利用闭包特性隐藏此方法</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>Target <span class="token punctuation">,</span> Origin<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//在立即执行函数中 return 此方法形成闭包</span>        F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Origin<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>        Target<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constuctor <span class="token operator">=</span> Target<span class="token punctuation">;</span>        Target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>uber <span class="token operator">=</span> Origin<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><blockquote><p><code>instanceof</code> A 对象 是不是 B 构造函数构造出来的</p></blockquote><pre class="line-numbers language-js"><code class="language-js">A <span class="token keyword">instanceof</span> <span class="token class-name">B</span><span class="token comment" spellcheck="true">// 看A对象的原型链上 有没有 B 的原型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="区分数组还是对象"><a href="#区分数组还是对象" class="headerlink" title="区分数组还是对象"></a>区分数组还是对象</h2><blockquote><p>通过<code>constructor</code> 构造器来区分</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// function Array(){};</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// function Object(){};</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>instanceof</code></p></blockquote><pre class="line-numbers language-js"><code class="language-js">arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><code>toString</code></p></blockquote><pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "[object Array]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "[object Object]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>ES 5 新增 <code>Array.isArray([]); //true</code>  参数为数组时返回 <code>true</code></p></blockquote><h2 id="命名模式"><a href="#命名模式" class="headerlink" title="命名模式"></a>命名模式</h2><blockquote><p>构造函数首字母大写</p><p>函数名是多个单词的时候 , 构造函数使用大驼峰命名法 , 普通函数使用小驼峰命名法</p><p>变量是多个单词 , 使用小写用<code>_</code>隔开 ,  或者也使用小驼峰命名法</p><p>使用全部大写的方式表示一个常量 , 来表示不要进行修改 , 或者通过全部大写来表示全局变量</p><p>使用下划线前缀声明私有函数[方法] 和 属性.</p></blockquote><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><blockquote><p>当以<code>new</code>操作符调用构造函数时 , 函数内部将会发生以下情况 : </p><ol><li>创建一个空对象并且<code>this</code>变量引用了该对象 , 同时还继承了该函数的原型.</li><li>属性和方法被加入到<code>this</code>引用的对象中.</li><li>新创建的对象由<code>this</code>所引用 , 并且最后隐式地返回<code>this</code> (如果没有显式的返回其他对象).</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//以上情况看起来就像是在后台发生了如下事情: </span><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> <span class="token keyword">this</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用对象字面量模式创建一个新对象</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 向this添加属性和方法</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h2><blockquote><p>指向函数自身的引用</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> test <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>argument<span class="token punctuation">.</span>callee<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//test 这个函数本身</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h2><blockquote><p>被调用环境的引用</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> test <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> demo <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>demo<span class="token punctuation">.</span>caller<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// test这个函数自身</span><span class="token punctuation">}</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="clone-复制-浅拷贝-深拷贝"><a href="#clone-复制-浅拷贝-深拷贝" class="headerlink" title="clone - 复制-浅拷贝-深拷贝"></a>clone - 复制-浅拷贝-深拷贝</h2><blockquote><p>clone - 浅拷贝</p></blockquote><pre class="line-numbers language-js"><code class="language-js">   <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>       name <span class="token punctuation">:</span> <span class="token string">"zhanglei"</span><span class="token punctuation">,</span>       age <span class="token punctuation">:</span> <span class="token number">18</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">function</span> <span class="token function">clone</span><span class="token punctuation">(</span>origin <span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">var</span> target <span class="token operator">=</span> target <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果传入了target则使用target,否则使用{}</span>       <span class="token keyword">for</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> origin<span class="token punctuation">)</span> <span class="token punctuation">{</span>            target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> origin<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> target<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token function">clone</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>clone - 深拷贝</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">"zhanglei"</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">,</span>    hobby<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//空对象</span><span class="token comment" spellcheck="true">// 通过函数实现 , 把对象 a 中的所有的数据深拷贝到 b 中</span><span class="token keyword">function</span> extend <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//先获取 a 对象中每个属性的值</span>        <span class="token keyword">var</span> item <span class="token operator">=</span> a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//判断这个属性的值是不是数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>item instenceof Array<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果是数组 , 那么在 b 对象中添加一个新的属性,并且这个属性值也是数组</span>            b<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//调用这个方法, 把 a 对象中这个数组的属性一个一个的复制到 b 对象的这个数组属性中</span>            <span class="token function">extend</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>b<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>item instenceof Object<span class="token punctuation">)</span><span class="token punctuation">{</span>            b<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token function">extend</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> b<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果是普通的数据 , 直接复制到 b 对象的这个属性中</span>            b<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">extend</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组中的常用方法"><a href="#数组中的常用方法" class="headerlink" title="数组中的常用方法"></a>数组中的常用方法</h2><h3 id="改变原数组"><a href="#改变原数组" class="headerlink" title="改变原数组"></a>改变原数组</h3><blockquote><p><code>push</code> 从后边添加,并返回添加后的数组长度,可以添加多个,用<code>,</code>隔开</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,2,3]</span><span class="token comment" spellcheck="true">//手写push方法</span>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>push <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>pop</code>把数组的最后一位剪切出来.返回剪切的值,和<code>push</code>相对应</p><p><code>shift</code>从前边减</p><p><code>unshift</code> 从前边加</p><p><code>sort</code>排序 , 默认按照 ASCII码排序  视频第27个 ,时间50分钟</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//1. 必须写俩形参</span><span class="token comment" spellcheck="true">//2. 看返回值</span>    <span class="token comment" spellcheck="true">//1.当返回值为负数时,那么前面的数放在前面</span>    <span class="token comment" spellcheck="true">//2.为正数 , 那么后面的数在前</span>    <span class="token comment" spellcheck="true">//3.为0 . 不动</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//return a - b; 升序</span>    <span class="token comment" spellcheck="true">//return b - a; 降序</span>    <span class="token comment" spellcheck="true">//return Math.random() - 0.5; 打乱顺序</span>    <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,3,4,5,10];</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>reverse</code> 翻转顺序</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [3,2,1]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>splice</code> 切片</p><blockquote><p>参数: 从第几位开始 , 截取多少长度 , 在切口处添加数据</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,2,3,4,5]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="不改变原数组"><a href="#不改变原数组" class="headerlink" title="不改变原数组"></a>不改变原数组</h3><blockquote><p><code>concat</code> 连接两个数组</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,2,3,4]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>join</code>数组转换成字符串</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">var</span> str <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>str<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//"1-2-3";</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>split</code>字符串的方法,把字符串按照参数拆分成数组,与<code>join</code>互逆</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"1-2-3"</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//["1","2","3"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>toString</code></p><p><code>slice</code></p><blockquote><p>参数1  从该位开始截取</p><p>参数2  截取到该位</p><blockquote><p>不写第二个参数 , 则截取到最后</p><p>不写参数,则整个截取</p></blockquote></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newArr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[2,3]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt"></a>charCodeAt</h2><blockquote><p>作用：返回指定位置的字符的Unicode编码。这个返回值在0~65535之间的整数。</p><p>可以判断返回值是否大于255,来判断时候是中文 </p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"zl张磊"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">retBytes</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> mun <span class="token operator">=</span> str<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">chatCodeAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           num<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">reBytes</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><blockquote><p>看起来像数组 , 但是不具有数组操作的一些方法  视频第28个 </p><p>DOM元素全是类数组</p></blockquote><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><blockquote><p>利用对象 , 让数组的值为对象的属性名循环添加属性,最后取出对象名就可以</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span>max <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>max<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    obj<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>    arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 添加到数组的原型方法中</span>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>unique <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> obj <span class="token operator">=</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//声明一个空对象用来存放</span>        arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//声明一个空数组</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           obj<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><blockquote><p>把原始值包装成对象</p><p>原始值本身没有属性 , 但是原始值调用属性时会 根据原始值类型 </p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 实际执行是: `new String('abc').length` 执行完之后就会进行删除</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Object-create-创建对象"><a href="#Object-create-创建对象" class="headerlink" title="Object.create() - 创建对象"></a>Object.create() - 创建对象</h2><blockquote><p>Object.create(prototype, definedProperty);</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> demo <span class="token operator">=</span> <span class="token punctuation">{</span>    name <span class="token operator">=</span> <span class="token string">"张磊"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> Objgect<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 创建一个空对象 , 对象的原型就是`demo` , 并返回</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>一旦经历了<code>var</code>的操作 , 所得出的属性 , window ,这种属性叫做不可配置的属性(不能delete)</p><p>形参也相当于是<code>var</code>声明的变量</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> mun <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">delete</span> mun<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span>window<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">delete</span> num<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>视频第30个 , 15分</p><blockquote><ol><li>预编译 <code>this</code>指向<code>window</code></li><li>谁调用的 <code>this</code>就指向谁</li><li><code>call</code> <code>apply</code> 改变<code>this</code>指向</li><li>全局 中  <code>this</code> 指向 <code>window</code></li></ol></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> Person <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> Student <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> sex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//隐式把函数的原型赋值给this</span>    <span class="token comment" spellcheck="true">//var this = Object.create(Student.prototype);</span>    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span>   <span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 改变Person的this指向调用Person</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>a 函数中包含 b 函数 , 只要 b 函数被返回到 a 函数的外边 , 就会形成闭包 , b 就会拿到 a 的执行上下文</p></blockquote><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><blockquote><ol><li>变量和形参声明提升</li><li>形参和实参相统一</li><li>函数声明提升 - 函数名作为属性名,函数体作为属性值</li><li>函数执行 - 预编译过得语句将会跳过执行 </li></ol></blockquote><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try {} catch {} finally {}"></a>try {} catch {} finally {}</h2><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><blockquote><ol><li>EvalError : eval() 的使用与定义不一致</li><li>RangeError :数值越界</li><li>ReferenceError :非法或不能识别的引用数值</li><li>SyntaxError : 发生语法解析错误</li><li>TypeError : 操作数类型错误</li><li>URLError : URL 处理函数使用不当</li></ol></blockquote><h2 id="es-5-严格模式"><a href="#es-5-严格模式" class="headerlink" title="es 5 严格模式"></a>es 5 严格模式</h2><blockquote><p>如果使用<code>es5</code>严格模式, name<code>es3</code> 和     <code>es5</code> 产生的冲突部分就用<code>es5</code> , 否则会用<code>es3</code></p></blockquote><blockquote><p>启用方式 : </p><p><code>&quot;use strict&quot;</code></p><blockquote><p>变量必须声明</p><p>局部方法预编译的时候里面的<code>this</code>不再指向<code>window</code> , 必须被赋值<code>new</code> 或者<code>.call</code></p><p>拒绝重复的属性和参数</p></blockquote><blockquote><p>为什么使用字符串, 而不是用方法调用呢?</p><blockquote><p>为了兼容老版本浏览器, 因为直接写<code>es5</code> 的方法会报错 , 而字符串老版本不能识别的情况下也不会报错</p></blockquote></blockquote></blockquote><h3 id="with"><a href="#with" class="headerlink" title="with(){}"></a>with(){}</h3><blockquote><p>改变作用域链最顶端 , 找变量最先往这里找, 简化代码</p></blockquote><pre class="line-numbers language-ja"><code class="language-ja">document.write("a");with(document){    write("a"); // 在with里边就可以直接写write了.}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>修改原型链如果原型链很长会整个修改, 影响效率 <code>es5</code>不能使用 ,</p><p><code>arguments</code> 的一些属性和方法 :  <code>caller</code> <code>callee</code> 也不可以在<code>es 5</code> 严格模式下使用</p></blockquote><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><blockquote><p>能把字符串当成代码执行</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token function">eval</span><span class="token punctuation">(</span>'console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器音乐插件 - Listen 1</title>
      <link href="/2020/01/31/yin-le-cha-jian/"/>
      <url>/2020/01/31/yin-le-cha-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Listen-1-Chrome-Extension-V2-5-1"><a href="#Listen-1-Chrome-Extension-V2-5-1" class="headerlink" title="Listen 1 (Chrome Extension) V2.5.1"></a>Listen 1 (Chrome Extension) V2.5.1</h1><p>（最后更新于2019年09月07日）</p><p><a href="LICENSE"><img src="https://img.shields.io/badge/license-MIT-brightgreen.svg" alt="Software License"></a></p><p><a href="https://github.com/listen1/listen1_chrome_extension/blob/master/README_EN.md" target="_blank" rel="noopener">English Version</a></p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>当我发现找个想听的歌因为版权听不了，需要打开好几个网站开始搜索，来回切换让我抓狂的时候，我知道是时候该做点什么了。</p><p>妈妈再也不用担心我找不到我想听的歌了。这里包含了网易云音乐，虾米，QQ音乐, 酷狗音乐，酷我音乐的曲库，够全够大了吧。</p><p>搜歌，听歌，就用 <code>Listen1</code>。</p><p>还有精选歌单哦。</p><h2 id="Chrome安装"><a href="#Chrome安装" class="headerlink" title="Chrome安装"></a>Chrome安装</h2><ol><li>下载项目的zip文件，<a href="https://pan.baidu.com/s/1UAbIrSmP5cOX4SX85pq0kQ" target="_blank" rel="noopener">点击下载</a> , 提取码 : <code>jj9q</code>解压到本地</li><li>chrome右上角的设置按钮下找到更多工具，打开<code>扩展程序</code></li><li>选择 <code>加载已解压的扩展程序</code>(如果没有显示先选中<code>开发者模式</code>)，选中解压后的文件夹，完成！</li></ol><h2 id="Firefox打包安装"><a href="#Firefox打包安装" class="headerlink" title="Firefox打包安装"></a>Firefox打包安装</h2><h3 id="打包xpi文件（或在release页面下载已经打包好的xpi文件）"><a href="#打包xpi文件（或在release页面下载已经打包好的xpi文件）" class="headerlink" title="打包xpi文件（或在release页面下载已经打包好的xpi文件）"></a>打包xpi文件（或在release页面下载已经打包好的xpi文件）</h3><ol><li>将根目录下manifest_firefox.json替换manifest.json</li><li><code>cd listen1_chrome_extension</code></li><li><code>zip -r ../listen1.xpi *</code></li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>打开Firefox，加载xpi文件，完成安装</li></ol><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p><code>2019-09-07</code></p><ul><li>修复migu无法播放的bug</li></ul><p><code>2019-08-09</code></p><ul><li>增加深色主题</li></ul><p><code>2019-07-03</code></p><ul><li>修复咪咕音乐无法播放的bug</li></ul><p><code>2019-06-24</code></p><ul><li>增加咪咕音乐</li><li>修复网易音乐无法播放的bug</li><li>修复酷狗音乐无法播放的bug</li></ul><p><code>2019-06-23</code></p><ul><li>修复无法连接到github的bug</li></ul><p><code>2019-05-26</code></p><ul><li>修复酷狗音乐无法播放的bug</li></ul><p><code>2019-04-26</code></p><ul><li>修复虾米音乐无法播放的bug</li><li>修复播放器未在页面底端显示的bug</li></ul><p><code>2019-03-03</code></p><ul><li>修复删除单个歌曲导致歌单所有歌曲消失的bug</li><li>修复删除单个歌单导致所有歌单消失的bug</li></ul><p><code>2019-02-26</code></p><ul><li>修复qq音乐歌单无法显示的bug</li></ul>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript同步和异步</title>
      <link href="/2020/01/23/javascript-tong-bu-he-yi-bu/"/>
      <url>/2020/01/23/javascript-tong-bu-he-yi-bu/</url>
      
        <content type="html"><![CDATA[<h1 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h1><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><blockquote><p>所谓同步编程,就是计算机一行一行按顺序依次执行代码,是一种典型的请求-响应模型.</p><p>当前代码比较耗时会阻塞后续代码的执行,当请求调用一个函数或者方法后,需等待其响应返回,然后执行后续代码.</p></blockquote><p><strong>类似于生活中规范的排队,即使前面的人动作很慢,后面的人也要等着.</strong></p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><blockquote><p>一般情况下,同步编程,代码依次执行能很好的保证程序的执行,</p><p>但是在某些场景中,比如读取文件内容,或者请求服务器接口数据,这些请求需要根据返回的数据内容,来执行后续操作,</p><p>等待数据返回的时间中,JavaScript是不能处理页面交互,滚动等操作的,</p><p>所以需要异步编程来解决这个问题,JavaScript执行异步任务时,不需要等待响应返回,可以继续执行其他任务,</p><p>而在响应返回时,会得到通知,并执行回调或者事件处理程序.</p><p>CPU不用等待而继续执行,  其实是交给,硬盘,光驱,声卡,网卡,显卡这些硬件, 他们是可以不消耗CPU资源而自动与内存交换数据的，这也是实现异步的基本条件，当数据交互完成，会告诉CPU执行完了,再触发指定的回调函数</p><p>就像打游戏要买一块好的显卡,因为涉及到大量的I/O操作应该就是为了对CPU能力的补充</p><p>当处理CPU走不开的异步操作就要通过线程池开启一个新的线程去完成,就变成了多线程</p></blockquote><p><strong>类似于排队的人有的人没带钱,需要找朋友来帮他付钱,需要时间比较长,就让后面的人先买,等他朋友来了再付钱,朋友就类似于硬盘和显卡.</strong></p><blockquote><p>简单描述下线程池:</p><p>线程池：基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</p></blockquote><h1 id="单线程和多线程"><a href="#单线程和多线程" class="headerlink" title="单线程和多线程"></a>单线程和多线程</h1><blockquote><p>说道这里稍微提一下单线程和多线程,</p><p>单线程就可以理解为你自己排队买吃的.</p><p>多线程就是你这边在排队买东西,你想买很多东西,但是排一次队只能买一个,</p><p>但是买东西的窗口有很多个,你就让你朋友去帮你排队买另一个这就形成了多线程</p><p>线程就可以理解为买东西排的队伍.</p><p>把你比作一个程序的话,通过朋友你就实现了同时占用两个线程</p><p>如果地方足够大的话,你还可以让你的家人帮你排别的队伍.</p><p>买东西的地方就可以理解为CPU.</p><p>线程补充介绍 : <a href="https://blog.csdn.net/hr10230322/article/details/78642898" target="_blank" rel="noopener">点击链接</a></p></blockquote><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>多线程<ul><li>最大的问题在于线程本身的调度和运行需要很多的时间,因此不建议创建太大量的线程;</li><li>共享资源的调度比较难,涉及到<a href="https://blog.csdn.net/hd12370/article/details/82814348" target="_blank" rel="noopener">死锁</a>,上锁等相关的概念</li></ul></li><li>异步<ul><li>最大的问题在于回调,这增加了软件设计上的难度</li></ul></li></ul><blockquote><p>在实际设计时,我们可以将两者结合起来:</p><blockquote><p>当需要执行I/O操作时,使用异步操作比使用线程 + 同步I/O操作更合适</p><p>I/O操作不仅包括了直接的文件,网络的读写,还包括数据库操作,WebServer,HttpRequest以及.netRemoting等跨进程的调用</p><p>异步特别适用于大多数I/O密集型的应用程序</p></blockquote><blockquote><p>而线程的适用范围则是那种需要长时间CPU运算的场合,例如耗时较长的图形处理和算法执行</p><p>但是往往由于适用线程编程的简单和符合习惯,所以很多朋友往往会使用线程来执行耗时较长的I/O操作</p><p>这样在只有少数几个并发操作的时候还无伤大雅,如果需要处理大量的并发操作时就不合适了</p></blockquote></blockquote><h1 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h1><p><strong>而JavaScript其实是单线程的<code>(只有一个队伍)</code>,但是又想实现多线程的效果,所以有了异步</strong></p><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p><strong>多线程可以实现边走路边打电话, 也就是同一时刻多任务同时进行 ,也就是并行</strong></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><em><em>而异步则是跑步跑不动了,但是我还没跑完,在我恢复体力之前去吃点东西,等恢复体力了再回来跑 , 虽然我不能同时吃饭和跑步,但是吃饭和跑步事件都发生了,也就是并发 </em></em></p><h1 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>异步编程实现并发执行的的基础是基于事件循环的并发模型</p><p>再讲并发模型之前先简单介绍下堆栈与队列</p><p><img src="1579733173618.png" alt="堆栈与队列"></p><h3 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h3><p>随便堆砌数据,没有顺序,通常存储对象(引用类型)</p><h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h3><p>类似于口袋,先放进去的在最底下,想拿出来就要把后放进去的一个一个拿出来<code>(先进后出)</code>,</p><p>通常存储函数参数和基本类型值变量<code>(按值访问)</code></p><h3 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h3><p><code>先进先出</code>的顺序存储数据结构</p><p><strong>待处理消息的列表，每条消息都关联一个回调函数。</strong></p><p>　　<strong>JavaScript是单线程的（多进程/多线程往往有更大的内存开销、上下文切换开销和数据竞争问题等），这意味着需要有一个队列保存异步执行的代码。</strong></p><p>　　I、入队操作。例如，某个按钮被按下时，它的事件处理器代码被添加到队列；接收到某个Ajax响应时，回调函数的代码被添加到队列；<strong>对于定时器，当指定时间过去后将其回调函数的代码添加到队列。</strong></p><p>　　II、出队操作。<strong>队列中没有任何代码是立刻执行的，但一旦进程空闲（此时栈为空）则尽快执行</strong>。进程每次从队列中取出一条消息并调用其回调函数（<strong>异步操作的结果通过回调函数获得</strong>）。这使得栈变为非空。当栈再次变为空时，表示该消息处理完毕。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>得名于它通常的实现方式：</p><pre><code>// 所谓事件循环，就像代码从一个循环中不断取出而运行一样while (queue.waitForMessage()) { queue.processNextMessage(); }  // waitForMessage()：当前没有消息时执行同步等待</code></pre><h2 id="模型特点："><a href="#模型特点：" class="headerlink" title="模型特点："></a>模型特点：</h2><h3 id="完整运行（Run-to-completion）："><a href="#完整运行（Run-to-completion）：" class="headerlink" title="完整运行（Run-to-completion）："></a><strong>完整运行</strong>（Run-to-completion）：</h3><p>每条消息处理完成后，再处理其他消息。</p><p>　　进入一个函数后，只有在它完整运行后才会“切换”到其他代码，从而无需担心函数操作的数据被意外修改。</p><p>　　不足之处在于，如果一条消息处理时间过长，则Web应用程序无法响应用户的交互操作，浏览器将提示”a script is taking too long to run”。一个好的做法是缩短消息处理过程，并尽可能把一条消息“切分”为多条。</p><p>　　例子：</p><pre><code>setTimeout(function cb() { console.log(&#39;5 seconds timeout&#39;); }, 5000);setTimeout(function cb() { console.log(&#39;9 seconds timeout&#39;); }, 9000);setTimeout(function cb() { console.log(&#39;7 seconds timeout&#39;); }, 7000);setTimeout(function cb() { console.log(&#39;3 seconds timeout&#39;); }, 3000);for(var start = +new Date; +new Date - start &lt;= 10000; ) {}  // “模拟”睡眠</code></pre><p>　　运行大约10s后，输出：</p><pre><code>3 seconds timeout5 seconds timeout7 seconds timeout9 seconds timeout</code></pre><h3 id="从不阻塞"><a href="#从不阻塞" class="headerlink" title="从不阻塞"></a>从不阻塞</h3><p>（也有例外，如alert或同步XHR，但最好避免使用它们）：I/O的处理一般借助于事件和回调函数，因此当应用程序在等待一个IndexedDB查询或一个XHR请求返回时，它仍可以处理其他事情。</p><h1 id="JS执行环境中的两个结构"><a href="#JS执行环境中的两个结构" class="headerlink" title="JS执行环境中的两个结构"></a>JS执行环境中的两个结构</h1><p><a href="https://www.jianshu.com/p/36a7775b04ec" target="_blank" rel="noopener">消息队列(messagequeue)</a></p><p>消息队列也叫任务队列(taskqueue) : 存储待处理消息及对应的回调函数或事件处理程序.</p><p><a href="https://blog.csdn.net/qq_41973396/article/details/88696343" target="_blank" rel="noopener">执行栈(executioncontextstack)</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git快速上手</title>
      <link href="/2020/01/21/git-kuai-su-shang-shou/"/>
      <url>/2020/01/21/git-kuai-su-shang-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="Git教程"><a href="#Git教程" class="headerlink" title="Git教程"></a>Git教程</h1><blockquote><p>如果之前了解过想复习一下,直接看总结就可以了</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="设置Name和Email地址"><a href="#设置Name和Email地址" class="headerlink" title="设置Name和Email地址"></a>设置Name和Email地址</h2><p>安装完成后，还需要最后一步设置，在命令行输入：</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"Your Name"</span>$ git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"email@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p></blockquote><h1 id="本地版本库"><a href="#本地版本库" class="headerlink" title="本地版本库"></a>本地版本库</h1><p>选择一个合适的地方，创建一个空目录：</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ mkdir learngit$ cd learngit$ <span class="token function">pwd</span><span class="token operator">/</span>Users<span class="token operator">/</span>michael<span class="token operator">/</span>learngit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>pwd</code>命令用于显示当前目录。在我的Mac上，这个仓库位于<code>/Users/michael/learngit</code>。</p><p> <strong>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</strong> </p></blockquote><p>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ git initInitialized empty Git repository in <span class="token operator">/</span>Users<span class="token operator">/</span>michael<span class="token operator">/</span>learngit<span class="token operator">/</span><span class="token punctuation">.</span>git<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><p><strong>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</strong> </p></blockquote><h2 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h2><blockquote><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><p>使用Windows的童鞋要特别注意：</p><p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="http://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a>代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：</p></blockquote><p>先添加:</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># 单个文件</span>$ git add readme<span class="token punctuation">.</span>txt <span class="token comment" spellcheck="true"># 多个文件</span>$ git add readme<span class="token punctuation">.</span>txt readmeCN<span class="token punctuation">.</span>txt<span class="token comment" spellcheck="true"># 全部添加</span>$ git add <span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="把文件提交到本地版本库"><a href="#把文件提交到本地版本库" class="headerlink" title="把文件提交到本地版本库"></a>把文件提交到本地版本库</h2><p>再提交:</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ git commit <span class="token operator">-</span>m <span class="token string">"wrote a readme file"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p></blockquote><blockquote><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ git add file1<span class="token punctuation">.</span>txt$ git add file2<span class="token punctuation">.</span>txt file3<span class="token punctuation">.</span>txt$ git commit <span class="token operator">-</span>m <span class="token string">"add 3 files."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># 查看本地库文件状态</span>$ git status<span class="token comment" spellcheck="true"># 文件当前文件改了什么,查看一下再提交就比较放心</span>$ git <span class="token function">diff</span> readme<span class="token punctuation">.</span>txt <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li></ul></blockquote><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># 回退到上一版</span>$ git reset <span class="token operator">--</span>hard HEAD^<span class="token comment" spellcheck="true"># 回退到上上一版</span>$ git reset <span class="token operator">--</span>hard HEAD^^<span class="token comment" spellcheck="true"># 回退到指定版</span>$ git reset <span class="token operator">--</span>hard commit_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li><li>用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。 </li></ul></blockquote><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><blockquote><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p></blockquote><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><pre class="line-numbers language-powershell"><code class="language-powershell">$ git checkout <span class="token operator">--</span> readme<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell">$ git reset HEAD readme<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">版本回退</a>一节，不过前提是没有推送到远程库。</p></blockquote><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre class="line-numbers language-powershell"><code class="language-powershell">$ <span class="token function">rm</span> file<span class="token comment" spellcheck="true"># 删除工作区 , 可以直接用用git checkout -- &lt;file> 恢复</span>$ git <span class="token function">rm</span> file<span class="token comment" spellcheck="true"># 不仅删除了工作区文件，而且还添加到了暂存区，需要先git reset HEAD &lt;file>，然后再git checkout -- &lt;file></span>&amp; git <span class="token function">rm</span> file&amp; git commit <span class="token operator">-</span>m <span class="token string">"说明注释"</span><span class="token comment" spellcheck="true"># 彻底删除 , 先删除工作区和暂存区,再提交到master分支(仓库)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果你用的rm删除文件，那就相当于只删除了工作区的文件，如果想要恢复，直接用git checkout – <file>就可以 2.如果你用的是git rm删除文件，那就相当于不仅删除了文件，而且还添加到了暂存区，需要先git reset HEAD <file>，然后再git checkout – <file> 3.如果你想彻底把版本库的删除掉，先git rm，再git commit 就ok了 </file></file></file></p></blockquote><h1 id="本地仓库总结"><a href="#本地仓库总结" class="headerlink" title="本地仓库总结"></a>本地仓库总结</h1><blockquote><p>Git管理的文件分为：工作区，版本库，版本库又分为暂存区stage和暂存区分支master(仓库)</p><p>工作区&gt;&gt;&gt;&gt;暂存区&gt;&gt;&gt;&gt;仓库</p><p>git add把文件从工作区&gt;&gt;&gt;&gt;暂存区，git commit把文件从暂存区&gt;&gt;&gt;&gt;仓库，</p><p>git diff查看工作区和暂存区差异，</p><p>git diff –cached查看暂存区和仓库差异，</p><p>git diff HEAD 查看工作区和仓库的差异，</p><p>git add的反向命令git checkout，撤销工作区修改，即把暂存区最新版本转移到工作区，</p><p>git commit的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区。</p></blockquote><blockquote><p><strong>新建git本地仓库：</strong></p><p><code>git init</code> </p><p>新建一个.git文件，有这个文件就是一个git仓库</p><p><strong>git本地仓库分三个区来区别操作（这个思路太重要了）：</strong> </p><p><strong>工作区：</strong> 就是一个多了.git文件的文件夹，不要想太多，就按Linux操作文件夹的方法正常操作 </p><p><strong>暂存区：</strong> 暂时讲了两种操作暂存区的方法：</p><p> 1.存入暂存区:</p><p><code>git add filename</code>  //添加文件</p><p><code>git rm filename</code>   //删除文件</p><p> 这两条都是修改暂存区 </p><p>2.递交暂存区</p><p> <code>git commit -m &quot;log说明一般写改动是什么&quot;</code> </p><p>别忘了正常来说一般对暂存区修改以后一定要commit一下<br><strong>版本库：</strong><code>git commit</code>以后的最终版本存入地方，git最重要的一个地方，因为只有版本库的修改才可以跟踪</p><p>另外有几个命令查看状态也很重要： </p><p><code>git status</code></p><p>查看当前git仓库与上一次commit之后的版本库的一切修改，包括工作区的修改和暂存区的修改（这种信息是不详细的） 很人性化的是，<code>git status</code>会提示你下一步可能会做的事，比如你对工作区做了修改，他可能会提示下一步要git add或者</p><p><code>git checkout  filename</code></p><p>， 你刚执行完git add以后，git status跟踪的暂存区的修改，他又会提示你下一步可能要提交git commit或者</p><p><code>git reset HEAD &lt; filename &gt;</code> </p><p><code>git diff filename</code></p><p>这个命令返回的是你对工作区的修改，别想太多，和什么对比并不重要，你只要知道什么时候他会有信息返回，返回什么信息！什么时候有返回呢！你对工作区已经存在的文件修改<!--（但是没有存入暂存区，也就是说没有git add或者git rm，所以一定要纠结的话，他比较的的确是暂存区和工作区的区别）-->的话有返回<strong>（新建文件git diff看不到）</strong>，返回什么，返回修改的详细信息，+是新添的行-是删去的行</p><p> <code>git diff --cached filename</code></p><p>这个命令是查看你对暂存区的修改，也就是你<code>git add</code>或者<code>git rm</code>以后，<code>git diff</code>的返回信息就用<code>git diff --cached</code>来用了（这也是为什么这两个命令一样，只有参数不一样的原因，因为其实干的都是一件事，只是<code>git diff</code>针对的对象是工作区，<code>git diff --cached</code>针对的对象是暂存区） </p><p><code>git log</code></p><p><strong>当前版本之前</strong>的commit日志记录，也就是说当前版本是回退回来的版本的话，当前版本之后的提交与回退都看不到（有个很重要的commit ID）</p><p><code>git reflog</code></p><p>包括版本回退、版本提交的日志，信息相较于<code>git log</code>会比较简单 </p><p><strong>这样把命令的针对对象分为三个区来理解，现在看撤销操作就很容易了：</strong></p><p> 1.针对工作区的撤销（必须保证没有git add/git rm之前）： </p><p><code>git checkout -- filename</code> </p><p>2.针对暂存区的撤销（必须是git add/git rm以后才行） </p><p><code>git reset HEAD filename</code> </p><p>顺便想起git reset的另一种用法，参数不一样啦，那肯定也是撤销操作，当然就是撤销提交，回退版本啦</p><p><code>git reset --hard （HEAD^^^^）/commit id</code></p></blockquote><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><blockquote><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 </p></blockquote><p><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 提供Git仓库托管服务 , 注册一个GitHub账号，就可以免费获得Git远程仓库 ,自行点击链接注册</p><blockquote><p>本地Git仓库和GitHub仓库之间的传输是通过SSH加密的 ,所以需要设置下SSH Key</p></blockquote><blockquote><p>第1步：<strong>创建SSH Key</strong>。在用户主目录下<code>C:\Users\zl</code><!--用户主目录在windows中就是 C:\Users\Administrator\，或者你新建了一个用户，那就是 C:\Users\用户名\--> ，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell">$ ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa <span class="token operator">-</span>C <span class="token string">"youremail@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“<strong>Add SSH Key”</strong>，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p></blockquote><h2 id="本地文件添加到远程仓库"><a href="#本地文件添加到远程仓库" class="headerlink" title="本地文件添加到远程仓库"></a>本地文件添加到远程仓库</h2><ul><li>找到“Create a new repo”按钮，创建一个新的仓库： </li><li>在Repository name填入名称</li><li>其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库 </li></ul><p>在本地的<code>learngit</code>仓库下运行命令：</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ git remote add origin git@github<span class="token punctuation">.</span>com:michaelliao<span class="token operator">/</span>learngit<span class="token punctuation">.</span>git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>请千万注意，把上面的<code>michaelliao</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell">$ git push <span class="token operator">-</span>u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样 </p></blockquote><blockquote><p>从现在起，只要本地作了提交，就可以通过命令：</p></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell">$ git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="克隆别人的Git远程仓库到自己的仓库"><a href="#克隆别人的Git远程仓库到自己的仓库" class="headerlink" title="克隆别人的Git远程仓库到自己的仓库"></a>克隆别人的Git远程仓库到自己的仓库</h2><ul><li>在本地新建文件夹克隆下来</li><li>删除<code>.git</code>文件</li><li>然后在自己的GitHub上新建一个仓库</li><li>在本地仓库执行</li></ul><pre class="line-numbers language-powershell"><code class="language-powershell">$ git init$ git remote add origin 新建的仓库地址$ git add <span class="token punctuation">.</span>$ git commit <span class="token operator">-</span>m <span class="token string">"提交全部"</span>$ git push <span class="token operator">-</span>u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h2><blockquote><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><pre><code>The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)?</code></pre><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><pre><code>Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts.</code></pre><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/" target="_blank" rel="noopener">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p></blockquote><blockquote><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p></blockquote><h2 id="从远程库克隆到本地"><a href="#从远程库克隆到本地" class="headerlink" title="从远程库克隆到本地"></a>从远程库克隆到本地</h2><ul><li>第一步<ul><li>新建一个仓库,勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件： </li></ul></li><li>第二步<ul><li><code>$ git clone 仓库的URL</code></li></ul></li></ul><blockquote><p>URL我们一般选取SSH 相较于 http 而言 方便不用每次都输入用户名密码,而且传输速度快</p><p>除非公司只支持 http 才会选用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue文档风格的Typora主题</title>
      <link href="/2020/01/21/vue-wen-dang-feng-ge-de-typora-zhu-ti/"/>
      <url>/2020/01/21/vue-wen-dang-feng-ge-de-typora-zhu-ti/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/ThirtyZhang/ypora-vue-theme" target="_blank" rel="noopener">typora-vue-theme</a>是 Typora Markdown 文档编辑器中一款类似<a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>文档风格的主题。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a>是一款支持实时预览的 Markdown 编辑器和阅读器，支持<code>Windows</code>、<code>macOS</code>、<code>Linux</code>三大平台。Typora 作为一款合格的 Markdown 编辑器，支持图片、列表、表格、代码、公式、目录等功能，同时这款软件还支持（一键）动态预览功能，让一切都变得如此干净、纯粹。并且有多种主题模板。<strong>typora-vue-theme就是参考了Vue文档风格而开发的一个 Typora 自定义主题</strong>。</p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><ol><li>下载本主题<strong><a href="https://github.com/ThirtyZhang/ypora-vue-theme" target="_blank" rel="noopener">typora-vue-theme</a></strong>中的<code>vue.css</code>、<code>vue-dark.css</code>文件和包含字体的<code>vue</code>文件夹；</li><li>打开 Typora，点击“<strong>偏好设置</strong>” =&gt; “<strong>打开主题文件夹</strong>”按钮，将弹出 Typora 的主题文件夹；</li><li>将下载好的<code>vue.css</code>和<code>vue-dark.css</code>文件和包含字体的<code>vue</code>文件夹放到 Typora 的主题文件夹中；</li><li>关闭并重新打开 Typora，从菜单栏中选择 “<strong>主题</strong>” =&gt; “<strong>Vue</strong>” 或者 “<strong>Vue Dark</strong>” 即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建个人博客</title>
      <link href="/2020/01/21/hexo-da-jian-ge-ren-bo-ke/"/>
      <url>/2020/01/21/hexo-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<div align="center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=864622002&auto=1&height=66"></iframe></div><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="添加国内镜像源"><a href="#添加国内镜像源" class="headerlink" title="添加国内镜像源"></a>添加国内镜像源</h2><p>如果没有梯子的话，可以使用阿里的国内镜像进行加速,不使用的话可能会有下载过慢或下载失败的问题</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ npm config <span class="token function">set</span> registry https:<span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>npm<span class="token punctuation">.</span>taobao<span class="token punctuation">.</span>org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="认识-Hexo"><a href="#认识-Hexo" class="headerlink" title="认识 Hexo"></a>认识 Hexo</h2><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架，可以让你快速建立一个博客。</p></blockquote><blockquote><p>Hexo 使用 Node.js 编写。得益于 Node.js，使得 Hexo 生成上百个页面游刃有余。</p></blockquote><blockquote><p>Hexo 支持 GFM (GitHub Flavored Markdown) 的大部分功能。如果你不喜欢 Markdown ，你还可以换一个 Hexo 渲染插件。</p></blockquote><blockquote><p>Hexo 有许多插件，可以进行各种操作。</p></blockquote><h2 id="学习-Hexo-之前，你需要有："><a href="#学习-Hexo-之前，你需要有：" class="headerlink" title="学习 Hexo 之前，你需要有："></a>学习 Hexo 之前，你需要有：</h2><ul><li>Node.js 基本知识</li><li>Git 基本知识</li><li>Markdown 基本知识</li><li>Html、css、JavaScript 基本知识</li><li>······</li></ul><p>当然了，你可别被吓跑了。除了 Markdown ，其他都不用熟练掌握（事实上如果你不注意排版连 Markdown 都不用掌握，但最好还是学学吧 : <strong><a href="https://thirtyzhang.github.io/2020/01/21/markdown-yu-fa/">Markdown语法 </a></strong>）。如果你完全不会以上划线部分的知识，也没关系。只是简单地建个可以发文章的博客就好了。如果你要更上一层楼，那么以上被划掉的知识就是必备的啦~</p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>在安装 Hexo 之前，你需要安装以下两个工具：</p><ul><li><strong><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></strong></li><li><strong><a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a></strong></li></ul><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> ：<code>brew install git</code>;或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li><li>Linux (Arch 系列)：<code>sudo pacman -S git</code></li></ul><p>提醒</p><p>由于墙的原因，从上面的链接下载 git for windows 最好挂上一个代理，否则下载速度十分缓慢。也可以参考<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">这个页面</a>，收录了存储于百度云的下载地址。</p><p>提醒</p><p>如果你是 CentOS 服务器上的，可以直接使用 <a href="https://github.com/PasserByJia/HexoOneClickInstallation" target="_blank" rel="noopener">HexoOneClickInstallation</a> 这个脚本快速安装 Hexo。</p><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。</p><p>cURL:</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ curl https:<span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>creationix<span class="token operator">/</span>nvm<span class="token operator">/</span>v0<span class="token punctuation">.</span>33<span class="token punctuation">.</span>11<span class="token operator">/</span>install<span class="token punctuation">.</span>sh <span class="token punctuation">|</span> sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Wget:</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ wget <span class="token operator">-</span>qO<span class="token operator">-</span> https:<span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>creationix<span class="token operator">/</span>nvm<span class="token operator">/</span>v0<span class="token punctuation">.</span>33<span class="token punctuation">.</span>11<span class="token operator">/</span>install<span class="token punctuation">.</span>sh <span class="token punctuation">|</span> sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ nvm install stable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">安装程序</a> 来安装。</p><h2 id="安装-Hexo-1"><a href="#安装-Hexo-1" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>安装好后，即可使用 npm 完成 Hexo 的安装。</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># 下面这两个命令好像是一样的效果,任选一个就可以了</span>$ npm install <span class="token operator">-</span>g hexo<span class="token operator">-</span><span class="token function">cli</span>$ npm install hexo<span class="token operator">-</span><span class="token function">cli</span> <span class="token operator">-</span>g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输入<code>npm install</code>安装必备的组件 </p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="建立网站"><a href="#建立网站" class="headerlink" title="建立网站"></a>建立网站</h2><p>安装好 Hexo 后即可建立你的网站。</p><p>首先建立一个文件夹。</p><pre class="line-numbers language-powershell"><code class="language-powershell">mkdir &lt;your_blog_name>  <span class="token comment" spellcheck="true"># 建立你的网站根目录，名字可以自己修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后往这个文件夹里安装 Hexo。</p><pre class="line-numbers language-powershell"><code class="language-powershell">hexo init &lt;your_blog_name><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再执行</p><pre class="line-numbers language-powershell"><code class="language-powershell">hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>浏览器输入</p><pre class="line-numbers language-powershell"><code class="language-powershell">http:<span class="token operator">/</span><span class="token operator">/</span>localhost:4000<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以本地访问了</p><p>这样就建立好网站了！</p><p><strong>网站建立好后还需要做一些个性化配置,如:修改网站默认内容改为自己的内容</strong></p><p>此部分内容可能过期，请见 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">Hexo 官方文档</a>。</p><p>在 Hexo 根目录 <code>_config.yml</code> 这个文件里配置！</p><p>警告</p><p>在 YAML 语法中，冒号后面必须要有一个空格才能继续写下去。</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><pre><code># Sitetitle:            subtitle: description: keywords:author: language: timezone: </code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>keywords</code></td><td>网站关键词</td></tr><tr><td><code>author</code></td><td>作者名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言</td></tr><tr><td><code>timezone</code></td><td>网站时区：详见<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">时区列表</a></td></tr></tbody></table><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><pre><code># URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: root: permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls:  trailiing_index: true</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>url</code></td><td>网址</td></tr><tr><td><code>root</code></td><td>网站根目录</td></tr><tr><td><code>permalink</code></td><td>文章的永久链接格式</td></tr><tr><td><code>permalink_defaults</code></td><td>永久链接中各部分的默认值</td></tr><tr><td><code>pretty_urls</code></td><td>改写 <code>permalink</code> 的值来美化 URL</td></tr><tr><td><code>pretty_urls.trailing_index</code></td><td>是否在永久链接中保留尾部的 <code>index.html</code>，<code>false</code> 时去除</td></tr></tbody></table><p>提醒</p><p>如果你的网站在子目录中，如：<code>https://yoursite.com/blog</code> ，就把你的 <code>url</code> 设为 <code>http://yoursite.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p><p>例如：</p><pre><code># 比如，一个页面的永久链接是 http://example.com/foo/bar/index.htmlpretty_urls:  trailing_index: false# 此时页面的永久链接会变为 http://example.com/foo/bar/</code></pre><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><pre><code># Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: README.md</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>source_dir</code></td><td>资源文件夹</td></tr><tr><td><code>public_dir</code></td><td>公共文件夹</td></tr><tr><td><code>tag_dir</code></td><td>标签文件夹</td></tr><tr><td><code>archive_dir</code></td><td>归档文件夹</td></tr><tr><td><code>category_dir</code></td><td>分类文件夹</td></tr><tr><td><code>code_dir</code></td><td>Include code 文件夹</td></tr><tr><td><code>i18n_dir</code></td><td>国际化文件夹</td></tr><tr><td><code>skip_render</code></td><td>跳过文件的渲染。匹配到的文件将直接复制到 <code>public</code> 目录中。您可使用 <a href="https://github.com/micromatch/micromatch#extended-globbing" target="_blank" rel="noopener">glob</a> 表达式来匹配路径。</td></tr></tbody></table><p>提醒</p><p>一般情况下，这部分是不需要修改的。</p><p>例如：</p><pre><code>skip_render: &quot;mypage/**/*&quot;# 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 &#39;public&#39; 目录# 你也可以用这种方法来跳过对指定文章文件的渲染skip_render: &quot;_posts/test-post.md&quot;# 这将会忽略对 &#39;test-post.md&#39; 的渲染</code></pre><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><pre><code># Writingnew_post_name: :title.md # File name of new postsdefault_layout: postauto_spacing: falsetitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tab  enable: true  field: site  exclude: []filename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight:  enable: true  line_number: true  auto_detect: false  tab_replace:</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>new_post_name</code></td><td>新文章的文件名称</td></tr><tr><td><code>default_layout</code></td><td>预设布局</td></tr><tr><td><code>auto_spacing</code></td><td>在中文和英文之间加入空格</td></tr><tr><td><code>titlecase</code></td><td>把标题转换为 title case</td></tr><tr><td><code>external_link</code></td><td>在新标签中打开链接</td></tr><tr><td><code>external_link.enable</code></td><td>在新标签中打开链接</td></tr><tr><td><code>external_link.field</code></td><td>适用于整个网站或仅文章</td></tr><tr><td><code>external_link.exclude</code></td><td>排除主机名。在适用时指定子域，包括 <code>www</code></td></tr><tr><td><code>filename_case</code></td><td>把文件名称转换为 (1) 小写或 (2) 大写</td></tr><tr><td><code>render_drafts</code></td><td>显示草稿</td></tr><tr><td><code>post_asset_folder</code></td><td>启动 <a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">Asset 文件夹</a></td></tr><tr><td><code>relative_link</code></td><td>把链接改为与根目录的相对位址</td></tr><tr><td><code>future</code></td><td>显示未来的文章</td></tr><tr><td><code>highlight</code></td><td>代码块的设置</td></tr><tr><td><code>highlight.enable</code></td><td>开启语法高亮</td></tr><tr><td><code>highlight.auto_detect</code></td><td>如果未指定语言，则启用自动检测</td></tr><tr><td><code>highlight.line_number</code></td><td>显示行数</td></tr><tr><td><code>highlight.tab_replace</code></td><td>用 n 个空格替换 tabs；如果值为空，则不会替换 tabs</td></tr></tbody></table><h3 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h3><pre><code># Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>default_category</code></td><td>默认分类</td></tr><tr><td><code>category_map</code></td><td>分类别名</td></tr><tr><td><code>tag_map</code></td><td>标签别名</td></tr></tbody></table><h3 id="日期-时间格式"><a href="#日期-时间格式" class="headerlink" title="日期 / 时间格式"></a>日期 / 时间格式</h3><pre><code># Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ssuse_date_for_updated: true</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>date_format</code></td><td>日期格式</td></tr><tr><td><code>time_format</code></td><td>时间格式</td></tr><tr><td><code>use_date_for_updated</code></td><td>如果前面没有提供更新日期，则使用 <code>post.updated</code> 中的发布日期。通常与 Git 工作流一起使用。</td></tr></tbody></table><p>提醒</p><p>Hexo 使用 <a href="http://momentjs.com/" target="_blank" rel="noopener">Moment.js</a> 来解析和显示时间。</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><pre><code># Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>per_page</code></td><td>每页显示的文章量 (0 = 关闭分页功能)</td></tr><tr><td><code>pagination_dir</code></td><td>分页目录</td></tr></tbody></table><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><pre><code># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: theme_config: deploy:meta_generator:</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>theme</code></td><td>当前主题名称。值为 <code>false</code> 时禁用主题</td></tr><tr><td><code>theme_config</code></td><td>主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置。</td></tr><tr><td><code>deploy</code></td><td>部署的设置</td></tr><tr><td><code>meta_generator</code></td><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签。</td></tr></tbody></table><p>提醒</p><p>下一篇文章将会提到 部署。</p><h1 id="Hexo-命令详解"><a href="#Hexo-命令详解" class="headerlink" title="Hexo 命令详解"></a>Hexo 命令详解</h1><p>下面介绍一些 Hexo 的基本命令。</p><h3 id="hexo-init-folder"><a href="#hexo-init-folder" class="headerlink" title="hexo init [folder]"></a><code>hexo init [folder]</code></h3><p>这个命令是 Hexo 初始化命令。<code>[folder]</code> 表示你要初始化的文件夹。如果你要初始化本地，直接 <code>hexo init .</code> 。</p><h3 id="hexo-new-layout-lt-title-gt"><a href="#hexo-new-layout-lt-title-gt" class="headerlink" title="hexo new [layout] &lt;title&gt;"></a><code>hexo new [layout] &lt;title&gt;</code></h3><p>这个命令是新建文章或页面用的命令。其中 <code>[layout]</code> 表示他的模板（即页面或者文章），<code>&lt;title&gt;</code> 表示标题。</p><p>用法：</p><ol><li><code>hexo new post 001</code> ，表示新建了一个标题为 <code>001</code> 的文章。</li><li><code>hexo new page 001</code> ，表示新建了一个标题为 <code>001</code> 的页面。</li></ol><p>如果你不想在终端中新建文章或页面，可以直接在 <code>博客根目录/source/_post/</code> 目录下创建 Markdown 文件写<strong>文章</strong>。或者在 <code>博客根目录/source/</code> 目录下创建一个文件夹，然后在新文件夹里创建 <code>index.md</code> 写<strong>页面</strong>即可。</p><p>提醒</p><p>当你新建页面后，页面的链接就是你页面所在的文件夹的名字。</p><p>例如：我在 <code>博客根目录/source/</code> 下新建了一个名为 <code>test</code> 的文件夹，然后在 <code>test</code> 文件夹下写 Markdown 文件，那么这个页面的链接就是 <code>网址/test</code>。</p><h3 id="hexo-server"><a href="#hexo-server" class="headerlink" title="hexo server"></a><code>hexo server</code></h3><p>当你要在本地查看网站的时候，就可以用这个命令。</p><p>默认在 <code>http://localhost:8080/</code> 这里，可能会不同，注意提示信息即可。</p><p>提醒</p><p>如果你想要换端口号（上面的 <code>8080</code> 就是端口号），可以在终端里输入 <code>hexo s -p 端口号</code>。</p><h3 id="hexo-generate"><a href="#hexo-generate" class="headerlink" title="hexo generate"></a><code>hexo generate</code></h3><p>这个命令是生成网站静态文件的时候用的，生成后网页将会放在根目录下面的 <code>public</code> 文件夹里。</p><h3 id="hexo-deploy"><a href="#hexo-deploy" class="headerlink" title="hexo deploy"></a><code>hexo deploy</code></h3><p>这个命令用来部署网站，使用此命令将会把生成好的页面（即 <code>public</code> 文件夹里的内容）部署到指定的地方上。</p><h3 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a><code>hexo clean</code></h3><p>这个命令用来清空 <code>public</code> 文件夹。</p><h3 id="hexo-version"><a href="#hexo-version" class="headerlink" title="hexo version"></a><code>hexo version</code></h3><p>这个命令用来输出你所使用的 Hexo 目前的版本号</p><h1 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h1><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>如果没有账号，请点此前往 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 注册一个 GitHub 账号。</li><li>新建一个公开仓库，仓库名格式为 <code>your_username.github.io</code> 例如你的 GitHub 用户名是 <code>easyhexo</code>，那么你的仓库地址名称就应该是 <code>easyhexo.github.io</code></li><li>创建完成后记下该仓库的 HTTPS/SSH 地址 一般格式为 <code>https://github.com/your_username/your_reponame.git</code> 在下一步会用到。</li></ol><h3 id="安装部署插件"><a href="#安装部署插件" class="headerlink" title="安装部署插件"></a>安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">部署插件</a></h3><pre><code>$ npm install hexo-deployer-git --save$ npm install hexo-server --save</code></pre><h3 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h3><p>如果你只是安装好了 Git 但没有配置过你的 Git ，那么现在需要做的第一件事情就是设置你的 Git 用户名和邮箱。 在 Git Bash 中执行以下两条命令配置你的用户名和邮箱，这里建议用户名和邮箱与你的 GitHub 用户名和邮箱保持一致。</p><pre><code>$ git config --global user.name &quot;Your_user_name&quot;$ git config --global user.email &quot;Your_email@example.com&quot;</code></pre><p>提醒</p><p>每次 Git 提交时都会附带这两条信息，用于记录是谁提交的更新，并且会随更新内容一起被记录到历史记录中。简单说，是用来标记的你的身份的~</p><p>用户名和邮箱根据你注册github的信息自行修改。</p><h3 id="然后生成密钥SSH-key："><a href="#然后生成密钥SSH-key：" class="headerlink" title="然后生成密钥SSH key："></a>然后生成密钥SSH key：</h3><pre><code>ssh-keygen -t rsa -C &quot;Your_email@example.com&quot;</code></pre><p>打开<a href="https://github.com/" target="_blank" rel="noopener">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>git bash中输入</p><pre><code>cat ~/.ssh/id_rsa.pub</code></pre><p>将输出的内容复制到框中，点击确定保存。</p><p>输入<code>ssh -T git@github.com</code>，出现你的用户名，那就成功了。</p><h3 id="配置站点-config-yml-文件"><a href="#配置站点-config-yml-文件" class="headerlink" title="配置站点 _config.yml 文件"></a>配置站点 <code>_config.yml</code> 文件</h3><pre><code>deploy:  type: git   # 类型填git  repo: &lt;repository url&gt; # 你的Github仓库地址  branch: master  # 分支名称。默认填写 master 如果您使用的是 GitHub ，程序会尝试自动检测。  message:  # 提交信息可以自定义，不填的则默认为提交时间</code></pre><pre><code>deploy:  type: git  repository: git@github.com:ThirtyZhang/ThirtyZhang.github.io.git  branch: master</code></pre><p>repository修改为你自己的github项目地址。<strong>(最好使用SSH的地址,因为使用Http更换电脑后可能找不到该git地址)</strong></p><h3 id="发布到-GitHub"><a href="#发布到-GitHub" class="headerlink" title="发布到 GitHub"></a>发布到 GitHub</h3><p>在本地的 Hexo 站点根目录下，执行如下命令即可部署到 GitHub Pages 上。</p><pre><code>$ hexo clean &amp;&amp; hexo d -g</code></pre><h1 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h1><p>首先在博客根目录下右键打开git bash</p><p>输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p><p>然后打开<code>博客根目录\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦</p><h2 id="创建文章命令详细介绍"><a href="#创建文章命令详细介绍" class="headerlink" title="创建文章命令详细介绍"></a>创建文章命令详细介绍</h2><blockquote><p><code>hexo new [layout]</code></p><p>这个命令是新建文章或页面用的命令。其中 <code>[layout]</code> 表示他的模板（即页面或者文章），<code>&lt;title&gt;</code> 表示标题。</p><p>用法：</p><ol><li><code>hexo new post 001</code> ，表示新建了一个标题为 <code>001</code> 的文章。</li><li><code>hexo new page 001</code> ，表示新建了一个标题为 <code>001</code> 的页面。</li></ol><p>如果你不想在终端中新建文章或页面，可以直接在 <code>博客根目录/source/_post/</code> 目录下创建 Markdown 文件写<strong>文章</strong>。或者在 <code>博客根目录/source/</code> 目录下创建一个文件夹，然后在新文件夹里创建 <code>index.md</code> 写<strong>页面</strong>即可。</p><p>提醒</p><p>当你新建页面后，页面的链接就是你页面所在的文件夹的名字。</p><p>例如：我在 <code>博客根目录/source/</code> 下新建了一个名为 <code>test</code> 的文件夹，然后在 <code>test</code> 文件夹下写 Markdown 文件，那么这个页面的链接就是 <code>网址/test</code>。</p></blockquote><h1 id="推荐使用的主题链接"><a href="#推荐使用的主题链接" class="headerlink" title="推荐使用的主题链接"></a>推荐使用的主题链接</h1><p>推荐一个好用的主题地址</p><p><a href="https://github.com/ThirtyZhang/hexo-theme-matery" target="_blank" rel="noopener">自己克隆的</a></p><p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">原版的</a></p><p>下载后将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可</p><p>然后参照其中的<code>DEADME-CN.md</code>文件进行配置</p><h1 id="最后我搭建好的成品效果图"><a href="#最后我搭建好的成品效果图" class="headerlink" title="最后我搭建好的成品效果图"></a>最后我搭建好的成品效果图</h1><p>我个人的博客地址 : <a href="https://thirtyzhang.github.io/">点击访问</a></p><p><img src="1579682303863.png" alt="MyBlog"></p><h1 id="收藏博客"><a href="#收藏博客" class="headerlink" title="收藏博客"></a>收藏博客</h1><p><strong><a href="https://milyyy.github.io/" target="_blank" rel="noopener">milyyy</a></strong></p><p><a href="https://blinkfox.github.io/" target="_blank" rel="noopener">闪烁之狐</a></p><p><a href="https://godweiyang.com/" target="_blank" rel="noopener">韦阳的博客</a></p><h1 id="备份博客源文件"><a href="#备份博客源文件" class="headerlink" title="备份博客源文件"></a>备份博客源文件</h1><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p><p>首先在github博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git checkout hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后</p><p>，最后<code>git push origin hexo</code>提交就行了。</p><h1 id="推荐另一个教程作参考"><a href="#推荐另一个教程作参考" class="headerlink" title="推荐另一个教程作参考"></a>推荐另一个教程作参考</h1><h2 id="Hexo-Github博客搭建-完整小白教程"><a href="#Hexo-Github博客搭建-完整小白教程" class="headerlink" title="Hexo+Github博客搭建 完整小白教程"></a>Hexo+Github博客搭建 完整小白教程</h2><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-10" target="_blank" rel="noopener">https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-10</a> </p><p><strong>更多细节可查看官方文档</strong> : <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">hexo</a></p><h1 id="遇到的问题解决办法"><a href="#遇到的问题解决办法" class="headerlink" title="遇到的问题解决办法"></a>遇到的问题解决办法</h1><h2 id="端口占用"><a href="#端口占用" class="headerlink" title="端口占用"></a>端口占用</h2><ul><li>提示“FATAL Port 4000 has been used. Try other port instead.”<br> 在使用了$ hexo s命令预览博客效果后使用Control+C关闭<br> 解决办法：</li></ul><p>还不行就重新手动制定端口号</p><pre><code>$ hexo s -p 5000</code></pre><h2 id="未安装git部署插件"><a href="#未安装git部署插件" class="headerlink" title="未安装git部署插件"></a>未安装git部署插件</h2><ul><li>提示“ERROR Deployer not found: git”<br>解决办法：</li></ul><pre><code>$ npm install hexo-deployer-git --save</code></pre><h2 id="每次hexo-d-提交到GitHub-都会发送警告邮件"><a href="#每次hexo-d-提交到GitHub-都会发送警告邮件" class="headerlink" title="每次hexo d 提交到GitHub 都会发送警告邮件"></a>每次hexo d 提交到GitHub 都会发送警告邮件</h2><p><strong>Page build warning：Cannot use CNAMEs ending with github.io or github.com</strong></p><p>总结写在前面,如果你没有绑定域名,而是克隆的别人的文件,直接删除掉就可以了</p><p>路径 : <code>博客根目录/source</code></p><p><img src="1579706750493.png" alt="CNAME"></p><p>然后重新依次执行:</p><pre class="line-numbers language-powershell"><code class="language-powershell">hexo cleanhexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>就不会受到警告邮件了.</p><p>​       在设计自己blog的时候，大家都会先借鉴一下<a href="http://jekyllthemes.org/" target="_blank" rel="noopener">jkell模板</a>吧。我的这个blog也先clone了别人的架构，接下来慢慢修改填充自己的想法。</p><p>​       在我每次向github的远程仓库提交更新的时候，总会收到一封邮件：</p><blockquote><p> The page build completed successfully, but returned the following warning for the <code>master</code> branch:You cannot use CNAMEs ending with github.io or github.com. Instead, create a repository named ThirtyZhang.github.io. See <a href="https://help.github.com/articles/setting-up-your-pages-site-repository/" target="_blank" rel="noopener">https://help.github.com/articles/setting-up-your-pages-site-repository/</a></p><p> For information on troubleshooting Jekyll see:</p><p> <a href="https://help.github.com/articles/troubleshooting-jekyll-builds" target="_blank" rel="noopener">https://help.github.com/articles/troubleshooting-jekyll-builds</a></p><p> If you have any questions you can contact us by replying to this email.</p></blockquote><p>大概就是表示您不能使用以<code>github.io</code> 或者 <code>github.com</code> 结尾的CNAMEs文件 ,创建一个名为ThirtyZhang.github.io的存储库代替</p><p>刚接触<a href="http://jekyll.bootcss.com/" target="_blank" rel="noopener">jekyll</a>不久，对它的构建结构和语法都不是特别熟悉。访问了邮件中的链接，我发现这并不能解决我的问题。虽然有warning但是无伤大雅，毕竟程序员不怎么care warning。But 每次更新代码，都要收到github的邮件，我是不能忍受的！！！(<em>&gt;﹏&lt;</em>)</p><p>​       于是乎好好研究了下jekyll的目录结构以及CNAME，原来CNAME是用来绑定域名的。</p><p><strong>绑定到一级域名</strong></p><ol><li>首先在项目根目录下创建一个叫CNAME文件，里面写上自己的以及一级域名(<a href="http://www.youdomain.com" target="_blank" rel="noopener">www.youdomain.com</a>)</li><li>在你的域名管理页或者是DNS解析的地方，增加一个记录，记录类别为CNAME(Alias)类型。i.e.在DNS中为自己的域名增加一条A记录，指向207.97.227.245（github服务器）。</li><li>将项目提交到github上, wait a minute</li><li>baseurl应该为”/”</li><li>访问自己的域名,check一下</li></ol><p><strong>绑定到二级域名</strong></p><p>​       需要额外在DNS中增加一条CNAME，指向(github用户名).github.io，然后再CNAME文件中修改为自己的二级域名即可</p><p>​       有关这个问题的<a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/" target="_blank" rel="noopener">github官方帮助文档</a></p><p>​       之前clone jekyll模板的时候在项目中有个CNAME文件，刚开始不知道它的而作用就保留了。我还没有申请域名，现在看来这个文件不仅unnecessary而且是trouble maker。删除这个文件就没有警告了。O(∩_∩)O</p><h2 id="python3安装PIL失败"><a href="#python3安装PIL失败" class="headerlink" title="python3安装PIL失败"></a>python3安装PIL失败</h2><p>PIL其实只是python2的专利，它并没有跟随python的进化而进化。有大师为此，专门写了一个针对python3的pillow模块。</p><p>所以，如果需要安装python3对应的PIL，应该选择安装<code>pillow</code>。</p><hr><p><strong>如果文章对您有帮助,希望可以点击下方的打<code>赏</code>.</strong></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub国内访问加速</title>
      <link href="/2020/01/21/github-guo-nei-fang-wen-jia-su/"/>
      <url>/2020/01/21/github-guo-nei-fang-wen-jia-su/</url>
      
        <content type="html"><![CDATA[<h1 id="Github加速"><a href="#Github加速" class="headerlink" title="Github加速"></a>Github加速</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>修改系统hosts文件的办法，绕过国内dns解析，直接访问GitHub的CDN节点</p><p>访问网址时先搜索hosts文件，如果由网址对应的ip则不需要dns域名解析，因此可以将网址的ip配成静态ip，减少解析过程，提高访问速度。 </p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><strong>修改hosts</strong></p><blockquote><p>hosts文件最下面增加（win10的位置为C:\Windows\System32\drivers\etc，先拷到其他地方修改后再覆盖该文件夹hosts文件）：</p></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># Github加速</span>192<span class="token punctuation">.</span>30<span class="token punctuation">.</span>253<span class="token punctuation">.</span>113     github<span class="token punctuation">.</span>com185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153    github<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io151<span class="token punctuation">.</span>101<span class="token punctuation">.</span>72<span class="token punctuation">.</span>133     assets<span class="token operator">-</span>cdn<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com151<span class="token punctuation">.</span>101<span class="token punctuation">.</span>185<span class="token punctuation">.</span>194    github<span class="token punctuation">.</span>global<span class="token punctuation">.</span>ssl<span class="token punctuation">.</span>fastly<span class="token punctuation">.</span>net203<span class="token punctuation">.</span>98<span class="token punctuation">.</span>7<span class="token punctuation">.</span>65 gist<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 13<span class="token punctuation">.</span>229<span class="token punctuation">.</span>189<span class="token punctuation">.</span>0 codeload<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>109<span class="token punctuation">.</span>153 desktop<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153 guides<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153 blog<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 18<span class="token punctuation">.</span>204<span class="token punctuation">.</span>240<span class="token punctuation">.</span>114 status<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153 developer<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153 services<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 192<span class="token punctuation">.</span>30<span class="token punctuation">.</span>253<span class="token punctuation">.</span>175 enterprise<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 34<span class="token punctuation">.</span>195<span class="token punctuation">.</span>49<span class="token punctuation">.</span>195 education<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153 pages<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 34<span class="token punctuation">.</span>196<span class="token punctuation">.</span>237<span class="token punctuation">.</span>103 classroom<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com<span class="token comment" spellcheck="true"># Github加速结束</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>刷新系统DNS缓存</strong> </p><blockquote><p>打开<code>cmd console:</code></p><blockquote><p><code>Windows+X</code> 打开系统命令行（管理员身份）或 PowerShell </p></blockquote></blockquote><blockquote><p>执行：<code>ipconfig /flushdns</code></p></blockquote><p>到这里就完成了,下面介绍下获取最新地址方法</p><h2 id="获取GitHub官方CDN地址"><a href="#获取GitHub官方CDN地址" class="headerlink" title="获取GitHub官方CDN地址"></a>获取GitHub官方CDN地址</h2><p><strong>打开:</strong><a href="https://www.ipaddress.com/" target="_blank" rel="noopener"><a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a> </a></p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># Github加速</span>192<span class="token punctuation">.</span>30<span class="token punctuation">.</span>253<span class="token punctuation">.</span>113     github<span class="token punctuation">.</span>com185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153    github<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io151<span class="token punctuation">.</span>101<span class="token punctuation">.</span>72<span class="token punctuation">.</span>133     assets<span class="token operator">-</span>cdn<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com151<span class="token punctuation">.</span>101<span class="token punctuation">.</span>185<span class="token punctuation">.</span>194    github<span class="token punctuation">.</span>global<span class="token punctuation">.</span>ssl<span class="token punctuation">.</span>fastly<span class="token punctuation">.</span>net<span class="token comment" spellcheck="true"># Github加速结束</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询上述IP后面的网址,更新前面的IP地址,并重新修改<code>hosts</code>文件</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2020/01/21/markdown-yu-fa/"/>
      <url>/2020/01/21/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<div align="middle"> <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28892385&auto=1&height=66"></iframe></div><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><table><thead><tr><th align="center"><strong>语法</strong></th></tr></thead><tbody><tr><td align="center"><code>#</code>一级标题</td></tr><tr><td align="center"><code>##</code>二级标题</td></tr><tr><td align="center"><code>###</code>三级标题</td></tr><tr><td align="center"><code>####</code>四级标题</td></tr><tr><td align="center"><code>#####</code>五级标题</td></tr><tr><td align="center"><code>######</code>六级标题</td></tr></tbody></table><p><img src="2.png" alt="png"></p><h2 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h2><p><code>*斜体*</code>  <em>斜体</em></p><p><code>_斜体_</code>  _斜体_</p><p><code>**粗体**</code>  <strong>粗体</strong></p><p><code>***加粗斜体***</code><strong><em>加粗斜体</em></strong></p><p><code>~~删除线~~</code>  <del>删除线</del></p><h2 id="插入图片或连接"><a href="#插入图片或连接" class="headerlink" title="插入图片或连接"></a>插入图片或连接</h2><blockquote><p>插入链接与插入图片的语法很像，区别在一个 <code>!</code>号</p><p>图片为：<code>![]()</code></p><p>链接为：<code>[]()</code></p></blockquote><p><code>[描述](图片路径或者URL)</code>  描述可以不写</p><h2 id="分割线三种方式"><a href="#分割线三种方式" class="headerlink" title="分割线三种方式"></a>分割线三种方式</h2><p>你可以在一行中用三个以上的星号<code>*</code>、减号<code>-</code>、底线<code>_</code>来建立一个分隔线，行内不能有其他东西。 </p><p><code>---</code></p><hr><p><code>***</code></p><hr><p><code>___</code></p><hr><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p><strong>行内式</strong>：如果在一个行内需要引用代码，只要用反引号`引起来就好（一般在ESC键下方，和~同一个键） </p><p>`用两个反引号` <code>行内/单行代码块</code></p><p><strong>多行代码块与语法高亮</strong>：在需要高亮的代码块的前一行及后一行使用三个单反引号“`”包裹 </p><p>```js</p><p>三个反引号可以表明代码语言,这里写的js</p><p>````</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我是js代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在被引用的文本前加上<code>&gt;</code>符号，以及一个空格就可以了，如一个<code>&gt;</code>符号会产生一次缩进</p><p><code>&gt;引用</code> </p><blockquote><p>引用</p></blockquote><p><code>&gt;&gt;引用</code></p><blockquote><blockquote><p>引用</p></blockquote></blockquote><p><code>&gt;&gt;&gt;引用</code></p><blockquote><blockquote><blockquote><p>引用</p></blockquote></blockquote></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><strong>无序列表</strong></p><p>使用 *，+，- 都可以表示无序列表。任意选用一个即可, 注意：符号后面一定要有一个空格，起到缩进的作用。 </p><p><code>- 无序列表</code>- </p><p><code>* 无序列表</code></p><p><code>+ 无序列表</code></p><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><p><strong>有序列表</strong></p><p>使用数字和一个英文句点表示有序列表。 注意：英文句点后面一定要有一个空格，起到缩进的作用。 </p><p><code>1.有序列表</code></p><p><code>2.有序列表</code></p><p><code>3.有序列表</code></p><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符\"></a>转义字符<code>\</code></h2><p>如果在使用符号时与Markdown语法冲突,可以在符号前面加上<code>\</code>即可正常显示</p><p>如在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><code>|姓名|性别|分数|</code></p><p><code>|:-:|:-:|:-:|</code></p><p><code>|小明|男|100|</code></p><p><code>|小明|男|100|</code></p><p>表格对齐方式：我们可以指定表格单元格的对齐方式，冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中 </p><table><thead><tr><th align="center">姓名</th><th align="center">性别</th><th align="center">分数</th></tr></thead><tbody><tr><td align="center">小明</td><td align="center">男</td><td align="center">100</td></tr><tr><td align="center">小明</td><td align="center">男</td><td align="center">100</td></tr></tbody></table><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Markdown语法学到这里日常已经够用了,下面介绍一款实时预览的 Markdown 文本编辑器</p><h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p>Typora 是一款<strong>支持实时预览的 Markdown 文本编辑器</strong>。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是<strong>完全免费</strong>的。 </p><p>点击下载:<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a></p><h2 id="GFM-标准"><a href="#GFM-标准" class="headerlink" title="GFM 标准"></a>GFM 标准</h2><p> <a href="https://github.github.com/gfm/" target="_blank" rel="noopener">GFM 标准</a>，它是由著名代码托管网站 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 所制定的。Typora 主要使用的也是 GFM 标准。同时，你还可以在 <code>文件 - 偏好设置 - Markdown 语法偏好 - 严格模式</code> 中将标准设置为「更严格地遵循 GFM 标准」。具体内容你可以在官方的 <a href="http://support.typora.io/Strict-Mode/" target="_blank" rel="noopener">这篇文档</a> 中查看。</p><h2 id="设置图片"><a href="#设置图片" class="headerlink" title="设置图片"></a>设置图片</h2><p>Typora 支持在拖动或 <code>Ctrl + V</code> 网络图片后自动将其保存到本地。你可以在 <code>文件 - 偏好设置 - 编辑器 - 图片插入</code> 中选择复制到哪个路径，什么情况下需要复制。</p><p><img src="3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预习路线</title>
      <link href="/2020/01/20/yu-xi-lu-xian/"/>
      <url>/2020/01/20/yu-xi-lu-xian/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28285910&auto=1&height=66"></iframe></div><h1 id="预习路线"><a href="#预习路线" class="headerlink" title="预习路线"></a>预习路线</h1><ul><li>ajax  —  node  —  vue  — 小程序 — react </li></ul><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p><strong><a href="https://www.bilibili.com/video/av15657082" target="_blank" rel="noopener">Part1</a></strong>不看php可以从第37个视频开始看</p><p><strong><a href="https://www.bilibili.com/video/av15866060/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">Part2</a></strong></p><p><a href="https://pan.baidu.com/s/1w-lcQCMTNLuSEg0e_hpKuQ" target="_blank" rel="noopener">课件网盘链接</a> – 提取码:mc10</p><p>这个ajax的视频比较老了,,,</p><p>又另外找了一个备看</p><p><a href="https://www.bilibili.com/video/av22807707/?spm_id_from=333.788.videocard.4" target="_blank" rel="noopener">李南江亲授-jQuery+Ajax从放弃到知根知底</a></p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p><a href="https://www.bilibili.com/video/av81455397" target="_blank" rel="noopener">NodeJs全套视频教程</a></p><p><a href="https://pan.baidu.com/s/1DuXusxfxaiUscfvDb0a9LA" target="_blank" rel="noopener">课件网盘链接</a> – 提取码: nzys </p><h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><p><strong><a href="https://www.bilibili.com/video/av75420619/?spm_id_from=333.788.videocard.2" target="_blank" rel="noopener">Pink 老师推荐-Vue.js快速入门课程</a></strong> </p><p><strong><a href="https://www.bilibili.com/video/av50680998" target="_blank" rel="noopener">Vue-黑马程序员视频</a></strong> —&gt;p1–p199是2018经典vue基础+项目实战教程—p200至最后是2019年最新的vue全家桶(包含了比较流行的新技术)+项目实战教程</p><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://thirtyzhang.github.io/git">Git</a></p><p><a href="https://naotu.baidu.com/" target="_blank" rel="noopener">百度脑图</a></p><p><a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">BootCDN</a></p><p><a href="https://www.html.cn/doc/underscore/#throttle" target="_blank" rel="noopener">Underscore.js (1.9.1) 中文文档 </a></p><p><a href="https://aui.github.io/art-template/zh-cn/" target="_blank" rel="noopener">模板引擎</a></p><p><a href="https://www.bypass.cn/" target="_blank" rel="noopener">Bypass-分流抢票</a></p><h2 id="学习站点"><a href="#学习站点" class="headerlink" title="学习站点"></a>学习站点</h2><p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰</a></p><p><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰</a></p><p>git - 典型错误</p><p><img src="1.png" alt="png"></p><h2 id="手动封装数组方法"><a href="#手动封装数组方法" class="headerlink" title="手动封装数组方法"></a>手动封装数组方法</h2><pre class="line-numbers language-js"><code class="language-js">        <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function">myForEach</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//循环调用回调函数,遍历数组中的值</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myForEach<span class="token punctuation">)</span><span class="token punctuation">;</span>        Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myForEach <span class="token operator">=</span> myForEach<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把函数添加为Array的原型方法</span>        <span class="token comment" spellcheck="true">//调用</span>        arr<span class="token punctuation">.</span><span class="token function">myForEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="典型错误"><a href="#典型错误" class="headerlink" title="典型错误"></a>典型错误</h2><p><strong>npm install</strong> 的时候出现错误：</p><p>npm ERR! Unexpected end of JSON input while parsing near ‘…”,”webpack-dev-server’<br>1<br>解决方案：</p><p>第一步：</p><p>npm cache clean –force<br>1<br>第二步：（再安装）</p><p>npm install</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曲库</title>
      <link href="/2018/01/22/2017-conclusion/"/>
      <url>/2018/01/22/2017-conclusion/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>{<br>        “name”: “aloha heja he”,<br>        “artist”: “ - 群星”,<br>        “url”: “/medias/music/1.m4a”,<br>        “cover”: “/medias/music/avatars/7.jpg”<br>    },<br>    {<br>        “name”: “稻香”,<br>        “artist”: “周杰伦”,<br>        “url”: “/medias/music/daoxiang.mp3”,<br>        “cover”: “/medias/music/avatars/1.jpg”<br>    },{<br>        “name”: “最美的期待”,<br>        “artist”: “周笔畅”,<br>        “url”: “/medias/music/zuimeideqidai.flac”,<br>        “cover”: “/medias/music/avatars/2.jpg”<br>    },{<br>        “name”: “起床进行曲”,<br>        “artist”: “钱晨航”,<br>        “url”: “/medias/music/起床进行曲.m4a”,<br>        “cover”: “/medias/music/avatars/3.jpg”<br>    },{<br>        “name”: “像鱼”,<br>        “artist”: “王贰浪”,<br>        “url”: “/medias/music/xiangyu.flac”,<br>        “cover”: “/medias/music/avatars/4.jpg”<br>    },{<br>        “name”: “Turnin”,<br>        “artist”: “Young Rising Sons”,<br>        “url”: “/medias/music/Turnin.m4a”,<br>        “cover”: “/medias/music/avatars/5.jpg”<br>    },{<br>        “name”: “夜空中最亮的星”,<br>        “artist”: “小果酱”,<br>        “url”: “/medias/music/夜空中最亮的星.m4a”,<br>        “cover”: “/medias/music/avatars/6.jpg”<br>    }<br>    ,{<br>        “name”: “CountingStars”,<br>        “artist”: “OneRepublic”,<br>        “url”: “/medias/music/CountingStars.m4a”,<br>        “cover”: “/medias/music/avatars/8.jpg”<br>    },{<br>        “name”: “Still”,<br>        “artist”: “Timirage”,<br>        “url”: “/medias/music/Still.m4a”,<br>        “cover”: “/medias/music/avatars/9.jpg”<br>    },{<br>        “name”: “Canon(Cover Johann Pachelbel)”,<br>        “artist”: “向晚丶”,<br>        “url”: “/medias/music/10.mp3”,<br>        “cover”: “/medias/music/avatars/10.jpg”<br>    },{<br>        “name”: “#Lov3 #Ngẫu HứngCanon”,<br>        “artist”: “Hoaprox”,<br>        “url”: “/medias/music/11.m4a”,<br>        “cover”: “/medias/music/avatars/11.jpg”<br>    },{<br>        “name”: “Beautiful In White (Demo)”,<br>        “artist”: “Shane Filan”,<br>        “url”: “/medias/music/12.m4a”,<br>        “cover”: “/medias/music/avatars/12.jpg”<br>    }</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

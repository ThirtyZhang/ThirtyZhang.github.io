<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开发与打包</title>
      <link href="/2020/04/07/vue-jin-jie-app-kai-fa-he-da-bao/"/>
      <url>/2020/04/07/vue-jin-jie-app-kai-fa-he-da-bao/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue进阶"><a href="#Vue进阶" class="headerlink" title="Vue进阶"></a>Vue进阶</h1><ul><li><input disabled type="checkbox"> 能够实现项目的打包</li><li><input disabled type="checkbox"> 能够说出开发移动App的几种方式</li><li><input disabled type="checkbox"> 能够使用HBuliderX把移动端网站打包成移动App</li><li><input disabled type="checkbox"> 能够说出defineProperty的作用</li><li><input disabled type="checkbox"> 能够说出服务端渲染和客户端渲染的区别</li><li><input disabled type="checkbox"> 理解Nuxt的作用</li><li><input disabled type="checkbox"> 能够理解asyncData的作用 </li></ul><h2 id="阶段说明和内容介绍"><a href="#阶段说明和内容介绍" class="headerlink" title="阶段说明和内容介绍"></a>阶段说明和内容介绍</h2><p><strong>内容介绍</strong></p><ol><li><p>打包app</p></li><li><p>MVVM实现原理</p><p>  会带大家 写一个vue.js, 超简易版的vue.js</p><ol><li>Object.defineProperty()方法的使用 proxData</li><li>发布订阅模式</li><li>实现MVVM框架</li></ol></li><li><p>SSR服务端渲染 =&gt;nuxt框架 =&gt; 服务端渲染框架</p></li></ol><p><strong>阶段说明</strong> </p><ol start="4"><li><p>本阶段的内容<strong><code>MVVM</code></strong>部分在面试环节Vue部分属于重点项、必问点,常见的面试问题:</p><ul><li>Vue 数据绑定的原理？</li><li>MVVM 数据绑定的原理？</li><li>Vue 双向数据绑定的原理？</li><li>Vue 数据响应式原理？</li><li>数据响应式原理？</li><li>数据驱动视图的原理?</li></ul></li></ol><h2 id="移动App开发的几种方式"><a href="#移动App开发的几种方式" class="headerlink" title="移动App开发的几种方式"></a>移动App开发的几种方式</h2><blockquote><p>同学回答:  感觉就一种 H5</p></blockquote><ol><li><p><strong><code>原生App</code></strong>  =&gt;  微信/ 支付宝  =&gt; 体验 界面审查 流畅度极高 =&gt; 开发语言不是h5  安卓 =&gt;  安卓  ios =&gt;ios</p><p> black黑莓 / window phone / 塞班  / 安卓 系统  =&gt; java开发 /  ios 系统  =&gt; object-c /swift </p></li><li><p><strong><code>WebApp</code></strong>  =&gt; 黑马头条 =&gt; webapp =&gt; 移动网站 =&gt; H5 =&gt;vuejs/reactjs/angularjs/jquery/原生js</p></li><li><p><strong><code>HybridApp</code></strong>  =&gt; 混合开发  =&gt; 原生(提供端能力 )+ h5(业务功能 + 调用端能力)</p></li><li><p><strong><code>跨平台开发</code></strong> =&gt; React-Native =&gt; 跨平台 (  安卓/ 苹果 <code>/ 黑莓 /塞班 / windows phone )</code></p></li></ol><p>​            React-Native 是 facebook推出的 可以一套代码 跑在 安卓系统 和 ios系统的 框架, 它是原生的</p><p>​           Flutter  =&gt; Flutter 是谷歌推出的跨平台 开发项目, 也是原生 跨 安卓 + ios , 非标签形式</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token string">'package:flutter/material.dart'</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">runApp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyApp</span> <span class="token keyword">extends</span> <span class="token class-name">StatelessWidget</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@override</span>  Widget <span class="token function">build</span><span class="token punctuation">(</span>BuildContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MaterialApp</span><span class="token punctuation">(</span>      title<span class="token operator">:</span> <span class="token string">'Welcome to Flutter'</span><span class="token punctuation">,</span>      home<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Scaffold</span><span class="token punctuation">(</span>        appBar<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">AppBar</span><span class="token punctuation">(</span>          title<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string">'Welcome to Flutter'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span><span class="token punctuation">,</span>        body<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Center</span><span class="token punctuation">(</span>          child<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​          开发模式类似  后端开发</p><p>​            React-Native 遵循 react开发规范的 原生开发  =&gt;状态机(类似 Vue的响应式数据)</p><pre class="line-numbers language-JSX"><code class="language-JSX">import { View, Text  } from 'react-native/components'class App  extends React.Components {    // 渲染函数 必须实现 必须返回组件结构 必须有一个根节点    state = {       name: '张三'    }    render () {        let { name } = this.state        return (<View>                <Text>{ name }</Text>            </View>)    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>weex  =&gt; 跨平台框架 ,也可以支持 Vuejs语法规范 </p><p>跨平台 最重要的是  =&gt;  生成的代码不是h5, 而是 对应的原生代码,体验 和原生几乎一样</p><p>​            Reactjs  =&gt;  遵循react开发规范的H5开发</p><ol><li><p>其他类型(<strong><code>小程序</code></strong>/<strong><code>快应用</code></strong>等等)  微信 /支付宝 /百度/抖音/头条/qq/钉钉/高德..</p><p>…快应用</p><p><img src="app.png" alt></p></li></ol><h2 id="移动App开发-原生-NativeApp介绍和特点"><a href="#移动App开发-原生-NativeApp介绍和特点" class="headerlink" title="移动App开发-(原生)NativeApp介绍和特点"></a>移动App开发-(<code>原生</code>)NativeApp介绍和特点</h2><p><strong>定义</strong>:传统的原生App开发模式，有iOS和Android两大系统，需要各自语言开发各自App。 </p><p><strong>优点</strong>：性能和体验都是最好的, 用的都是本系统的原生组件,没有网络渲染问题</p><p><strong>缺点</strong>：开发和发布成本高  =&gt; 需要专业的安卓 和 ios开发人员  ios  系统 闭环 , 应用上传appStore</p><p>微信会推出小程序?  ios把握着应用命脉  16</p><p>支付宝 也这么想   17</p><p>百度也这么想   17</p><p>头条也这么想  18-19</p><p>qq 也这么想 18-19</p><p>钉钉 也这么想</p><p>各大手机厂商也这么想</p><p>抖音这么想..</p><p><strong>应用技术</strong>：Swift，OC，Java</p><blockquote><p>常识: 安卓/iOS/Web 基本都使用Mac进行开发</p></blockquote><h2 id="移动App开发-WebApp介绍和特点"><a href="#移动App开发-WebApp介绍和特点" class="headerlink" title="移动App开发-WebApp介绍和特点"></a>移动App开发-WebApp介绍和特点</h2><p><a href="https://m.toutiao.com/?" target="_blank" rel="noopener">M站演示</a>  </p><p><strong>定义</strong>: 移动端的网站，常被称为<strong><code>H5应用</code></strong>，说白了就是特定运行在移动端浏览器上的网站应用。一般泛指 <strong><code>SPA</code>(</strong>Single Page Application)模式开发出的网站，与<strong><code>MPA</code>（</strong>Multi-page Application）对应。 </p><p>8 / 10 / 12 /15</p><p><strong><code>优点</code></strong>：<strong>开发和发布成本最低</strong> </p><ol><li><p>开发成本低,可以跨平台,调试方便，开发速度最快</p><p>webapp一般只需要一个前端人员开发出一套代码,然后即可应用于各大主流<strong><code>浏览器</code></strong>(特殊情况可以代码进行下兼容),没有新的学习成本,而且可以直接在浏览器中调试</p></li><li><p>维护成本低</p><p>同上,如果代码合理,只需要一名前端就可以维护多个web app</p></li><li><p>更新最为快速</p><p>由于web app资源是直接部署在服务器端的,所以只需要替换服务器端的文件,用户访问是就已经更新了(当然需要解决一些缓存问题)</p></li><li><p>无需安装App,不会占用手机内存</p><p>通过浏览器即可访问,无需安装,用户就会比较愿意去用</p></li></ol><p><strong><code>缺点</code></strong>：<strong>性能和体验不能讲是最差的</strong>，但也<strong>受到浏览器处理能力的限制</strong></p><ol><li><p>性能低,用户体验差</p><p>由于是直接通过的浏览器访问,所以无法使用原生的API,操作体验不好</p></li><li><p>依赖于网络,页面访问速度慢,耗费流量</p><p>Web App每次访问都需要去服务端加载资源访问,所以必须依赖于网络,而且网速慢时访问速度很不理想,特别是在移动端,如果网站优化不好会无故消耗大量流量</p></li><li><p>功能受限,大量功能无法实现</p><p>只能使用Html5的一些特殊api,无法调用原生API,所以很多功能存在无法实现情况</p></li><li><p>临时性入口,<strong><code>用户留存率低</code></strong>, 这个<strong><code>几乎是不可原谅</code></strong>的</p><p>这既是它的优点,也是缺点,优点是无需安装,缺点是用完后有时候很难再找到,或者说很难专门为某个web app留存一个入口,导致用户很难再次使用</p></li></ol><p><strong>应用技术</strong>：<strong><code>ReactJS</code></strong>，<strong><code>AngularJS</code></strong>，<code>VueJS</code>等等 </p><h2 id="移动App开发-HybridApp介绍和特点"><a href="#移动App开发-HybridApp介绍和特点" class="headerlink" title="移动App开发-HybridApp介绍和特点"></a>移动App开发-HybridApp介绍和特点</h2><p>WebView =&gt; 原生浏览器的内置浏览器</p><p><strong>定义</strong>:混合模式移动应用，介于<strong><code>Web App</code>、<code>Native App</code></strong>这两者之间的App开发技术，兼具“Native App良好交互体验的优势”和“Web App跨平台开发的优势” ,<strong>原生客户端的壳<code>WebView</code>，其实里面是HTML5的网页</strong></p><blockquote><p>webview 就是一个内置的浏览器  =&gt; 里面是我们做的 h5的网页  外面是一个安卓或者 ios的<strong><code>壳</code></strong>  只提供 API,不做具体业务   </p></blockquote><p>举例 :  电商app ,  所有的业务 都是h5网页, 外面的壳 是安卓或者ios,提供SDK(调用原生能力的包) / 拍照/录像/录音/   h5网页  =&gt; js  调用 原生能力 </p><ul><li>把网页打包成移动 App</li><li>使你的 Web 程序可以访问手机原生能力</li></ul><p><strong><code>优点</code></strong>：开发和发布都比较方便，效率介于Native App、Web App之间 </p><ol><li><p>开发成本较低,可以跨平台,调试方便</p><p>Hybrid模式下,由原生提供统一的API给JS调用,实际的主要逻辑有Html和JS来完成,而由于最终是放在webview中显示的,所以只需要写一套代码即可,达到跨平台效果,另外也可以直接在浏览器中调试,很为方便</p><p>最重要的是只需要一个前端人员稍微学习下JS api的调用即可,无需两个独立的原生人员</p><p>一般Hybrid中的跨平台最少可以跨三个平台:Android App,iOS App,普通webkit浏览器</p></li><li><p>维护成本低,功能可复用</p><p>同上,如果代码合理,只需要一名前端就可以维护多个app,而且很多功能还可以互相复用</p></li><li><p>更新较为自由</p><p> 混合开发 实际上 就是 安卓的壳 /ios壳  +  html/js/css </p><p>更新的话 只需要 下载最新的  html+js+css(<strong><code>本地模式</code></strong>)</p><p>安卓的壳 /ios壳  + webview(<strong><code>线上地址</code></strong>)(<strong><code>线上模式</code></strong>)  =&gt; 更新只需要部署到服务器即可 (性能和效率是比较低)</p><p>虽然没有web app更新那么快速,但是Hybrid中也可以通过原生提供api,进行资源主动下载,达到只更新资源文件,不更新apk(ipa)的效果  (进入之后<strong><code>热更新</code></strong>)</p></li><li><p>针对新手友好,学习成本较低</p><p>这种开发模式下,只需要前端人员关注一些原生提供的API,具体的实现无需关心,没有新的学习内容,只需要前端人员即可开发22</p></li><li><p>功能更加完善,性能和体验要比起web app好太多</p><p>因为<strong><code>可以调用原生api</code></strong>,所以很多功能只要原生提供出就可以实现,另外性能也比较接近原生了</p></li><li><p>部分性能要求的页面可用原生实现</p><p>H5实现不了的 原生来做 </p><blockquote><p>一般来说 壳+html+js+css , 壳+ 部分原生 + html/js+css</p></blockquote><p>这应该是Hybrid模式的最多一个好处了,因为这种模式是原生混合web,所以我们完全可以将交互强,性能要求高的页面用原生写,然后一些其它页面用JS写,嵌入webview中,达到最佳体验</p></li></ol><p><strong>缺点</strong>：学习范围较广，需要原生配合 </p><ol><li><p>相比原生,性能仍然有较大损耗</p><p>这种模式<strong>受限于webview</strong>的性能桎梏,相比原生而言有不少损耗,体验无法和原生相比</p></li><li><p>不适用于交互性较强的app</p><p>这种模式的主要应用是:一些新闻阅读类,信息展示类的app;但是不适用于一些交互较强或者性能要求较高的app(比如动画较多就不适合)</p></li></ol><p><strong>应用技术</strong>：<a href="https://cordova.apache.org/" target="_blank" rel="noopener">Cordova</a>、<a href="http://www.appcan.cn/" target="_blank" rel="noopener">APPCan</a>、 <a href="https://dcloud.io/" target="_blank" rel="noopener">DCloud</a> 、<a href="https://www.apicloud.com/" target="_blank" rel="noopener">API Cloud </a></p><p>一般大公司不会用这些壳,大公司有能力 有资本 有能力自己做原生 自己封装sdk, 比如 支付宝 / 微信 .. 抖音 ./头条</p><p><strong>四种方式对比</strong></p><p><img src="zl9vgosvxs.png" alt="img"></p><p><img src="4t0yf9dnpw.png" alt="img"></p><h2 id="移动App开发-跨平台开发介绍和特点"><a href="#移动App开发-跨平台开发介绍和特点" class="headerlink" title="移动App开发-跨平台开发介绍和特点"></a>移动App开发-跨平台开发介绍和特点</h2><blockquote><p>特点：使用类似于 Web 技术的方式来开发 Native App。</p><p>React Native (原生开发)和 reactjs(h5开发)是两回事  =&gt; 同时都用jsx语法 ,都用react语法规范  状态机 state (React)  Vue (data)</p></blockquote><p><strong>定义</strong>: <strong><code>Facebook</code></strong>发现Hybrid App存在很多缺陷和不足，于是发起开源的一套新的App开发方案<strong><code>React Native</code></strong>。使用<strong><code>JSX语言</code></strong>写原生界面，js通过JSBridge调用原生API渲染UI交互通信。</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token keyword">import</span> Menu  <span class="token keyword">from</span> <span class="token string">'menu'</span><span class="token comment" spellcheck="true">// 定义一个组件叫App react 16.8之前的语法</span><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// render函数  渲染方法 要求必须返回一个元素 元素只能有且只有一个根节点</span>    <span class="token comment" spellcheck="true">// 标签 闭合标签 和 js逻辑混写</span>    <span class="token comment" spellcheck="true">// state </span>    state <span class="token operator">=</span> <span class="token punctuation">{</span>        name <span class="token punctuation">:</span> <span class="token string">'张三'</span>    <span class="token punctuation">}</span>    changeName <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// this.name = '李四'</span>         <span class="token comment" spellcheck="true">// 改变张三为李四</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>             name<span class="token punctuation">:</span> <span class="token string">'李四'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    render <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">></span>          <span class="token operator">&lt;</span>p<span class="token operator">></span>  <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>name  <span class="token punctuation">}</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>          <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>changeName<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>改变name<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>          <span class="token operator">&lt;</span>Menu <span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 16.8之后 推出了函数式的组件  react hooks</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>React-Native 就是<strong><code>用js的方式 去开发 原生应用那个 一套代码  安卓/ios上面</code></strong></p><p>招人的 时候 会说 =&gt; 招聘 React-Native工程师, 具备安卓和ios 相关一些背景, Android Studio  /  XCode</p><p><strong><code>优点</code></strong>：效率体验接近Native App，发布和开发成本低于Native App</p><ol><li><p>虽然说开发成本大于Hybrid模式,但是小于原生模式,大部分代码可复用</p><p>相比于原生模式,这种模式是统一用JS写代码,所以往往只需要一名成员投入学习,即可完成跨平台app的开发,而且后续代码封装的好,很多功能可复用</p></li><li><p>性能体验高于Hybrid,不逊色与原生</p><p>这种模式和Hybrid不一样,Hybrid中的view层实际上还是dom,但是这种模式的view层是虚拟dom,所以性能要高于Hybrid,距离原生差距不大</p><p>这种模式可以认为是用JS写原生,即页面用JS写,然后原生通过Bridge技术分析JS,将JS内容单独渲染成原生Android和iOS,所以也就是为什么性能不逊色原生</p></li><li><p>开发人员单一技术栈,一次学习,跨平台开发 </p><p>这种模式是统一由JS编写,有着独特的语法,所以只需要学习一次,即可同时开发Android和iOS</p></li><li><p>社区繁荣,遇到问题容易解决</p><p>这应该是React Native的很大一个优势,不像Hybrid模式和原生模式一样各自为营,这种模式是Facebook统一发起的,所以有一个统一的社区,里面有大量资源和活跃的人员,对开发者很友好</p></li></ol><p><strong><code>缺点</code>:</strong> 学习有一定成本，且文档较少，免不了踩坑  </p><ol><li><p>虽然可以部分跨平台,但并不是Hybrid中的一次编写,两次运行那种,而是不同平台代码有所区别</p><p>这种模式实际上还是JS来写原生,所以Android和iOS中的原生代码会有所区别,如果需要跨平台,对开发人员有一定要求</p><p>当然了,如果发展了有一定时间,组件库够丰富了,那么其实影响也就不大了,甚至会比Hybrid更快</p></li><li><p>开发人员学习有一定成本</p><p>虽然社区已经比较成熟了,但是一个新的普通前端学习起来还是有一定学习成本的,无法像Hybrid模式一样平滑</p></li><li><p>学习成本大，对开发人员技术要求比较高</p></li><li><p>不懂原生开发很难驾驭好</p></li><li><p>说是使用 Web 技术进行开发，还是多少得学点儿原生 App 开发，才能处理好跨平台。</p></li><li><p>前期投入比较大，后劲很足。</p></li></ol><p><strong>应用技术</strong> :</p><p><strong>React Native（主流）</strong></p><ul><li>公司：Facebook</li><li>技术栈：React</li><li>基于React开发App的框架RN</li></ul><p><strong>其他技术</strong>: </p><p><strong>Weex（使用不多）</strong></p><ul><li>公司：Apache 开源基金会</li><li>Vue.js 技术栈</li><li>基于Vue开发App的框架WEEX</li></ul><p><strong>Flutter（未来趋势）</strong></p><ul><li>公司：Google</li><li>它提供了官方的原生 UI 组件</li><li>比 RN、Weex 之类的体验更好  =&gt;代码 不像前端代码 =&gt; 代码更接近于后端</li><li>开发语言：Dart（和 JavaScript 很像）</li><li>商业应用：闲鱼</li></ul><h2 id="移动App开发-其他类型App"><a href="#移动App开发-其他类型App" class="headerlink" title="移动App开发-其他类型App"></a>移动App开发-其他类型App</h2><blockquote><p>小程序</p></blockquote><ul><li><p><strong>微信小程序</strong></p></li><li><p>百度小程序</p></li><li><p>头条小程序</p></li><li><p>支付宝小程序</p></li><li><p>快应用 …  10大手机厂商推出的</p><blockquote><p>本质</p></blockquote></li><li><p>混合开发 + 微信搞了一套 微信小程序的开发规范  =&gt; vue /react </p></li><li><p>混合开发 + 支付宝搞了一套微信小程序的开发规范 </p></li></ul><blockquote><p>统一开发平台</p></blockquote><ul><li>taro(京东)-&gt;坑多 趋势很好 是有react 为基础的开发语言规范</li><li>uni-app    是以 vuejs为基础开发语言规范</li></ul><blockquote><p>一套代码 开发多套 应用  </p><p>taro  -&gt; 是以 React为语法规范   =&gt; 只需要写一遍代码  =&gt;对应编译成不同的端</p><p>uni-app 是以 vue语法规则</p><p>Chameleon 是滴滴的也是 一端多用</p><p>mpVue 美团的应用  一端多用</p></blockquote><p><strong><code>微网页</code></strong></p><ul><li><strong>微信公众号</strong> /在微信中嵌入了h5页面</li><li>百度直达号  /在百度中嵌入了h5页面</li><li>。。。</li></ul><p><strong><code>快应用</code></strong></p><p>9大手机厂商 =&gt; 联合推出 了一个标准  =&gt;体验接近原生 =&gt; 但是坑巨多,流量巨少</p><ul><li>各大手机厂商联合制定推出的一种方式，类似于小程序</li><li>使用 Web 技术进行开发， 而且提供了在 Web 中访问手机硬件等底层交互的 API</li><li>属于混合 App 的一种方式</li></ul><p><strong><code>PWA</code></strong>（网站离线访问技术，没有 iPhone 不参与）</p><ul><li>它可以让网站拥有一个类似于 App 的入口</li><li>提供了网站的离线应用访问</li><li>Google 在推动</li><li>手机端目前只能在 安卓手机的 Chrome 浏览器运行</li></ul><h2 id="移动App开发-开发模式对比和选择"><a href="#移动App开发-开发模式对比和选择" class="headerlink" title="移动App开发-开发模式对比和选择"></a>移动App开发-开发模式对比和选择</h2><p>各大开发模式对比</p><table><thead><tr><th align="left"></th><th align="left">Native App</th><th align="left">Web App</th><th align="left">Hybrid App</th><th align="left">React Native App</th></tr></thead><tbody><tr><td align="left">原生功能体验</td><td align="left">优秀</td><td align="left"><strong>差</strong></td><td align="left">良好</td><td align="left"><strong>接近优秀</strong></td></tr><tr><td align="left">渲染性能</td><td align="left">非常快</td><td align="left">慢</td><td align="left">接近快</td><td align="left">快</td></tr><tr><td align="left">是否支持设备底层访问</td><td align="left">支持</td><td align="left">不支持</td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left">网络要求</td><td align="left">支持离线</td><td align="left">依赖网络</td><td align="left">支持离线(资源存本地情况)</td><td align="left">支持离线</td></tr><tr><td align="left">更新复杂度</td><td align="left">高(几乎总是通过应用商店更新)</td><td align="left">低(服务器端直接更新)</td><td align="left">较低(可以进行资源包更新)</td><td align="left">较低(可以进行资源包更新)</td></tr><tr><td align="left">编程语言</td><td align="left">Android(Java),iOS(OC/Swift)</td><td align="left">js+html+css3</td><td align="left">js+html+css3</td><td align="left">主要使用JS编写,语法规则JSX</td></tr><tr><td align="left">社区资源</td><td align="left">丰富(Android,iOS单独学习)</td><td align="left">丰富(大量前端资源)</td><td align="left">有局限(不同的Hybrid相互独立)</td><td align="left">丰富(统一的活跃社区)</td></tr><tr><td align="left">上手难度</td><td align="left"><strong>难(不同平台需要单独学习)</strong></td><td align="left">简单(写一次,支持不同平台访问)</td><td align="left">简单(写一次,运行任何平台)</td><td align="left"><strong>挺等(学习一次,写任何平台)</strong></td></tr><tr><td align="left">开发周期</td><td align="left">长</td><td align="left">短</td><td align="left">较短</td><td align="left">中等</td></tr><tr><td align="left">开发成本</td><td align="left">昂贵</td><td align="left">便宜</td><td align="left">较为便宜</td><td align="left">中等</td></tr><tr><td align="left">跨平台<em>**</em></td><td align="left"><strong>不跨平台<em>**</em></strong></td><td align="left"><strong>所有H5浏览器</strong></td><td align="left">Android,iOS,h5浏览器<em>**</em></td><td align="left"><strong>Android,iOS</strong></td></tr><tr><td align="left">APP发布</td><td align="left">App Store</td><td align="left">Web服务器</td><td align="left">App Store</td><td align="left">App Store</td></tr></tbody></table><blockquote><p> 如何选择开发模式</p></blockquote><p>目前有多种开发模式,那么我们平时开发时如何选择用哪种模式呢？如下</p><ul><li>选择纯Native App模式的情况</li></ul><ul><li><p>性能要求极高,体验要求极好,不追求开发效率</p><p>一般属于吹毛求疵的那种级别了,因为正常来说如果要求不是特别高,会有Hybrid</p></li></ul><blockquote><p>选择Web App模式的情况</p></blockquote><ul><li><p>不追求用户体验和性能,对离线访问没要求</p><p>正常来说,如果追求性能和体验,都不会选用web app</p></li><li><p>没有额外功能,只有一些信息展示</p><p>因为web有限制,很多功能都无法实现,所以有额外功能就只能弃用这种方案了</p></li></ul><ul><li>选择Hybrid App(混合开发)模式的情况</li></ul><ul><li><p><strong>大部分情况下的App</strong>都推荐采用这种模式</p><p>这种模式可以用原生来实现要求高的界面,对于一些比较通用型,展示型的页面完全可以用web来实现,达到跨平台效果,提升效率</p><p>当然了,一般好一点的Hybrid方案,都会把资源放在本地的,可以减少网络流量消耗</p></li></ul><blockquote><p>选择React Native App模式的情况</p></blockquote><ul><li><p>追求性能,体验,同时追求开发效率,而且有一定的技术资本,舍得前期投入</p><p>React Native这种模式学习成本较高,所以需要前期投入不少时间才能达到较好水平,但是有了一定水准后,开发起来它的优势就体现出来了,性能不逊色原生,而且开发速度也很快</p></li></ul><blockquote><p>选择其它方案</p></blockquote><ul><li><strong>小程序</strong>（目前移动 App 中开发难度最低的，体验也是仅次于原生+跨平台NativeApp）</li></ul><h2 id="HTML5-介绍-HBuliderX安装和完整示例项目"><a href="#HTML5-介绍-HBuliderX安装和完整示例项目" class="headerlink" title="HTML5+介绍-HBuliderX安装和完整示例项目"></a>HTML5+介绍-HBuliderX安装和完整示例项目</h2><blockquote><p>DClound是什么?  HTML5+又是什么?</p></blockquote><p><a href="https://www.dcloud.io/index.html" target="_blank" rel="noopener">DClound官网</a></p><p>DCloud面向HTML5行业分别推出了开发工具<strong><code>HBuilder</code></strong>、手机强化引擎<strong><code>5+ Runtime</code></strong>、<strong><code>前端框架mui</code></strong>，通过系列产品对HTML5的强化支持，使得HTML5能达到原生的功能和体验，同时在发行上更优于原生应用。</p><blockquote><p>这里 <strong><code>Hbuilder</code></strong>是开发工具, <strong><code>mui</code></strong>是前端UI框架(类似于vant),但不是Vue技术栈,<strong><code>5+ Runtime</code></strong>是  一个手机强化引擎, 相当于一个<strong><code>强化版的webview</code></strong>(让浏览器拥有了原生的能力) 拍照/录音/二维码 …</p></blockquote><p>DClound做了很多事情, 开发工具, 前端框架, 浏览器引擎,我们通过一个例子来认识它</p><blockquote><p>接下来 ,我们希望完成一个轻量<strong><code>混合应用</code></strong>的开发, <strong><code>混合应用</code></strong> 即  H5 + 原生, 但是我们并没有 原生SDK,这个时候就可以借助 <strong><code>5+ RunTime</code></strong> 来做, 那么我们的界面 恰好可以用 它专属的mui来布局设计</p><p>OK, 那么接下来,我们尝试 在<strong><code>HBuilderX</code></strong>中,开发一个<strong><code>混合应用</code></strong>,利用<strong><code>mui</code></strong>做布局,利用 <strong><code>5+ RunTime</code></strong>提供原生能力</p></blockquote><p> <strong><code>开始!</code></strong></p><blockquote><p>第一步, 我们需要先下载<a href="https://www.dcloud.io/hbuilderx.html" target="_blank" rel="noopener">HbuilderX开发版</a></p></blockquote><blockquote><p>第二步, 我们创建一个项目,但是我们创建项目的时候,惊呆了!因为Hbuilder可以创建 各种类型的项目</p><p>简单说一下:  <img src="image-20200211233833961.png" alt="image-20200211233833961"></p></blockquote><blockquote><p>普通项目  =&gt;  普通H5项目, Hbuilder内置了几套模板,作用不大,同学们基本都会自己创建</p><p>uni-app   =&gt; 多端应用,一套代码,复用八端,时下最火的一个跨端框架</p><p>wap2App  =&gt;wap项目转 App , 原来只运在手机上的wap(无线网络协议,诺基亚,爱立信时代)项目 可转app项目</p><p>5+ App  =&gt;  利用DCloud 的 <strong><code>5+ Runtime</code></strong>来做原生能力提供者的 项目</p><p>小程序  =&gt;  微信原生小程序的另外一个编辑器,比微信提供的开发者工具好用,但是现在谁还在用原生写小程序呢?</p><p>快应用  =&gt; 原生快应用 编辑器 , 较为冷门的生态, 目前不太热闹</p></blockquote><p>我们要选择5+App 项目,我们说了要用 mui前端框架,所以选择一个mui项目</p><blockquote><p>第三步,项目创建好之后,我们着手对界面进行设计和开发,  <a href="https://dev.dcloud.net.cn/mui/getting-started/" target="_blank" rel="noopener">mui文档</a></p><p>hbuilderx提供了很多简单快速的快捷键,我们简单学习两个即可,在body中输入 <strong><code>moffcanvas</code></strong>,会给出 mui几套基础界面的提示 我们随便选择一个 <strong><code>moffcanvas</code></strong>(侧滑导航,主界面,菜单同时移动)</p></blockquote><blockquote><p>第四步 ,我们在页面中输入一个九宫格 <strong><code>mGrid</code></strong>, 然后 把图标换成  拍照 / 地图 / 电话 / 信息</p></blockquote><p><img src="image-20200212003656485.png" alt="image-20200212003656485"></p><p>OK,我们经过几步 完成了这样一个页面,<strong><code>注意</code></strong>,<strong><code>我们的目的并不是学习mui</code></strong>,而是体验DCloud,这个世界上的前端框架何止几百种,永远是学不完的,开发只会用一种前端UI, 我们通过对于这个示例的学习进而了解 混合开发</p><blockquote><p>我们的界面搭建完毕, 接下来我们要尝试去调用摄像头 和 地图 以及电话</p></blockquote><h2 id="HBuliderX-中-5-RunTime的使用和测试"><a href="#HBuliderX-中-5-RunTime的使用和测试" class="headerlink" title="HBuliderX 中 5+RunTime的使用和测试"></a>HBuliderX 中 5+RunTime的使用和测试</h2><blockquote><p>我们已经完成了H5页面, 我们知道混合开发其实是 H5 + 原生能力,现在H5有了,原生能力在哪?</p></blockquote><blockquote><p>老高告诉你,<strong><code>你已经有了原生能力</code></strong>! </p><p><strong><code>what ?</code></strong>   <strong><code>Are you Kidding  me</code></strong> ?</p><p>没错! 我们创建的项目是 5+ Runtime,  这个项目本身就自带原生能力的, 究其原因就是因为 我们的项目中多了一个文件 <strong><code>manifest.json</code></strong>   <a href="https://ask.dcloud.net.cn/article/94" target="_blank" rel="noopener">说明地址</a>,该文件是一个w3c的webapp配置文件</p><p>HbuilderX 给我们的页面中注入了个全局对象 <strong><code>plus</code></strong>, 这个plus就是我们的原生能力</p><p>我们可以在页面中监听plus初始化完成的事件</p></blockquote><pre class="line-numbers language-js"><code class="language-js">    document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'plusready'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'原生能力准备好了'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong><code>在模拟器/真机测试</code></strong></p><blockquote><p>接下来,我们尝试在模拟器或者真机中运行 我们写好的程序. 如果你没有安卓手机, 那么你只能选择模拟器来测试</p></blockquote><p>这里推荐一个<a href="https://www.yeshen.com/" target="_blank" rel="noopener">夜神模拟器</a>,值得注意的是,我们需要把HbuilderX的安卓调试设置为<strong><code>62001</code></strong>,否则将不能连接</p><p><img src="image-20200212014533423.png" alt="image-20200212014533423"></p><blockquote><p>真机调试,需要将手机的开发者选项打开,并且启动usb调试, <strong><code>注意</code></strong> 必须采用数据线连接</p></blockquote><p>在选中当前项目的情况下 , 在 HBuilder 中找到：运行 -&gt; 运行到手机或模拟器 -&gt; 你的设备</p><p><a href="http://ask.dcloud.net.cn/article/97" target="_blank" rel="noopener">HBuilder/HBuilderX真机运行、手机运行、真机联调常见问题</a></p><p><strong><code>开发简单的几个小功能</code></strong></p><ul><li><a href="http://www.html5plus.org/doc/zh_cn/camera.html" target="_blank" rel="noopener">5+ Runtime的文档 </a></li></ul><blockquote><p>第一步,我们想拍张照片然后放在页面上, 刚说了<strong><code>plus</code></strong>是我们的原生能力,怎么调摄像头拍照?</p><p><a href="http://www.html5plus.org/doc/zh_cn/camera.html" target="_blank" rel="noopener">拍照API</a></p><p>拍照代码</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> takePhoto <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">var</span> carmera <span class="token operator">=</span>    plus<span class="token punctuation">.</span>camera<span class="token punctuation">.</span><span class="token function">getCamera</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 获取主摄像头对象</span>           carmera<span class="token punctuation">.</span><span class="token function">captureImage</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// 注意这个地址不能用 需要转化</span>               <span class="token comment" spellcheck="true">// 需要将相对手机路径变成绝对路径</span>            <span class="token keyword">let</span> absoluteUrl <span class="token operator">=</span> plus<span class="token punctuation">.</span>io<span class="token punctuation">.</span><span class="token function">convertLocalFileSystemURL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">// 我们把地址放到一个新的图片上</span>             document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"myImg"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>src <span class="token operator">=</span> absoluteUrl           <span class="token punctuation">}</span><span class="token punctuation">)</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><blockquote><p>第二步,我们进行地图的定位, 我们希望做一个 在高德地图中 显示<strong><code>黑马校区位置</code></strong>的 功能</p></blockquote><blockquote><p><a href="http://www.html5plus.org/doc/zh_cn/maps.html" target="_blank" rel="noopener">地图API</a></p><p>地图代码  =&gt; 我们单独新建一个页面 map.html 专门放置 地图导航</p><p>地图页面的模板</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span>doctype html<span class="token operator">></span><span class="token operator">&lt;</span>html<span class="token operator">></span>   <span class="token operator">&lt;</span>head<span class="token operator">></span>       <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token operator">></span>       <span class="token operator">&lt;</span>title<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>       <span class="token operator">&lt;</span>meta name<span class="token operator">=</span><span class="token string">"viewport"</span> content<span class="token operator">=</span><span class="token string">"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"</span> <span class="token operator">/</span><span class="token operator">></span>       <span class="token operator">&lt;</span>link href<span class="token operator">=</span><span class="token string">"css/mui.css"</span> rel<span class="token operator">=</span><span class="token string">"stylesheet"</span> <span class="token operator">/</span><span class="token operator">></span>       <span class="token operator">&lt;</span>style type<span class="token operator">=</span><span class="token string">"text/css"</span><span class="token operator">></span>           #app <span class="token punctuation">{</span>               width<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>               position<span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>               top<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>               left<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>               height<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">;</span>               background<span class="token operator">-</span>color<span class="token punctuation">:</span> #0062CC<span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span>   <span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>   <span class="token operator">&lt;</span>body<span class="token operator">></span>       <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"js/mui.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>       <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>           mui<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>       <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span>           地图加载中<span class="token operator">...</span>       <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>       <span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">></span>           <span class="token comment" spellcheck="true">// 模拟器没有地图 只能在真机上测试</span>       <span class="token keyword">var</span> initMap <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 初始化地图</span>           <span class="token keyword">var</span>  map <span class="token operator">=</span>    <span class="token keyword">new</span> <span class="token class-name">plus<span class="token punctuation">.</span>maps<span class="token punctuation">.</span>Map</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 实例化一个map对象</span>           map<span class="token punctuation">.</span><span class="token function">setCenter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">plus<span class="token punctuation">.</span>maps<span class="token punctuation">.</span>Point</span><span class="token punctuation">(</span><span class="token number">116.635699</span><span class="token punctuation">,</span> <span class="token number">40.169122</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 设置中心点</span>       <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 下面代码用来保证 执行初始化地图时  plus是一定有值</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>plus<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果plus存在表示 此时已经初始化原生能力 结束</span>            <span class="token function">initMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"plusready"</span><span class="token punctuation">,</span> initMap<span class="token punctuation">)</span>        <span class="token punctuation">}</span>       <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>   <span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置坐标点</p></blockquote><blockquote><p>接下来 ,我们做最后一个功能 打电话 ,就打给 联通客服 10010</p><p><a href="https://www.html5plus.org/doc/zh_cn/device.html" target="_blank" rel="noopener">硬件API</a></p></blockquote><blockquote><p>直接上代码</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 打电话 </span>       <span class="token keyword">var</span> takePhone <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           plus<span class="token punctuation">.</span>device<span class="token punctuation">.</span><span class="token function">dial</span><span class="token punctuation">(</span><span class="token string">'10086'</span><span class="token punctuation">)</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>需要注意的是: <strong><code>地图/电话 这两个功能只能在真机上测试哦</code></strong></p><h2 id="HBuliderX打包开发示例"><a href="#HBuliderX打包开发示例" class="headerlink" title="HBuliderX打包开发示例"></a>HBuliderX打包开发示例</h2><blockquote><p>OK, 我们上一节,做了一个小小的混合应用,这个应用我们想要让别人安装使用, 需要把我们新建的 <strong><code>5+App</code></strong></p><p>打包成一个 安卓的apk 或者 苹果的 .ipa</p><p>注意: 打包工作 <strong><code>目前不是</code></strong>我们作为前端开发的重点, 只有掌握了精湛的前端技术, 熟练的开发各种移动应用之后,才有可能 有机会 去做类似的工作,所以这里我们尝试去练习,我们的重难点 还在 vue/react 这些技术栈上,</p><p>而不是把时间放在配置各种乱七八糟的前端打包编译环境上,假以时日,技术成熟,再来搞也不迟</p></blockquote><p>配置<a href="http://ask.dcloud.net.cn/article/94" target="_blank" rel="noopener">mainfest.json</a>文件 , 此文件是配置我们app的各种配置,例如 图标,权限,启动屏</p><blockquote><p>我们设置一个图标 和启动屏幕,具体参照视频操作,</p><p>这里<strong><code>需要特别注意</code></strong>::由于我们用了<strong><code>百度地图</code></strong>功能, 所以打包的时候需要用一个公共的sdk的api_key,</p><p>需要到百度开发者中心注册一个账号,得到一个地图的key</p><p><a href="https://ask.dcloud.net.cn/article/29" target="_blank" rel="noopener">操作文档</a></p></blockquote><blockquote><p>接下里, 我们进行打包,</p><p>在 HBuilder 中找到：发行 -&gt; 原生 App（云打包）</p><p>等待一段时间，得到打包结果安装包，然后安装到手机上测试</p><p>最后根据需要发布到对应的手机应用商店</p></blockquote><p><strong><code>注意</code></strong>, 打包本身分两种, 一种<strong><code>本地打包</code></strong>,一种<strong><code>云打包</code></strong></p><p>本地打包<strong><code>需要配置</code></strong>  安卓以及苹果的开发打包环境  <a href="https://ask.dcloud.net.cn/article/508" target="_blank" rel="noopener">安卓本地打包说明</a></p><p>云打包 是把我们的资源提交到DCloud服务器, 由DCloud完成打包</p><p>后者 比较简单不需要 环境安装, 我们此次采用云打包方式</p><blockquote><p>一般在企业中还是 本地打包居多,因为谁都不想把自己的开发好的东西提交到别人的服务器</p></blockquote><ul><li>云打包提交之后,稍等几分钟, 此时 DCloud 会返回一个下载链接 (只允许下载5次),我们可以下载尝试安装</li></ul><p>一切顺利,安装完毕. </p><blockquote><p>虽然成功了, 但是我们也清楚的看到, 打包并不是那么简单,有很多环境,属性细节需要设置 调整.</p></blockquote><h2 id="HBuliderX打包黑马头条"><a href="#HBuliderX打包黑马头条" class="headerlink" title="HBuliderX打包黑马头条"></a>HBuliderX打包黑马头条</h2><blockquote><p>通过HBuliderX将黑马头条项目打包成app,生成apk文件下载安装测试</p><p>黑马头条我们已经完成, 此时来讲黑马头条打包成 App</p></blockquote><p><strong><code>值得注意</code></strong>的是: 我们的黑马头条就是H5, H5就是运行在浏览器中的, 只不过运行在 <strong><code>5+ Runtime</code></strong>这个增强版浏览器里面, 浏览器和 APP的物理按钮并没有进行关联, 也就是 点击手机返回按钮, 浏览器并不会进行返回</p><p>所以我们需要在我们的 页面中 对物理返回按键进行一下处理</p><blockquote><p>下面的代码 就是   <strong><code>5+ Runtime</code></strong>的处理物理返回按钮的问题</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 在main.js中添加如下代码  此代码是采用的 5+ Runtime中的plus对象</span>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'plusready'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> webview <span class="token operator">=</span> window<span class="token punctuation">.</span>plus<span class="token punctuation">.</span>webview<span class="token punctuation">.</span><span class="token function">currentWebview</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  window<span class="token punctuation">.</span>plus<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'backbutton'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    webview<span class="token punctuation">.</span><span class="token function">canBack</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>canBack<span class="token punctuation">)</span> <span class="token punctuation">{</span>        webview<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// webview.close(); //hide,quit</span>        <span class="token comment" spellcheck="true">// plus.runtime.quit();</span>        <span class="token comment" spellcheck="true">// 首页返回键处理</span>        <span class="token comment" spellcheck="true">// 处理逻辑：1秒内，连续两次按返回键，则退出应用；</span>        <span class="token keyword">var</span> first <span class="token operator">=</span> <span class="token keyword">null</span>        window<span class="token punctuation">.</span>plus<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'backbutton'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 首次按键，提示‘再按一次退出应用’</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span>            first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              first <span class="token operator">=</span> <span class="token keyword">null</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> first <span class="token operator">&lt;</span> <span class="token number">1500</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              window<span class="token punctuation">.</span>plus<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这个代码注入之后,我们还<strong><code>缺少一个mainfest.json文件</code></strong>,这个文件我们如何自己创建,里面过多内容根本不知道怎么如何测试!</p><p>我们直接新建一个<strong><code>5+App</code></strong>项目 然后,配置好app信息之后,直接将 unpackage(图标)/ mainfest.json(配置文件)</p><p>拷贝到黑马头条的<strong><code>public</code></strong>目录下, 打包完成之后 public目录就自动拥有该配置,然后我们打包 dist目录就可以了</p></blockquote><blockquote><p>最终一切结束, apk 安装到了模拟器或者手机 进行测试吧</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue部分相关的面试题</title>
      <link href="/2020/04/07/vue-xiang-guan-yi-nan/"/>
      <url>/2020/04/07/vue-xiang-guan-yi-nan/</url>
      
        <content type="html"><![CDATA[<div align="middle"> <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28892385&auto=1&height=66"></iframe></div># Vue部分相关的面试题<h2 id="如何在组件中监听Vuex的数据变化"><a href="#如何在组件中监听Vuex的数据变化" class="headerlink" title="如何在组件中监听Vuex的数据变化"></a>如何在组件中监听Vuex的数据变化</h2><blockquote><p>分析:   此题考查Vuex的应用及 Vue内部的监听数据变化的机制  </p></blockquote><blockquote><p><strong><code>解答</code></strong>:  首先确定 Vuex是为了解决什么问题而出现的 ?  Vuex是为了解决组件间状态共享而出现的一个框架.</p><p>其中有几个要素 是组成Vuex的关键,  state(状态)  mutations  actions  ,</p><p>state 表示 需要共享的状态数据</p><p>mutations  表示 更改 state的方法集合  只能是同步更新 不能写ajax等异步请求</p><p>actions  如果需要做异步请求  可以在actions中发起 然后提交给 mutations mutation再做同步更新</p></blockquote><p>也就是 state 负责管理状态 ,  mutation负责同步更新状态 action负责 异步获取数据 同提交给mutation</p><blockquote><p>所以 组件监听Vuex数据变化 就是 监听 Vuex中state的变化, </p></blockquote><p><strong><code>第一种方案</code></strong>  我们可以在组件中通过组件的 watch方法来做, 因为组件可以将state数据映射到 组件的计算属性上,</p><p>然后 监听 映射的计算属性即可 代码如下</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// vuex中的state数据</span>  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>    count<span class="token punctuation">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//  A组件中映射 state数据到计算属性</span>  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'count'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// A组件监听 count计算属性的变化</span>   watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>    count <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 用本身的数据进行一下计数</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>changeCount<span class="token operator">++</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20200217103409496.png" alt="image-20200217103409496"></p><p><strong><code>第二种方案</code></strong>   vuex中store对象本身提供了<strong><code>watch</code></strong>函数 ,可以利用该函数进行监听</p><ul><li><strong>watch(fn: Function, callback: Function, options?: Object): Function</strong></li></ul><p>响应式地侦听 <code>fn</code> 的返回值，当值改变时调用回调函数。<code>fn</code> 接收 store 的 state 作为第一个参数，其 getter 作为第二个参数。最后接收一个可选的对象参数表示 Vue 的 <a href="https://cn.vuejs.org/v2/api/#vm-watch" target="_blank" rel="noopener"><code>vm.$watch</code></a> 方法的参数。</p><p>代码</p><pre class="line-numbers language-js"><code class="language-js">  created <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> getters<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> state<span class="token punctuation">.</span>count    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>changeCount<span class="token operator">++</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>以上代码 均在示例有体现</p></blockquote><p>vue-cli项目 中router  </p><p>history模式  /地址  =&gt; 一定会引起向服务端发请求 ,需要服务器配合,需要服务器做配合, 无论地址怎么变化, 返回都是一个页面,这样页面就不会强制刷新, 开发时  用的脚手架本身支持, 如果上线, 需要ngix 服务器配置,单页应用 无论地址怎么变化 </p><p>hash模式    #/地址  =&gt; #的变化不会引起 页面的刷新</p><blockquote><p> 脚手架中 可能会频繁遇到环境变量</p></blockquote><p>dev环境    测试环境   预发布环境  生产环境 </p><p>每个环境的地址 和域名可能不一样,如果你的项目需要上线,  不需要手动的 根据环境 来切换参数</p><p>把一些需要根据环境变化的参数 变成环境变量, 运维会在不同的环境中将 不同的环境变量写入, 此时你的代码 编译之后就是带当时的环境变量的了</p><h2 id="Vue单页面和多页面的混合使用"><a href="#Vue单页面和多页面的混合使用" class="headerlink" title="Vue单页面和多页面的混合使用"></a>Vue单页面和多页面的混合使用</h2><blockquote><p>分析: 首先分析,单页面应用和 多页面应用的根本区别 </p><p><strong><code>解答</code></strong>:  单页面即所有的模块统统置于一个html文件之上,切换模块,不会重新对html文件和资源进行再次请求,服务器不会对我们<strong><code>换页面</code></strong>的动作 产生任何反应, 所以我们感觉不到任何的刷新动作,速度和体验很畅快</p><p>多页面应用 即多个html页面 共同的使用, 可以认为一个页面即一个模块,但是不排除 多个单页应用混合到一起的组合情况 ,  多页面切换一定会造成 页面资源的重新加载, 这也就意味着 如果 多页面之间切换,一定会造成很数据的<strong><code>重置</code></strong></p><p>​    所以在 Vue的单页面 和多页面混合使用的时候,需要注意, 如果 不论是单页  跳到多页 ,还是多页跳到单页,都会造成页面内容的重置. 多页面我们不用关心,因为重置本就是多页面的特性,但是单页不一样, 很多变量或者数据 可能会因为 重置归零或者重置,所以我们应该 重点检查 单页每个页面的业务 在刷新页面之后, 能否保证业务的连贯性,  这些都可以通过<strong><code>导航守卫</code></strong>来进行处理, 也就是一进入单页的路由,就检查业务的连贯性.</p></blockquote><h2 id="vuex怎么合理规范管理数据-及mutations和actions区别"><a href="#vuex怎么合理规范管理数据-及mutations和actions区别" class="headerlink" title="vuex怎么合理规范管理数据,及mutations和actions区别"></a>vuex怎么合理规范管理数据,及mutations和actions区别</h2><blockquote><p>解析: 此题考查 vuex中数据的管理和数据结构的设计,还有mutations 和actions的区别</p></blockquote><blockquote><p><strong><code>解答</code></strong> : 首先要明确一个特别重要的原则, 就是 不是所有的数据都要放在vuex中, 因为vuex有一句名言:假如你并不知道为什么要使用vuex,那就不要使用它 !</p><p> 那么什么样式的数据需要放在vuex中呢 ? 首先这个数据肯定要被多个组件频繁用到, 如果只是被一个组件 用到, 那完全没有任何必要为了使用vuex和使用vuex</p></blockquote><p>举例:  一个网站用户的昵称,账号,资料,像这种系统级别的信息 随时可能在业务中展示,使用, 如果在组件中存储, 那么要获取N次, 所以<strong><code>系统级别的数据</code></strong>是需要放置在vuex中的, 那么系统级别数据 也不能随意的放置,为了让数据看着更有层级结构感,可以按照像下面这样设计,  </p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    // 系统消息    system<span class="token operator">:</span> <span class="token punctuation">{</span>        user<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        setting<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上面这种结构,一看 便知道我们应该哪里获取系统数据即 设置数据</p></blockquote><p>如果有些业务数据,也需要共享,最好按照模块的具体业务含义分类 , 比如下面</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    // 系统消息    system<span class="token operator">:</span> <span class="token punctuation">{</span>        user<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        setting<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    product<span class="token operator">:</span> <span class="token punctuation">{</span>        productList<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> // 商品信息列表        productOrders<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> // 商品订单啊列表    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如上图代码所示,我们很清晰的能够分清楚 每个模块的数据,这样不会导致数据管理的混乱</p></blockquote><h3 id="mutations和-actions-的区别"><a href="#mutations和-actions-的区别" class="headerlink" title="mutations和 actions 的区别"></a>mutations和 actions 的区别</h3><blockquote><p>不同于redux只有一个action, vuex单独拎出了一个mutations,  它认为 更新数据必须是同步的, 也就是只要调用了 提交数据方法, 就会得到一个当前的<strong><code>状态快照</code></strong>,提交一个mutation就会得到一个<strong><code>快照</code></strong></p><p>那么如果我们想做 异步请求,怎么做?  这里 vuex提供了专门做异步请求的模块,action, 当然action中也可以做同步操作, 只不过 分工更加明确, 所有的数据操作 不论是同步还是异步 都可以在action中完成, </p><p>mutation只负责接收状态, 同步完成 <strong><code>数据快照</code></strong></p><p>所以可以认为 </p><p>state =&gt; 负责存储状态 </p><p>mutations =&gt; 负责同步更新状态</p><p>actions =&gt; 负责获取 处理数据, 提交到mutation进行状态更新</p></blockquote><h2 id="vuex模块化管理-使用的时候有注意事项"><a href="#vuex模块化管理-使用的时候有注意事项" class="headerlink" title="vuex模块化管理,使用的时候有注意事项"></a>vuex模块化管理,使用的时候有注意事项</h2><blockquote><p>分析: 此题考查 当vuex维护的数据越来越复杂的时候, 模块化的解决方案</p><p><strong><code>解析</code></strong>:使用单一的状态树，应用的所有状态都会<strong><code>集中在一个比较大的对象</code></strong>上面，随着项目需求的不断增加，状态树也会变得越来越臃肿，增加了状态树维护的复杂度,而且代码变得沉长；因此我们需要<strong><code>modules(模块化)</code></strong>来为我们的状态树<strong><code>分隔</code></strong>成不同的模块，每个模块拥有自己的state，getters，mutations，actions；而且允许每个module里面嵌套子module；如下：</p><pre><code> store    ├── index.js          # 我们组装模块并导出 store 的地方    ├── actions.js        # 根级别的 action    ├── mutations.js      # 根级别的 mutation    ├── state.js          # 根级别的 state    └── modules        ├── module1.js   # 模块1的state树        └── module2.js   # 模块2的state树</code></pre></blockquote><p>上面的设计中, 每个vuex子模块都可以定义 state/mutations/actions</p><blockquote><p>需要注意的是  我们原来使用<strong><code>vuex辅助函数</code></strong>  mapMutations/mapActions  引入的是 全局的的mutations 和actions , 并且我们vuex子模块  也就是module1,module2 … 这些模块的aciton /mutation 也注册了全局, </p><p>也就是如果 module1 中定义了 updateUser , module2中也定义了 updateUser, 此时, mutation就冲突了</p><p>如果重名,就报错了…..</p><p>如果不想冲突, 各个模块管理自己的action 和 mutation ,需要 给我们的子模块一个 属性 <strong><code>namespaced: true</code></strong></p></blockquote><p>那么 组件中怎么使用子模块的action 和 mutations</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文</span>methods <span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'updateUser'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 引用A模块的mptations方法 </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>此题具体考查 Vuex虽然是一个公共状态, 但是公共状态还可以切分成若干个子状态模块, 也就是moudels,</p><p>解决当我们的状态树过于庞大和复杂时的一种解决方案.  但是笔者认为, 一旦用了vuex, 几乎 就认定该项目是较为复杂的</p></blockquote><p><a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener">参考文档</a></p><h2 id="封装Vue组件的步骤"><a href="#封装Vue组件的步骤" class="headerlink" title="封装Vue组件的步骤"></a>封装Vue组件的步骤</h2><blockquote><p>分析: 本题考查 对于Vue组件化开发的熟练程度</p><p><strong><code>解析</code></strong>: 首先明确 组件是本质是什么?  </p><p>组件就是一个单位的HTML结构 + 数据逻辑 + 样式的 操作单元 </p><p>Vue的组件 继承自Vue对象, Vue对象中的所有的属性和方法,组件可自动继承. </p><p>组件的要素  template  =&gt;  作为页面的模板结构 </p><p>script  =&gt; 作为数据及逻辑的部分</p><p>style  =&gt; 作为该组件部分的样式部分</p></blockquote><p>要封装一个组件,首先要明确该组件要做的具体业务和需求,  什么样的体验特征, 完成什么样的交互, 处理什么样的数据</p><blockquote><p>明确上述要求之后, 着手模板的结构设计及搭建,也就是 常说的html结构部分,  先完成 静态的html结构</p><p>结构完成, 着手数据结构的设计及开发, 数据结构一般存储于组件的data属性 或者 vuex 状态共享的数据结构</p><p>数据设计完成/ 结构完成  接下来 完成数据和模块的结合 , 利用vuejs中指令和 插值表达式的特性 将静态结构 <strong><code>动态化</code></strong></p><p>展现的部分完成, 接下来完成<strong><code>交互部分</code></strong>,即利用 组件的生命周期的钩子函数 和 事件驱动 来完成 逻辑及数据的处理与操作</p></blockquote><p>最后组件完成,进行测试及使用</p><p>常用的组件属性 =&gt; data/ methods/filters/ components/watch/created/mounted/beforeDestroy/computed/props</p><p>常用组件指令: v-if/v-on/v-bind/v-model/v-text/v-once</p><h2 id="Vue中的data是以函数的形式还是对象的形式表示"><a href="#Vue中的data是以函数的形式还是对象的形式表示" class="headerlink" title="Vue中的data是以函数的形式还是对象的形式表示"></a>Vue中的data是以函数的形式还是对象的形式表示</h2><blockquote><p>分析: 此题考查 data的存在形式</p></blockquote><blockquote><p><strong><code>解析</code></strong>: 我们在初步学习Vue实例化的时候写的代码时这个样子</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>        name<span class="token punctuation">:</span> <span class="token string">'hello world'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中的data 是一个对象, 但是我们在开发组件的时候要求data必须是一个带返回值的函数</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'张三'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>为什么组件要求必须是带返回值的函数?  因为 我们的组件在实例化的时候, 会直接将data数据作用在视图上, </p><p>对组件实例化, 会导致我们组件的data数据进行共享, 好比  现在有两辆新车, 你一踩油门, 不光你的车往前走,另辆车也和你一样往前冲!   这显然不符合我们的程序设计要求, 我们希望组件内部的数据是相互独立的,且互不响应,所以 采用   <strong><code>return {}</code></strong>  每个组件实例都返回新对象实例的形式,保证每个组件实例的唯一性</p></blockquote><h2 id="使用Proxy代理跨域"><a href="#使用Proxy代理跨域" class="headerlink" title="使用Proxy代理跨域"></a>使用Proxy代理跨域</h2><blockquote><p>分析: 本题考查如何解决跨域问题</p><p>解析: 解决跨域问题的方式有几种,一种是服务端设置 all-control-origin * , 但这种方式依赖服务端的设置,在前后分离的场景下 ,不太方便</p><p>还有一种jsonp形式, 可以利用script标签 的特性解决同源策略带来的跨域问题,但这是这种方案对于请求的类型有限制,只能get/post</p><p>还有一种就可以在开发环境(本地调试)期间,进行代理, 说白了 就是通过 在本地通过nodejs 启动一个微型服务, </p><p>然后我们先请求我们的微型服务, 微型服务是服务端, 服务端<strong><code>代我们</code></strong>去请求我们想要的跨域地址, 因为服务端是不受<strong><code>同源策略</code></strong>的限制的, 具体到开发中,打包工具webpack集成了代理的功能,可以采用配置webpack的方式进行解决, 但是这种仅限于 本地开发期间, 等项目上线时,还是需要另择代理 ngix</p></blockquote><p>以下为webpack配置代理的配置 </p><pre class="line-numbers language-json"><code class="language-json"> // 代理设置 proxy<span class="token operator">:</span> <span class="token punctuation">{</span>    '/api'<span class="token operator">:</span> <span class="token punctuation">{</span>        target<span class="token operator">:</span> 'http<span class="token operator">:</span>//www.baidu.com/'<span class="token punctuation">,</span>        changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        pathRewrite<span class="token operator">:</span> <span class="token punctuation">{</span>            '^/api'<span class="token operator">:</span> ''        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>target</code></strong>：接口域名；</p><p> <strong><code>changeOrigin</code></strong>： 如果设置为<code>true</code>,那么本地会虚拟一个服务端接收你的请求并代你发送该请求；</p><p> <strong><code>pathRewrite</code></strong>：如果接口中是没有api的，那就直接置空（如上）如果接口中有api，就需要写成{‘^/api’:‘/api’}</p><p>真实访问地址  <a href="http://www.baidu.com/test" target="_blank" rel="noopener">http://www.baidu.com/test</a> </p><p>/api/test  =&gt;  /api 就是 表示  <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>  =&gt;webpack 后台 发出的请求(<a href="http://www.baidu.com/test" target="_blank" rel="noopener">http://www.baidu.com/test</a> )=&gt;  返回结果  =&gt; 前端</p><p>反向代理  =&gt;   前端   =&gt; 后台 不让你访问 (跨域)</p><p>   前端 =&gt; webpack后台 (代理)(仅限于本地开发模式)     =&gt;后台</p><h2 id="Vue中的watch如何深度监听某个对象"><a href="#Vue中的watch如何深度监听某个对象" class="headerlink" title="Vue中的watch如何深度监听某个对象"></a>Vue中的watch如何深度监听某个对象</h2><blockquote><p>分析: 此题考查Vue的选项watch的应用方式</p><p>解析:  watch最基本的用法是 </p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'张三'</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>        name <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中: 有个原则监听谁,写谁的名字,然后是对应的执行函数, 第一个参数为最新的改变值,第二个值为上一次改变的值, 注意: 除了监听 data,也可以监听<strong><code>计算属性</code></strong> 或者一个 函数的计算结果</p><p>那怎么深度监听对象 ,两种方式</p><ol><li>字符串嵌套方式</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>           a<span class="token punctuation">:</span> <span class="token punctuation">{</span>               b<span class="token punctuation">:</span> <span class="token punctuation">{</span>                   c <span class="token punctuation">:</span><span class="token string">'张三'</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token string">"a.b.c"</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p>启用深度监听方式</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>    data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>           a<span class="token punctuation">:</span> <span class="token punctuation">{</span>               b<span class="token punctuation">:</span> <span class="token punctuation">{</span>                   c <span class="token punctuation">:</span><span class="token string">'张三'</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>        a<span class="token punctuation">:</span> <span class="token punctuation">{</span>            deep<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// deep 为true  意味着开启了深度监听 a对象里面任何数据变化都会触发handler函数,</span>            <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// handler是一个固定写法</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></blockquote><h2 id="Vue-keep-alive使用"><a href="#Vue-keep-alive使用" class="headerlink" title="Vue keep-alive使用"></a>Vue keep-alive使用</h2><blockquote><p>分析: 此题考查Vue中组件缓存的使用 </p><p>解析:  keep-alive是 Vue提供的一个全局组件, Vue的组件是有销毁机制的,比如条件渲染, 路由跳转时 组件都会经历<strong><code>销毁</code></strong>, 再次回到页面时,又会回到 <strong><code>重生</code></strong>, 这一过程保证了生命周期钩子函数各个过程都会在这一生命周期中执行.</p><p>但是,我们辛辛苦苦获取的数据 滑动的页面 会因为组件的销毁 重生 而 <strong><code>归零</code></strong>,这影响了交互的体验, 所以 keep-alvie出现了, 可以帮助我们缓存想要缓存的组件实例, 只用用keep-alive <strong><code>包裹</code></strong>你想要缓存的组件实例, 这个时候, 组件创建之后,就不会再进行 销毁, 组件数据和状态得以保存</p><p>但是,没有了销毁,也就失去了重生的环节, 我们失去了 原有的钩子函数, 所以keep-alive包裹的组件 都获取了另外两个事件 </p><p>唤醒 activited 重新唤醒休眠组件实例时 执行</p><p>休眠 unactiived  组件实例进入休眠状态时执行</p></blockquote><p>但是我们不能缓存所有的组件实例, 如果是针对 组件容器 router-view 这个组件进行的缓存, 一般的策略是在路由的元信息 meta对象中设置是否缓存的标记,  然后根据标记决定是否进行缓存</p><pre class="line-numbers language-js"><code class="language-js">  <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 里面是当需要缓存时 <span class="token operator">--</span><span class="token operator">></span>      <span class="token operator">&lt;</span>router<span class="token operator">-</span>view  v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"$route.meta.isAlive"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">></span>     <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 外面是不需要缓存时 <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>router<span class="token operator">-</span>view  v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"!$route.meta.isAlive"</span> <span class="token operator">/</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有需要注意的问题是:  被缓存的组件中如果还有子组件, 那么子组件也会一并拥有 激活和唤醒事件,并且这些事件会在同时执行</p><h2 id="vue的双向数据绑定原理是什么"><a href="#vue的双向数据绑定原理是什么" class="headerlink" title="vue的双向数据绑定原理是什么"></a>vue的双向数据绑定原理是什么</h2><blockquote><p>分析 :此题考查 Vue的MVVM原理</p><p><strong><code>解答</code></strong>:  Vue的双向绑定原理其实就是MVVM的实现原理, Vuejs官网已经说明, 实际就是通过 Object.defineProperty方法 完成了对于Vue实例中数据的 <strong><code>劫持</code></strong>, 通过对于 data中数据 set的监听,</p><p>然后通过<strong><code>观察者模式</code></strong>, 通知 对应的绑定节点 进行节点数据更新, 完成数据驱动视图的更新</p></blockquote><p>我们实现的MVVM是一个简易版本</p><p>我们并没有做虚拟DOM, 虚拟DOM的问题</p><p>虚拟DOM,并不是真正的DOM, 数据驱动视图, 数据变化  =&gt;  数据 切换成 虚拟DOM, </p><p>新的虚拟DOM 会和 旧的虚拟DOM 进行 diff比较算法, 比较 得出 需要更新的结果, 反映到dom上</p><p>diff比较 =&gt;  其实就是 用一种时间时间复杂度比较低的方式去更新</p><p>新节点    和 旧节点 完成 比较 ,时间复杂度 O(n^n^n), </p><p>diff 比较算法 时间复杂度 是 O(n)  =&gt;   diff 比较算法 只比较同级的节点, 如果同级节点不一致, 就不再比较子级了,</p><p>性能比较高的算法.</p><blockquote><p><a href="https://www.jianshu.com/p/af0b398602bc" target="_blank" rel="noopener">虚拟dom和diff比较</a>    此问题 仅仅存于面试</p></blockquote><p>Vue/React  不推荐 移动节点, 不推荐改变节点的名称, </p><p>旧节点</p><blockquote><p>同理, 通过对于节点的表单值改变事件的监听,  执行对于数据的修改</p></blockquote><p>简单概述 : 通过Object.defineProperty 完成对于数据的劫持, 通过观察者模式, 完成对于节点的数据更新</p><h2 id="页面刷新了之后vuex中的数据消失怎么解决"><a href="#页面刷新了之后vuex中的数据消失怎么解决" class="headerlink" title="页面刷新了之后vuex中的数据消失怎么解决"></a>页面刷新了之后vuex中的数据消失怎么解决</h2><blockquote><p>分析:此题考查 如果将vuex数据进行本地持久化</p><p><strong><code>解析</code></strong>: vuex数据位于内存, 页面的刷新重置会导致数据的<strong><code>归零</code></strong>,也就是所谓的消失,  本地持久化可以解决这个问题.本地持久化用到的技术也就是 本次存储 sesstionStorage 或者 localStorage ,  </p><p>如果需要保持的更长久 ,浏览器关掉 再打开依然存有数据,需要使用后者 </p><p>实施方案:  state的持久化 也就是分别需要在 state数据初始化 /更新 的时候 进行读取和设置本地存储操作</p><p>代码如下 </p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>   state<span class="token punctuation">:</span> <span class="token punctuation">{</span>       user<span class="token punctuation">:</span> localStorge<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 初始化时读取 本地存储</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>   mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>       updateUser <span class="token punctuation">(</span>state<span class="token punctuation">,</span> payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>           state<span class="token punctuation">.</span>user <span class="token operator">=</span> payload<span class="token punctuation">.</span>user           localStoregae<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">,</span>payload<span class="token punctuation">.</span>user<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 数据更新时 设置本地存储</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="vue做服务端渲染"><a href="#vue做服务端渲染" class="headerlink" title="vue做服务端渲染"></a>vue做服务端渲染</h2><blockquote><p>分析: 为什么要做服务端渲染, 首先要明白 服务端渲染解决什么问题</p><p><strong><code>解析</code></strong>: vuejs 官网说的很明白, 要做服务端渲染首先必须是有对应的需求,即对 实时到达时间(页面访问时间)的绝对需求.  如果只是简单的一个管理系统, 区区几百毫秒的优化 显得十分小题大做.</p><p>服务端渲染这里 有一个成熟优秀的框架 nuxt.js , 正如next.js对于react,nuxt是vue服务端渲染的优秀解决方案</p></blockquote><p>我们几乎可以像原来一样的去开发组件,页面, nuxt帮我们集成了原有项目的插件,模块, 提供了预加载数据事件</p><p>asyncData, 在客户端实现对于服务端内容的<strong><code>完美接管</code></strong></p><p>只不过 这里我们的路由开发方式,需要遵循nuxt.js制定的特殊规范,比如,动态 路由需要 <strong><code>下划线前缀</code></strong>, 嵌套路由需要</p><p>同名组件的文件下下建立组件,并在 同名组件中 加入 nuxt-child 作为 容器  ….</p><blockquote><p>nuxt的出现可以让渲染内容完全服务端化,解决seo不够友好, 首屏渲染速度不够迅速的问题,</p><p>但是这里需要注意: 并不是所有页面都需要服务端渲染, 因为服务端渲染比重多大 对于服务器的访问处理能力 要求也会急剧增大</p></blockquote><p><a href="https://zh.nuxtjs.org/" target="_blank" rel="noopener">nuxt.js官网</a></p><h2 id="双向数据绑定和vuex冲突解决方案"><a href="#双向数据绑定和vuex冲突解决方案" class="headerlink" title="双向数据绑定和vuex冲突解决方案"></a>双向数据绑定和vuex冲突解决方案</h2><blockquote><p>分析: 此题考查 当Vuex数据想要进行逆向操作,也就是 双向数据流向的解决方案</p><p><strong><code>解析</code></strong>:   vuex的数据对于组件来说,默认是不可改的, 但是如果我们就是想改, 可以利用 computed计算属性的另一个方法 , 我们知道计算属性 默认是数据的getter实现, 但是我们可以采用 对于 计算属性 同时get/set的实现,</p><p>双向数据流 中 当对 计算属性设置时 ,就可以通过 store对象进行再次的mutations提交 </p><p>具体代码如下</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>state<span class="token punctuation">:</span> <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token string">''</span> <span class="token comment" spellcheck="true">// 定义value数据 作为vuex状态数据</span><span class="token punctuation">}</span><span class="token punctuation">,</span>mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span> addCount <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>   state<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 定义mutations方法 作为 提交mutations的方法</span> updateValue <span class="token punctuation">(</span>state<span class="token punctuation">,</span> payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>   state<span class="token punctuation">.</span>value <span class="token operator">=</span> payload<span class="token punctuation">.</span>value <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span>actions<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>modules<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-vue"><code class="language-vue"><template><div>   <div>vuex的双向数据流</div>   <input type="text" v-model="value">   <div>Vuex数据属性: {{value }}</div></div></template><script>import { mapMutations } from 'vuex'export default {methods: { ...mapMutations(['updateValue'])},    // 计算属性的get/setcomputed: { value: {   get () {       // 获取state公共数据     return this.$store.state.value   },    // 通过对 计算属性的set监听 将 数据提交mutations     // 当input中数据变化时 就会调用set中的方法  value就是最新值   set (value) {     this.updateValue({ value: value })  // 在set中提交mutations   } }}}</script><style></style><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="vue-router传参"><a href="#vue-router传参" class="headerlink" title="vue-router传参"></a>vue-router传参</h2><blockquote><p>分析:考查vue-router的传值方式</p><p><strong><code>解析</code></strong>  vue-router 传值 可以通过 地址传值</p><p>最简单的就是url传值, url传值又两种, params 和 query参数传值</p><p>params传值 是指的动态路由传值 </p><pre class="line-numbers language-vue"><code class="language-vue">{  path: '/user/:id' }  // 定义一个路由参数<router-link to="/user/123"></router-link>  // 传值this.$route.params.id   // 取值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>query传值,指通过?后面的拼接参数传值</p><pre class="line-numbers language-vue"><code class="language-vue"><router-link to="/user?id=123"></router-link>  // 传值this.$route.query.id   // 取值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="前端鉴权一般思路"><a href="#前端鉴权一般思路" class="headerlink" title="前端鉴权一般思路"></a>前端鉴权一般思路</h2><blockquote><p>分析: 考查前后分离的鉴权思路</p></blockquote><p><strong><code>解析</code></strong>: 首先要明白 为什么要在前端鉴权? 因为传统项目都是在后端鉴权, 然后通过进行拦截 跳转 对应操作</p><p>因为 我们做的并不是传统的项目,而是前后分离项目,也就是前端项目和后端服务进行了<strong><code>剥离</code></strong>, 后端没有办法用session来存储你任意一个前端项目域名下的身份信息, 所以jwt 鉴权模式应运而生. </p><p>​    也就是后端不再提供会话的身份存储,而是通过一个鉴权接口将用户的身份,登录时间,请求端口,协议头..等等信息 组装成一个加密的串 返给前端请求,  前端拿到了这个串,就可以认为自己登录成功</p><p>那么这个<strong><code>加密串</code></strong>就成了 前端用户是否登录的成功标志, 这就是我们的token , 那么在接下来的接口请求中,我们几乎都要携带这个加密串,因为它是<strong><code>唯一</code></strong>能<strong><code>证明我们身份</code></strong>的信息.</p><p>为了方便,我们会一般在请求工具 axios(举例)的拦截器中<strong><code>统一注入token</code></strong>, 减少代码的重复</p><p>token 同时具有时效性,我们也需要在此时对token过期进行处理,一旦出现过期的请求码, 就需要进行 换取新token 或者重新登录的解决方案</p><p>除此之外,我们还需要依据<strong><code>有无加密串</code></strong> 在前端对于某些页面的访问进行限制, 这个会用到我们的Vue-Router中的导航守卫.</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务端渲染</title>
      <link href="/2020/04/07/vue-jin-jie-vue-de-fu-wu-duan-xuan-ran-ssr/"/>
      <url>/2020/04/07/vue-jin-jie-vue-de-fu-wu-duan-xuan-ran-ssr/</url>
      
        <content type="html"><![CDATA[<h2 id="CSR演示和特点-客户端渲染"><a href="#CSR演示和特点-客户端渲染" class="headerlink" title="CSR演示和特点 - 客户端渲染"></a>CSR演示和特点 - 客户端渲染</h2><blockquote><p>什么是CSR ?  同学们:其实这种类似字母的堆积都是 单词的缩写拼接</p></blockquote><p><strong><code>Client Side Render</code></strong> , 也就是在客户端渲染,我们请求的Html页面中并没有核心内容,而是需要下载执行 js 文件，由浏览器动态生成页面，并通过 JS 进行页面交互事件与状态管理</p><p>简单一句话 : <strong><code>页面的主体结构是请求完js,由js完成的渲染</code></strong></p><blockquote><p>客户端渲染的优势是什么?</p></blockquote><p> 适合前后端分离开发，方便维护，单页应用中几乎都是客户端渲染,像我们的黑马头条 都是客户端渲染</p><blockquote><p>缺点呢? 难道没缺点?</p></blockquote><p><strong><code>首次加载慢</code>，<code>不利于 SEO</code></strong> , 因为我们的大部分动态结构 都是在客户端渲染的,后端返回的只是一个空的div,</p><p>因为首次加载需要先把js加载完毕,然后才能去渲染</p><p>SEO =&gt; 搜索引擎优化 =&gt; H5页面 =&gt; 百度/头条 =&gt; 爬虫爬取网页的结构./关键词/语义化标签</p><blockquote><p>上述的效果可通过查看 黑马头条的网页元素进行验证</p><p><img src="image-20200402095640332.png" alt="image-20200402095640332"></p></blockquote><h2 id="SSR渲染的演示和特点-服务端渲染"><a href="#SSR渲染的演示和特点-服务端渲染" class="headerlink" title="SSR渲染的演示和特点-服务端渲染"></a>SSR渲染的演示和特点-服务端渲染</h2><blockquote><p>什么是SSR ? 和 CSR一个字之差! SSR其实就是 把Client换成了Server, 客户端渲染变成了服务端渲染</p></blockquote><p><strong><code>Server Side Render</code></strong> (服务端渲染 <strong>SSR</strong>)：服务器直接<strong><code>生成 HTML 文档结构</code></strong> 返回给浏览器，但页面交互能力有限。适合于任何后端语言：PHP、Java、Python、Go, ASP 等。aspx =&gt; 很多服务器标签</p><p>JSP  =&gt; 服务端渲染 =&gt;  服务端标签 =&gt; 完成数据的替换 =&gt; html =&gt;  浏览器</p><p>ASP =&gt; 服务端渲染 =&gt; 服务端标签  =&gt; 完成数据的替换 =&gt; html =&gt;  浏览器</p><p>服务端渲染速度更快, 因为直接返回了文档结构,立刻能看到文档效果</p><p>相当于 在服务端完成了页面的结构的生成 =&gt; 返回生成好的页面结构 =&gt;不需要js请求完毕就有内容</p><blockquote><p>服务端渲染 的优势是什么?</p></blockquote><p>响应速度快(首屏渲染速度快)，有利于 SEO, 不需要等待js, 就好像你访问的是静态页面一样</p><blockquote><p>劣势 ?</p></blockquote><ul><li>前后端代码混合在一起，难以开发和维护，不适合进行前后端分离开发</li></ul><p>前后一体 =&gt;  前后分离 =&gt; 服务端渲染  =&gt;     中间件(只做服务端渲染)  =&gt;  服务端(主)</p><blockquote><p>服务端页面返回的内容直接是Html文档结构,不用等到下载完js,再通过js去渲染</p><p><img src="image-20200402095657205.png" alt="image-20200402095657205"></p></blockquote><h2 id="Vue的SSR介绍及示例演示"><a href="#Vue的SSR介绍及示例演示" class="headerlink" title="Vue的SSR介绍及示例演示"></a>Vue的SSR介绍及示例演示</h2><blockquote><p>Vue的SSR(服务端渲染)是什么?</p></blockquote><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为<strong><code>服务器端的 HTML 字符串</code></strong>，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p><p><a href="https://ssr.vuejs.org/zh/" target="_blank" rel="noopener">Vue的SSR文档</a> </p><p><strong><code>Vue的SSR代码既包含客户端部分,又包含服务端部分</code></strong> </p><p>基于react、vue框架，客户端渲染和服务器端渲染的结合，在服务器端执行一次，用于实现服务器端渲染（首屏直出），在客户端再执行一次，用于<strong><code>接管页面交互</code></strong>，核心解决SEO和首屏渲染慢的问题。</p><blockquote><p>上面这段话的意思是, 在服务端 生成页面结构, 页面结构返回给了客户端浏览器, 然后下载运行js, js同样也会执行,但是并不会再次执行渲染,而是直接接管了页面的交互, 比如点击事件.业务操作</p></blockquote><p>接下来,我们运行一个官方的小例子看看效果</p><blockquote><p>首先,我们需要新建一个文件夹  ssrDemo, 并在该目录下初始化 npm</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> init -y <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>然后,我们来安装 Vue 和 Vue 服务端渲染包</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span>  <span class="token function">install</span> vue vue-server-renderer --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>然后 在该目录下 新建一个 app.js,内容如下</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 第 1 步：创建一个 Vue 实例</span><span class="token keyword">const</span> Vue <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue'</span><span class="token punctuation">)</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`&lt;div>Hello World&lt;/div>`</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 第 2 步：创建一个 renderer</span><span class="token keyword">const</span> renderer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue-server-renderer'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 第 3 步：将 Vue 实例渲染为 HTML renderToString 返回一个promise</span>renderer<span class="token punctuation">.</span><span class="token function">renderToString</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>html <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>我们可以直接用命令执行 看看能输出什么内容</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ node app<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20200213222737986.png" alt="image-20200213222737986"></p><blockquote><p>试着写一些动态内容</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> Vue  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//  为什么不能用import  因为这里是后端代码</span><span class="token keyword">const</span>  render  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue-server-renderer'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 服务端渲染包 此模板 可以获取vue实例的html内容</span><span class="token keyword">const</span> SSR <span class="token operator">=</span> render<span class="token punctuation">.</span><span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 创建一个 服务端渲染实例化对象  </span><span class="token comment" spellcheck="true">// 第一步 创建一个vue实例</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`&lt;div>Hello world :{{  name }}&lt;/div>`</span></span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>        name<span class="token punctuation">:</span> <span class="token string">'程序猿'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 第二步 对vue实例进行 渲染 得到其html结构</span>SSR<span class="token punctuation">.</span><span class="token function">renderToString</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>html <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 得到渲染的结构</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"得到服务端渲染的结构是:"</span> <span class="token operator">+</span> html<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 将组件或者vue实例化 转化成字符串</span><span class="token comment" spellcheck="true">// 我们要将这个结果 返回浏览器  浏览器直接显示这个结构  这就是服务端渲染</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20200213222907433.png" alt="image-20200213222907433"></p><blockquote><p>我们发现代码动态数据直接渲染成了真正的字符串</p></blockquote><p>OK, 既然可以生成最终的页面字符串, 我们可以和express进行结合,写一个最终版的服务端渲染示例</p><blockquote><p>首先安装express</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span>  i express<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>然后新建 server.js , 将 app.js  的数据进行返回</p></blockquote><p>首先,将app.js的内容导出</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">const</span> Vue  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//  为什么不能用import  因为这里是后端代码</span><span class="token keyword">const</span>  render  <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue-server-renderer'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 服务端渲染包 此模板 可以获取vue实例的html内容</span><span class="token keyword">const</span> SSR <span class="token operator">=</span> render<span class="token punctuation">.</span><span class="token function">createRenderer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 创建一个 服务端渲染实例化对象  </span><span class="token comment" spellcheck="true">// 第一步 创建一个vue实例</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`&lt;div>Hello world :{{  name }}&lt;/div>`</span></span><span class="token punctuation">,</span>    data<span class="token punctuation">:</span> <span class="token punctuation">{</span>        name<span class="token punctuation">:</span> <span class="token string">'程序猿'</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// // 第二步 对vue实例进行 渲染 得到其html结构</span><span class="token comment" spellcheck="true">// SSR.renderToString(app).then(html => {</span><span class="token comment" spellcheck="true">//     // 得到渲染的结构</span><span class="token comment" spellcheck="true">//     console.log("得到服务端渲染的结构是:" + html)</span><span class="token comment" spellcheck="true">// }) // 将组件或者vue实例化 转化成字符串</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> SSR<span class="token punctuation">.</span><span class="token function">renderToString</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 直接导出 promise对象</span><span class="token comment" spellcheck="true">// 我们要将这个结果 返回浏览器  浏览器直接显示这个结构  这就是服务端渲染</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后,在server.js 中通过express 开启服务端口监视,并将导出的模板字符串 进行返回,代码如下</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> server <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 实例化web服务</span><span class="token keyword">var</span> app <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./app'</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//  当请求地址是/ 进行处理</span>    app<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>html <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        response<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`        &lt;!DOCTYPE html>&lt;html lang="en">&lt;head>    &lt;meta charset="UTF-8">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">    &lt;title>大家好,老高的课结束在即&lt;/title>&lt;/head>&lt;body>     </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>html<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&lt;/body>&lt;/html>`</span></span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 需要把动态渲染的内容直接返回</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">10086</span><span class="token punctuation">,</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"您的web服务启动了,访问地址 http://localhost:10086/"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OK了, 访问对应的地址 ,通过审查元素,我们发现返回的页面直接是已经组装好的页面结构,</p><p>同志们! 这就是<strong><code>纯服务端渲染</code></strong></p><h2 id="Nuxt介绍"><a href="#Nuxt介绍" class="headerlink" title="Nuxt介绍"></a>Nuxt介绍</h2><blockquote><p>上个小节中,我们的服务端内容觉得还好啊,不难啊,挺好用啊 , <strong><code>But</code></strong>!真实的案例往往超乎你的想象,</p><p>我们并不可能只返回一个字符串,然后没有任何交互, 交互只能在客户端做啊!</p></blockquote><p>服务端渲染=&gt; 解决首屏渲染问题,SEO不够友好</p><p>怎么办? 我们并不是只有服务端内容, 不能为了解决这个问题,把交互给丢了</p><blockquote><p>所以在既有服务端,又有客户端的情况下,我们的代码好像并不能用了</p><p>此时 带来第三方基于Vue的服务端渲染框架Nuxt</p></blockquote><p>需要大家注意的是:</p><p><a href="https://zh.nuxtjs.org/guide" target="_blank" rel="noopener">说明</a> </p><ol><li>Nuxt<strong><code>不是</code></strong>Vue官方提供的</li><li>Nuxt是<strong><code>基于Vue</code></strong>的服务端渲染的框架</li><li>Nuxt.js 预设了利用 Vue.js 开发<strong><code>服务端渲染</code></strong>的应用所需要的各种配置。</li></ol><blockquote><p>nuxt有什么作用?</p></blockquote><p>基于 Vue、Webpack 和 Babel Nuxt.js 集成了以下组件/框架，用于开发完整而强大的 Web 应用：</p><ol><li><a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">Vue 2</a></li><li><a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener">Vue-Router</a></li><li><a href="https://github.com/vuejs/vuex" target="_blank" rel="noopener">Vuex</a> (当配置了 <a href="https://zh.nuxtjs.org/guide/vuex-store" target="_blank" rel="noopener">Vuex 状态树配置项</a> 时才会引入)</li><li><a href="https://ssr.vuejs.org/en/" target="_blank" rel="noopener">Vue 服务器端渲染</a> (排除使用 <a href="https://zh.nuxtjs.org/api/configuration-mode" target="_blank" rel="noopener"><code>mode: &#39;spa&#39;</code></a>)</li><li><a href="https://github.com/nuxt/vue-meta" target="_blank" rel="noopener">Vue-Meta</a></li></ol><blockquote><p>看到了没? </p></blockquote><p>vue-cli 是 vuejs 官方的脚手架, 用来开发纯前端项目,不负责服务端渲染</p><p>nuxt脚手架 是 第三方团队推出的, 和vue-cli 半毛钱关系没有</p><p>Nuxt里面拥有我们开发纯前端项目的一切配置,用于开发完整强大的web应用</p><p>我们用了nuxt,我们的项目就不再是一个纯前端项目了, 而是一个包含<strong><code>服务端渲染</code></strong>的前后端项目</p><p>服务端 + 客户端  =&gt; nuxt项目 ,并不会丢弃我们原来的前端内容</p><p>只不过 <strong><code>把每个组件的首屏渲染放在了 服务端 而不是客户端</code></strong></p><h2 id="Nuxt创建项目"><a href="#Nuxt创建项目" class="headerlink" title="Nuxt创建项目"></a>Nuxt创建项目</h2><blockquote><p>说了这么半天, Nuxt怎么用, 我们怎么用它开发项目?</p></blockquote><p>来做个例子看看吧</p><blockquote><p>首先我们来新建个文件夹  nuxtDemo  初始化 npm</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> init -y <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>然后在package.json中配置 一个 调试启动命令,启动命令是nuxt</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token punctuation">{</span>  <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"nuxtDemo"</span><span class="token punctuation">,</span>  <span class="token string">"version"</span><span class="token punctuation">:</span> <span class="token string">"1.0.0"</span><span class="token punctuation">,</span>  <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span>  <span class="token string">"main"</span><span class="token punctuation">:</span> <span class="token string">"index.js"</span><span class="token punctuation">,</span>  <span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>     <span class="token string">"dev"</span><span class="token punctuation">:</span> <span class="token string">"nuxt"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token string">"keywords"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"author"</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span>  <span class="token string">"license"</span><span class="token punctuation">:</span> <span class="token string">"ISC"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>安装 nuxt依赖包,这是 服务端渲染的关键</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> i nuxt --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在根目录下 新建 <strong><code>pages</code></strong>, 特别注意: 这里 只能叫<strong><code>pages</code></strong>,不能起别的名字</p></blockquote><p>在 pages新建一个组件 home.vue,内容如下</p><pre class="line-numbers language-vue"><code class="language-vue"><template>  <div class='app'>      <div class="header">水若寒宇</div>      <div class="body">           <div class='item' v-for="item in 30" :key="item">               <span>刘备</span>               <span>{{ new Date().toDateString() }}</span>           </div>      </div>  </div></template><script>export default {}</script><style>  .header {         height: 50px;         background-color: aquamarine;         text-align: center;         font-size: 20px;         line-height: 50px;  }.item {     display: flex;    justify-content: space-between;    padding: 0px 10px;    height: 40px;    line-height: 40px;   }    span:nth-child(2) {        font-size: 14px;        color:#ccc;}</style><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>组件建立好之后, 运行nuxt项目</p></blockquote><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> run dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>项目启动成功,我们访问对应的端口,一个nuxt的项目被创建好了</p><blockquote><p>我们会发现,在项目中多了一个.nuxt文件夹, 这个文件夹 是  编译客户端和服务端代码的结果</p></blockquote><p>我们pages下的home组件会自动帮我们生成 对应的路由的下的组件, </p><p>而且pages新建组件 也会完成路由的新建和自动重启</p><blockquote><p>以后百分之九十 还是 Vue的spa项目</p><p>vue-cli 做的前后分离项目  =&gt; 纯客户端渲染</p><p>Nuxt并不是官方的   =&gt; 解决首屏渲染慢的问题 =&gt; 一般只会做一个页面</p><p>双11 =&gt; 大流量访问页面的时候 =&gt; 首页做成服务端渲染项目</p></blockquote><p>一般来讲,服务端渲染只需要做首页</p><h2 id="Nuxt路由的动态路由"><a href="#Nuxt路由的动态路由" class="headerlink" title="Nuxt路由的动态路由"></a>Nuxt路由的动态路由</h2><blockquote><p>Nuxt会帮我们生成对应的路由,但是 我们之前学过 动态路由怎么办</p></blockquote><ul><li>动态路由</li></ul><blockquote><p>原来在 单页spa项目中,我们需要给 路由规则一个 参数  { path: ‘/user/:id’  }, </p><p>然后传递一个 通过 /user/123 来传递参数</p></blockquote><p>在nuxt中怎么实现呢 </p><p>nuxt项目中 标签跳转, 直接用nuxt-link标签, 相当于原来的router-link</p><pre class="line-numbers language-vue"><code class="language-vue"><nuxt-link to="/home">主页</nuxt-link><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>nuxt-link标签只能在nuxt项目中使用,不能在原来的vue-cli项目中使用</p><p> <a href="https://zh.nuxtjs.org/guide/routing" target="_blank" rel="noopener">Nuxt路由</a></p><p>在 Nuxt.js 里面定义带参数的动态路由，需要创建对应的<strong><code>以下划线作为前缀</code></strong>的 Vue 文件 或 目录。</p><blockquote><p>假如你想 实现  /users/:id 的动态路由,你需要建立一个users文件夹, 然后 在该文件夹下</p><p>创建一个以下划线为前缀的文件 _id.vue</p></blockquote><p>以下目录结构：</p><pre><code>pages/--| users/-----| _id.vue</code></pre><p>Nuxt.js 生成对应的路由配置表为：</p><pre><code>router: {  routes: [    {      name: &#39;users-id&#39;,      path: &#39;/users/:id?&#39;,      component: &#39;pages/users/_id.vue&#39;    }]}</code></pre><p>你会发现名称为 <code>users-id</code> 的路由路径带有 <code>:id?</code> 参数，表示该路由是可选的。如果你想将它设置为必选的路由，需要在 <code>users/_id</code> 目录内创建一个 <code>index.vue</code> 文件。</p><blockquote><p>我们可以尝试一下</p></blockquote><p>动态路由中 <strong><code>?</code></strong>   的含义是什么?</p><p><strong><code>可传可不传</code></strong>      { path: ‘/user/:id?’ ,component: {} }    =&gt;  如果你传的地址 是 /user/1 =&gt; 匹配组件 </p><p> 如果你传的地址 是 /user =&gt; 匹配组件 </p><p>  { path: ‘/user/:id’ ,component: {} }  =&gt;  只能匹配   /user/1</p><h2 id="Nuxt的asyncData-和生命周期"><a href="#Nuxt的asyncData-和生命周期" class="headerlink" title="Nuxt的asyncData 和生命周期"></a>Nuxt的asyncData 和生命周期</h2><blockquote><p>Nuxt.js 扩展了 Vue.js，增加了一个叫 <code>asyncData</code> 的方法，使得我们可以在设置组件的数据之前能异步获取或处理数据。</p></blockquote><p>nuxt =&gt; 服务端渲染 =&gt;  返回的页面结构 是需要数据的, 需要返回页面结构之前 进行 ajax请求</p><p>Vue.js =&gt;  实例创建前后  /  页面渲染前后 /  数据更新前后 / 组件卸载前后</p><p>Nuxt.js  =&gt;  asyncData事件  =&gt; 会在服务端渲染初始化的时候 调用</p><p><code>asyncData</code>方法会在组件（<strong><code>限于页面组件,在pages下的组件</code></strong>）<strong><code>每次加载之前</code></strong>被调用。它可以在服务端或路由更新之前被调用。 在这个方法被调用的时候，第一个参数被设定为当前页面的<a href="https://zh.nuxtjs.org/api#上下文对象" target="_blank" rel="noopener">上下文对象</a>，你可以利用 <code>asyncData</code>方法来获取数据，Nuxt.js 会将 <code>asyncData</code> 返回的数据融合组件 <code>data</code> 方法返回的数据一并返回给当前组件。</p><p><img src="image-20200215142417144.png" alt="image-20200215142417144"></p><p><strong><code>注意</code></strong>：由于<code>asyncData</code>方法是在组件 <strong><code>初始化前</code></strong> 被调用的，所以在方法内是没有办法通过 <code>this</code> 来引用组件的实例对象。  这个asyncData方法 是相当于在后端调用发起了请求,并将数据和data中的数据进行了融合, 这些数据会返回前端,<strong><code>交接</code></strong>给前端的交互</p><p>asyncData 函数 需要返回一个对象,返回的对象会和Vue中的对象进行融合,合并</p><blockquote><p>asyncData中不能用this !</p></blockquote><p><a href="https://zh.nuxtjs.org/guide/async-data" target="_blank" rel="noopener">asyncData说明文档</a> </p><blockquote><p>尝试做个例子吧! 这里提供一个获取数据的接口, 我们可以在asyncData中 尝试请求,并进行服务端数据的渲染</p></blockquote><p><a href="http://ttapi.research.itcast.cn/mp/v1_0/channels" target="_blank" rel="noopener">黑马头条的频道接口</a> </p><p>首先,我们得给我们的nuxt项目安装一个请求工具,也就是axios</p><p>axios 可以在客户端使用,也可以在nodejs后端使用</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> i axios <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在pages新建一个 <strong><code>asyncList.vue</code></strong>组件,内容如下    </p><pre class="line-numbers language-vue"><code class="language-vue"><template>  <div class='app'>      <!-- 头 -->      <div class="header">水若寒宇</div>      <!-- 尾部 -->      <div class="body">           <div class='item' v-for="item in list" :key="item.id">               <span>{{ item.name }}</span>               <span>{{ new Date().toDateString() }}</span>           </div>      </div>  </div></template><script>import axios from 'axios' export default {  data () {    return {    }  }, async asyncData () {    // 这里不能用this 因为执行该函数时  组件还没有实例化    // 执行asyncData时  还在服务端 还没有返回数据  let { data } = await axios({      url:'http://ttapi.research.itcast.cn/app/v1_0/user/channels'    })    // 等到频道的数据加载 然后返回 频道数据  返回的频道数据会和 data进行融合    return { list: data.data.channels }  }}</script><style>  .header {         height: 50px;         background-color: aquamarine;         text-align: center;         font-size: 20px;         line-height: 50px;  }.item {     display: flex;    justify-content: space-between;    padding: 0px 10px;    height: 40px;    line-height: 40px;   }    span:nth-child(2) {        font-size: 14px;        color:#ccc;}</style><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>通过上面的示例,我们可以看出,直接返回的html页面是一个渲染好的页面,但是我们依然从devtools中发现了 list数据,这说明首次渲染,已经将提前在<strong><code>服务端将内容渲染好</code></strong>, 到达前端之后,前端实现了<strong><code>接管</code></strong>,</p></blockquote><p>同学们,这就是真正的服务端渲染!</p><p>需要注意的是，在任何 Vue 组件的<a href="https://vuejs.org/v2/guide/instance.html#Lifecycle-Diagram" target="_blank" rel="noopener">生命周期</a>内， 只有 <code>beforeCreate</code> 和 <code>created</code> 这两个方法会在 <strong>客户端和服务端</strong>被调用。其他生命周期函数仅在客户端被调用。</p><p>也就是 created会在服务端执行一遍,又会在客户端执行一遍,所以如果我们在created中加载数据, 就会<strong><code>重复两次</code></strong>,</p><h2 id="利用Nuxt脚手架开展项目实例"><a href="#利用Nuxt脚手架开展项目实例" class="headerlink" title="利用Nuxt脚手架开展项目实例"></a>利用Nuxt脚手架开展项目实例</h2><blockquote><p>上面我们使用nuxt是纯手工创建的, 目的是让大家熟悉,实际上nuxt也有脚手架 帮我们创建项目</p></blockquote><p>怎么玩?</p><blockquote><p>首先肯定是先读<a href="[https://zh.nuxtjs.org/guide/installation/#%E6%96%B0%E6%89%8B%E6%A8%A1%E6%9D%BF](https://zh.nuxtjs.org/guide/installation/#新手模板)">文档</a></p></blockquote><p>首先,nuxt也有脚手架来帮助我们创建一个服务端渲染的项目,so,开整</p><pre class="line-numbers language-bash"><code class="language-bash">$  npx create-nuxt-app  heima <span class="token comment" spellcheck="true"># npx是npm自带的一个工具 它每次都会下载最新包   heima 是一个项目名</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>然后是一系列的窒息选择操作 , 我们选择   Element(UI框架) +express(web服务框架) + <strong><em><code>Axios</code></em></strong>(Nuxt模块) +Eslint(语法校验) +SSR(服务端渲染)</p></blockquote><p>上面这些选择是nuxt给我们提供好的选项,创建好之后,我们将切到目录下 运行并且访问项目</p><pre class="line-numbers language-bash"><code class="language-bash">$ yarn dev <span class="token comment" spellcheck="true"># 使用yarn </span>$ <span class="token function">npm</span> run dev <span class="token comment" spellcheck="true"># 使用 dev</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>访问 localhost:3000 </p><h2 id="Nuxt脚手架-开发黑马头条PC的登录和数据首页"><a href="#Nuxt脚手架-开发黑马头条PC的登录和数据首页" class="headerlink" title="Nuxt脚手架-开发黑马头条PC的登录和数据首页"></a>Nuxt脚手架-开发黑马头条PC的登录和数据首页</h2><blockquote><p>老铁们,这个nuxt已经让我们创建好项目并且启动起来了,我们要做什么呢?</p></blockquote><p>可否还记得大明湖畔做过的黑马头条PC项目 ? </p><blockquote><p>什么 ? 完全没印象 !  </p></blockquote><p>没印象没关系,这里奉上老铁的<a href="https://github.com/shuiruohanyu/94-heimatoutiaopc.git" target="_blank" rel="noopener">git仓库地址</a>  </p><blockquote><p>我们的目的是 平移一两个黑马头条的页面过来</p></blockquote><p>开整</p><blockquote><p>首先,先把黑马头条的仓库克隆下来, 由于我们黑马头条使用了elementUI, 所以当初创建nuxt项目,我们也用了elementUI</p></blockquote><p>注意, 原来我们的项目用了less预处理器,但是 nuxt并没有,所以首先给我们的项目增加less 依赖</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">npm</span> i <span class="token function">less</span> less-loader <span class="token comment" spellcheck="true"># 安装less 和less-loader</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>其次,我们黑马头条用了一些资源图片,把资源图片拷贝到nuxt目录相等位置,这样可以保证代码几乎不用更改任何内容</p></blockquote><p>接下来,我们先平移 登录页面login,直接将login文件夹 拷贝到nuxt项目的pages下</p><p><strong><code>login/index.vue</code></strong></p><pre class="line-numbers language-vue"><code class="language-vue"><template>  <div class="login">    <!-- 表单 -->    <el-card class="login-card">      <!-- 表单内容 -->      <!-- 头部logo部分 -->      <div class="title">        <img src="../../img/logo_index.png" alt="">      </div>      <!-- 表单 绑定model属性  绑定rules属性(表单验证规则) ref 给el-form一个属性-->      <el-form ref="loginForm" :model="loginForm" :rules="loginRules" style="margin-top:20px">        <!-- 表单容器 设置prop属性 prop表示要校验的字段名-->        <el-form-item prop="mobile">          <!-- 表单域  v-model双向绑定 -->          <el-input v-model="loginForm.mobile" placeholder="请输入手机号" />        </el-form-item>        <!-- 验证码 -->        <el-form-item prop="code">          <el-input v-model="loginForm.code" style="width:60%" placeholder="请输入验证码" />          <!-- 放置一个按钮 -->          <el-button style="float:right" plain>            发送验证码          </el-button>        </el-form-item>        <!-- 表单域 -->        <el-form-item prop="checked">          <!-- 是否同意被人家坑 -->          <el-checkbox v-model="loginForm.checked">            我已阅读同意用户协议和隐私条款          </el-checkbox>        </el-form-item>        <!-- 按钮 -->        <el-form-item>          <el-button style="width:100%" type="primary" @click="login">            登录          </el-button>        </el-form-item>      </el-form>    </el-card>  </div></template><script>export default {  data () {    return {      // 登录表单的数据      loginForm: {        mobile: '', // 手机号        code: '', // 验证码        checked: false // 是否同意用户协议      },      // 定义表单的验证规则      loginRules: {        // required 如果为true表示该字段必填        mobile: [{ required: true, message: '您的手机号不能为空' }, {          pattern: /^1[3-9]\d{9}$/, // 正则表达式          message: '您的手机号格式不正确'        }],        code: [{ required: true, message: '您的验证码不能为空' }, {          pattern: /^\d{6}$/, // 要求6个数字          message: '验证码应该是6位数字'        }],        // 自定义校验  required不能校验true/false        checked: [{          validator (rule, value, callback) {          // rule是当前的校验规则          // value是当前的要校验的字段的值          // calllback是一个回调函数 不论成功或者失败都要执行          // 成功执行callback 失败执行 callback(new Error('错误信息'))          // 我们认为 如果 value 为true 就表示 校验成功 如果value 为false就表示校验失败            // new Error(错误信息) 就是我们提示的错误信息            value ? callback() : callback(new Error('您必须同意我们的霸王条款'))          }        }]      }    }  },  methods: {    login () {      //    this.$refs.loginForm 获取的就是el-form的对象实例      // 第一种 回调函数 isOK, fields(没有校验通过的字段)      // this.$refs.loginForm.validate(function (isOK) {      //   if (isOK) {      //     console.log('校验通过')      //   } else {      //     console.log('校验未通过')      //   }      // }) // 方法      // 第二种方式 promise      this.$refs.loginForm.validate().then(() => {        // 如果成功通过 校验就会到达 then        // 通过校验之后 应该做什么事 -> 应该调用登录接口 看看手机号是否正常        //   this.$axios.get/post/delete/put        this.$axios({          url: '/authorizations', // 请求地址          data: this.loginForm,          // data: { ...this.loginForm, checked: null }, // body请求体参数          method: 'post'        }).then((result) => {          // 成功 之后打印结果          // 把钥匙放在兜里 也就是把token存于 本地缓存          window.localStorage.setItem('user-token', result.data.token)          // 跳转到主页          this.$router.push('/home') // push 和 router-link类似 to属性 可以直接是字符串 也可以是对象        }).catch(() => {          // 提示消息          // 第一种用法          // this.$message({ message: '用户名或者密码错误', type: 'error' })          this.$message.error('用户名或者密码错误')        })      })    }  }}</script><style lang='less' scoped>// 加了scoped属性 就只会对当前自己的组件起作用// 如果需要写less 需要在style标签中 lang='less'.login {  // background-image: url('../../assets/img/back.jpg');  height: 100vh;// 当前屏幕可视区域分成100份  display: flex;  justify-content: center;  align-items: center;  &:before {     content: '123';     width: 100%;     height: 100%;     position: absolute;     background-image: url('../../assets/img/back.jpg');     filter: blur(5px);      background-size: cover;  }  .login-card {    background: rgba(0, 0, 0, 0);    z-index: 2;    width:440px;    height: 340px;    .title {      text-align: center;      img {         height: 40px;      }    }  }}</style><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>拷贝过去之后,我们访问 localhost:3000/login ,我们发现一切OK, 页面没有任何问题,<strong><code>真是nice</code></strong>!</p></blockquote><p>并且,我们之前做的很多校验,正则都能正常之前,这是因为服务端首屏渲染, 内容和逻辑被客户端<strong><code>正常接管</code></strong>,</p><p>除了首屏在服务端完成,一切都还和原来一样!</p><p>创建项目的时候,选了axios模块, 这个axios模块实际上赋值了Vue的全局对象 名字就叫 $axios</p><p><strong><code>this.$axios =&gt; 直接获取的就是 创建项目时 所选择的axios</code></strong></p><blockquote><p>但是这里有个问题,就是我们的axios,请求 的baseUrl没有设置 ,在哪里设置呢? </p></blockquote><p>找到nuxt.config.js文件 </p><p>设置 axios 属性的baseUrl即可,<strong><code>注意</code></strong>  改完这个配置需要重新启动</p><pre class="line-numbers language-js"><code class="language-js">axios<span class="token punctuation">:</span> <span class="token punctuation">{</span>    baseURL<span class="token punctuation">:</span> <span class="token string">'http://ttapi.research.itcast.cn/mp/v1_0/'</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>点击登录成功,我们会进入home组件 </p></blockquote><p>老高带你做一个新的home组件, 展示实时的疫情数据, 小递归 ,树形 </p><pre class="line-numbers language-vue"><code class="language-vue"><template>  <!-- 做一个实时的疫情数据 -->  <el-card>    <!-- 用来展示数据   id是惟一的 是递归生成的-->    <el-table :data="list" row-key="id">      <el-table-column prop="name" label="地区名称" />      <el-table-column prop="total.confirm" label="确诊总人数(人)" />      <el-table-column prop="total.suspect" label="疑似总人数(人)" />      <el-table-column prop="total.dead" label="死亡总人数(人)" />      <el-table-column prop="total.heal" label="康复总人数(人)" />    </el-table>  </el-card></template><script>// 将现在的疫情数据显示到表格上export default {//  加数据  我们要做的服务端渲染// 此函数会在 后端服务端渲染之前 执行  返回的数据 会和data中的数据进行融合  async asyncData (context) {    // 注意 此时 不要用jsonp    // 只有前端才会有跨域同源策略问题    // 此时此刻在服务端    // 如何解决跨域问题 jsonp 利用sciprt标签 可以请求不同端口协议的内容, 回调的形式 执行对应的方法    // 设置cors (通过在服务端设置允许访问的 协议端口地址)    // 采用反向代理的方式 解决跨域    // 服务端是不存在 跨域问题的  先去发起一个请求 => 后台 (允许你访问的后台) => 代替你去访问你要访问的真实后台 => 接口返回给你    // spa 项目中  => 代理 要设置在 webpack中, webpack可以当做一个后台(仅仅限于开发期间),因为webpack 是一个开发期间的工具    // 你最终的打包的项目要部署到 linux服务器 ,采用ngix 进行web化服务, 上线之后 需要ngix去做你的反向代理, 只需要运维帮你做, 但是你你需要知道    // 请求数据    const url = 'https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5'    // 哪里有axios 我们安装项目是选择的axios 那是前端的对象    // context.app  => 指的就是 前端的vue惟一的Vue实例对象    const { data: { data } } = await context.app.$axios({      url    })    const result = JSON.parse(data)    // 如果想要解决重复的问题 可以进行一下递归 递归的目的是 给每一个节点 每一条数据加上一个惟一的id    // 递归方法    // arr是当前的数组 prefix是当前的前缀    const dealId = function (arr, prefix) {      arr.forEach((element, index) => {        element.id = prefix + '-' + (index + 1) // 所有的地区都是从1 开始        if (element.children && element.children.length) {          // 此时 表示有子节点          dealId(element.children, element.id) // 此时 中国是 1  1-1 1-2  1-1-1        }      })    }    dealId(result.areaTree, '') // 处理树形数据  第二个参数 是 前缀  树形数据  1-1 1-2 1-3  2-1 2-2 2-3    return { list: result.areaTree }  }}</script><style></style><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间关系,我们对nuxt只是简单进行了一下了解,实际上还有内容可以做,希望大家通过通过<a href="https://zh.nuxtjs.org/guide/installation" target="_blank" rel="noopener">nuxt官网</a>来认识更多的功能</p><h1 id="That-39-s-All-谢幕"><a href="#That-39-s-All-谢幕" class="headerlink" title="That &#39;s All   谢幕"></a><code>That &#39;s All</code>   <code>谢幕</code></h1>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVVM</title>
      <link href="/2020/04/07/vue-jin-jie-vue-de-mvvm-shi-xian-yuan-li/"/>
      <url>/2020/04/07/vue-jin-jie-vue-de-mvvm-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="MVVM-介绍和演示"><a href="#MVVM-介绍和演示" class="headerlink" title="MVVM-介绍和演示"></a>MVVM-介绍和演示</h2><p><img src="mvvm-3510948.png" alt="MVVM"></p><blockquote><p>面试过程中,面试官一定会问你 描述一下 你所知道的MVVM?</p><p>MVVM 在Vue中是用什么来实现的?</p><p>OK,我们来攻克这个题目</p></blockquote><ul><li><p>首先第一个M,指的是 Model, 也就是<strong><code>数据模型</code></strong>,其实就是数据, 换到Vue里面,其实指的就是 Vue组件实例中的<strong><code>data</code></strong>, 但是这个data 我们从一开始就定义了 它叫 <strong><code>响应式数据</code></strong></p></li><li><p>第二个V,指的是View, 也就是<strong><code>页面视图</code></strong>, 换到Vue中也就是 我们的<strong><code>template</code></strong>转化成的<strong><code>DOM对象</code></strong></p></li><li><p>第三个 VM, 指的是<strong><code>ViewModel</code></strong>,  也就是 视图和数据的管理者, 它管理着我们的数据 到 视图变化的工作,换到Vue中 ,它指的就是我们的当前的<strong><code>Vue实例</code></strong>,  Model数据 和 View 视图通信的一个<strong><code>桥梁</code></strong></p></li></ul><ul><li><p>简单一句话：<strong><code>数据驱动视图</code></strong>, 数据变化 =&gt;视图更新</p><p>Vue是双向数据流,React是单向数据流</p><blockquote><p>Vue 数据变化  =&gt; 视图变化  视图变化  =&gt; 数据变化</p><p>React  数据变化  =&gt; 视图变化  (自身框架只支持数据驱动视图)    (手动实现)  视图变化  =&gt; 数据变化</p></blockquote></li></ul><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 视图 <span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span> message <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token comment" spellcheck="true">// Model 普通数据对象</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  data <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      message<span class="token punctuation">:</span> <span class="token string">'Hello World'</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>style<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MVVM-响应式原理-Object-defineProperty-基本使用"><a href="#MVVM-响应式原理-Object-defineProperty-基本使用" class="headerlink" title="MVVM-响应式原理-Object.defineProperty()-基本使用"></a>MVVM-响应式原理-Object.defineProperty()-基本使用</h2><blockquote><p>接下里,我们来重点研究MVVM的原理及实现方式,Vuejs官网给出了MVVM的原理方式</p></blockquote><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue文档说明</a> </p><blockquote><p>通过上面的文档我们可以发现, Vue的响应式原理(MVVM)实际上就是下面这段话:</p><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 将遍历此对象所有的属性，并使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener"><code>Object.defineProperty</code></a> 把这些属性全部转为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#定义_getters_与_setters" target="_blank" rel="noopener">getter/setter</a>。<code>Object.defineProperty</code> 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p></blockquote><p>从上面的表述中,我们发现了几个关键词, <strong><code>Object.defineProperty</code></strong>   <strong><code>getter/setter</code></strong></p><blockquote><p>什么是 Object.defineProperty? </p></blockquote><p>定义:<code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p><blockquote><p>语法:  Object.defineProperty(obj, prop, descriptor)</p></blockquote><p>参数:  <strong>obj</strong>  =&gt;  要在其上定义属性的对象。</p><p>​           <strong>prop</strong>  =&gt;  要新增或者修改的属性名</p><p>​           <strong>descriptor</strong>  =&gt;  将被定义或修改的属性描述符。</p><p>返回值 :    被传递给函数的对象。 也就是 传入的obj对象</p><blockquote><p>通过上面的笔记 我们来看下 有哪些参数 需要学习</p><p>obj  就是一个对象  可以 new Object()  也可以  {}</p><p>prop  就是属性名 也就是一个字符串</p><p>descriptor 描述符是什么 ?  有哪些属性</p></blockquote><p>对象里目前存在的属性描述符有两种主要形式：<strong><code>数据描述符</code></strong>和<strong><code>存取描述符</code></strong>。<strong><code>数据描述符</code></strong>是一个具有值的属性，该值可能是可写的，也可能不是可写的。<strong><code>存取描述符</code></strong>是由getter-setter函数对描述的属性。描述符必须是这两种形式之一；<strong><code>不能同时是两者</code></strong>。</p><blockquote><p>上面是官方描述 ,它告诉我们 defineProterty设计上有<strong><code>两种模式</code></strong>存在,一种<strong><code>数据描述</code></strong>, 一种<strong><code>存取描述</code></strong></p><p>描述符必须是这两个中的一个 ,不能同时是两者, 也就是 <strong><code>一山不容二虎</code></strong>, 也不能 <strong><code>一山两虎都无</code></strong></p></blockquote><p>我们写一个最简单的 <strong><code>数据描述符</code></strong>的例子</p><pre class="line-numbers language-js"><code class="language-js">        <span class="token comment" spellcheck="true">// Object.defineProperty(obj, prop, descriptor)</span>        <span class="token comment" spellcheck="true">// obj  对象  prop属性名 descriptor 描述符 (数据描述 / 存取描述)</span>        <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>            msg<span class="token punctuation">:</span> <span class="token string">'愚人节,真不快乐'</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 新增一个属性</span>        <span class="token keyword">var</span> o <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 描述符对象</span>            value<span class="token punctuation">:</span> <span class="token string">'泰森'</span> <span class="token comment" spellcheck="true">// 指的就是新增属性的值  value是固定写法</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'msg'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            value<span class="token punctuation">:</span> <span class="token string">'希望找到工作'</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 返回值 o 就是 新增过属性的obj</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>接下来进行详细分析</p></blockquote><h2 id="Object-defineProperty-数据描述符模式"><a href="#Object-defineProperty-数据描述符模式" class="headerlink" title="Object.defineProperty()-数据描述符模式"></a>Object.defineProperty()-<code>数据描述符</code>模式</h2><blockquote><p>数据描述符有哪些属性?</p></blockquote><ul><li><strong><code>value</code></strong> =&gt;该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 unfined</li><li><strong><code>writable</code></strong> =&gt; 当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</li></ul><blockquote><p>就这两个 ? 还有吗 ?</p></blockquote><ul><li><strong><code>configurable</code></strong>  =&gt;  当且仅当该属性的 configurable 为 true 时，该属性<code>描述符</code>才能够被改变，同时该属性也能从对应的对象上被删除。<strong>默认为 false</strong>。</li><li><strong><code>enumerable</code></strong>  =&gt; 当且仅当该属性的<code>enumerable</code>为<code>true</code>时，该属性才能够出现在对象的枚举属性中。<strong>默认为 false</strong>。</li></ul><blockquote><p>为什么  <strong><code>configurable</code></strong>  和 <strong><code>enumerable</code></strong>  不同时 和 value  还有 writable一起写呢 ?</p></blockquote><p>因为这两个属性不但可以在数据描述符里出现 还可以在 存取描述符里出现</p><blockquote><p>我们通过writeable 和 value属性来写一个 可写的属性 和不写的属性  </p></blockquote><pre class="line-numbers language-js"><code class="language-js">   <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>          name<span class="token punctuation">:</span> <span class="token string">'曹扬'</span>      <span class="token punctuation">}</span>     Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'money'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>         value<span class="token punctuation">:</span> <span class="token string">"10k"</span> <span class="token comment" spellcheck="true">// 薪水 此时薪水是不可改的</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span>     Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'weight'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>         value<span class="token punctuation">:</span> <span class="token string">'150斤'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 给一万根头发</span>         writable<span class="token punctuation">:</span> <span class="token boolean">true</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span>     obj<span class="token punctuation">.</span>money <span class="token operator">=</span> <span class="token string">'20k'</span>     obj<span class="token punctuation">.</span>weight <span class="token operator">=</span> <span class="token string">'200斤'</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 此时 薪水还是 10k  但是体重变成 200斤</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>接下来 ,我们希望 去让一个不可变的属性变成可变的</p></blockquote><pre class="line-numbers language-js"><code class="language-js">    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>          name<span class="token punctuation">:</span> <span class="token string">'曹扬'</span>      <span class="token punctuation">}</span>     Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'money'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>         value<span class="token punctuation">:</span> <span class="token string">'10k'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 薪水 此时薪水是不可改的</span>         configurable<span class="token punctuation">:</span> <span class="token boolean">true</span>  <span class="token comment" spellcheck="true">// 只有这里为true时 才能去改writeable属性</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span>     Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'weight'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>         value<span class="token punctuation">:</span> <span class="token string">'150斤'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 给一万根头发</span>         writable<span class="token punctuation">:</span> <span class="token boolean">true</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span>     obj<span class="token punctuation">.</span>money <span class="token operator">=</span> <span class="token string">"20k"</span>     obj<span class="token punctuation">.</span>weight <span class="token operator">=</span> <span class="token string">'200斤'</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>     Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'money'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>         writable<span class="token punctuation">:</span> <span class="token boolean">true</span>  <span class="token comment" spellcheck="true">// 只有前面配置了configurable: true 后面的属性才可以修改 </span>     <span class="token punctuation">}</span><span class="token punctuation">)</span>     obj<span class="token punctuation">.</span>money <span class="token operator">=</span> <span class="token string">'20k'</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 此时薪水才可以改变</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>接下来,我们希望可以在遍历的时候 遍历到新添加的两个属性</p></blockquote><pre class="line-numbers language-js"><code class="language-js">      <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>          name<span class="token punctuation">:</span> <span class="token string">'曹扬'</span>      <span class="token punctuation">}</span>     Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'money'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>         value<span class="token punctuation">:</span> <span class="token string">'10k'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 薪水 此时薪水是不可改的</span>         configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>         enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span>  <span class="token comment" spellcheck="true">// 此属性用来 表示该属性 可以遍历循环得到</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span>     Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'weight'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>         value<span class="token punctuation">:</span> <span class="token string">'150斤'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 给一万根头发</span>         writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>         enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span>     obj<span class="token punctuation">.</span>money <span class="token operator">=</span> <span class="token string">"20k"</span>     obj<span class="token punctuation">.</span>weight <span class="token operator">=</span> <span class="token string">'200斤'</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>     Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'money'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>         writable<span class="token punctuation">:</span> <span class="token boolean">true</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>     obj<span class="token punctuation">.</span>money <span class="token operator">=</span> <span class="token string">'20k'</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> item <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>     <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Object-defineProperty-存取描述符模式"><a href="#Object-defineProperty-存取描述符模式" class="headerlink" title="Object.defineProperty()-存取描述符模式"></a>Object.defineProperty()-<code>存取描述符</code>模式</h2><blockquote><p>上一小节中,数据描述符 独有的属性 是 value  和 writable , 这也就意味着, 在存取描述模式中</p><p>value 和 writable属性不能出现</p><p>那么 存储描述符有啥属性 ?</p></blockquote><ul><li><strong><code>get</code></strong>  一个给属性提供 getter 的方法，如果没有 getter 则为 <code>undefined</code>。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入<code>this</code>对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）。</li><li><strong><code>set</code></strong>  一个给属性提供 setter 的方法，如果没有 setter 则为 <code>undefined</code>。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。</li></ul><blockquote><p>get/set  其实就是我们最常见的 读取值 和设置值得方法   this.name 读取值 this.name = ‘张三’</p><p>读取值得时候 调用 get方法 </p><p>设置值得时候调用 set方法</p></blockquote><p>我们做一个 可以 通过 get 和 set 读取设置的方法</p><pre class="line-numbers language-js"><code class="language-js">        <span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'曹操'</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">''</span>        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'wife'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//   存取描述符  不需要 设置可写 和不可写</span>            <span class="token comment" spellcheck="true">//  writable: false, // 是错误的 数据描述符  不能和存取描述符一起写</span>            <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 获取值</span>                <span class="token keyword">return</span> name            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 设置值</span>                name <span class="token operator">=</span> value            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>wife<span class="token punctuation">)</span>        person<span class="token punctuation">.</span>wife <span class="token operator">=</span> <span class="token string">"大乔"</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>wife<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>但是,我们想要遍历怎么办 ? 注意哦 , 存储描述符的时候 依然拥有 <strong>configurable</strong> 和 <strong>enumerable</strong>属性,</p><p>依然可以配置哦</p></blockquote><pre class="line-numbers language-js"><code class="language-js">  <span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'曹操'</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">''</span>        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">'wife'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//   存取描述符  不需要 设置可写 和不可写</span>            <span class="token comment" spellcheck="true">//  writable: false, // 是错误的 数据描述符  不能和存取描述符一起写</span>            enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 表示该属性可以被遍历到</span>            <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 获取值</span>                <span class="token keyword">return</span> name            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 设置值</span>                name <span class="token operator">=</span> value            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>wife<span class="token punctuation">)</span>        person<span class="token punctuation">.</span>wife <span class="token operator">=</span> <span class="token string">"大乔"</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>wife<span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据描述符 wriable 只对 数据描述的时候 value进行控制,不能和存取描述符一起写</p><h2 id="Object-defineProperty-模拟vm对象"><a href="#Object-defineProperty-模拟vm对象" class="headerlink" title="Object.defineProperty()-模拟vm对象"></a>Object.defineProperty()-模拟vm对象</h2><blockquote><p>通过两个小节,学习了 defineProperty的基本使用, 接下里我们要通过defineProperty模拟 Vue实例化的效果</p></blockquote><p>Vue实例化的时候, 我们明明给data赋值了数据,但是却可以通过 <strong><code>vm实例.属性</code></strong>进行访问和设置</p><p>怎么做的 ?</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>   data<span class="token punctuation">:</span> <span class="token punctuation">{</span>      name<span class="token punctuation">:</span> <span class="token string">'张三'</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>vm<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'李四'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>实际上这就是 通过 Object.defineProperty实现的</p></blockquote><pre class="line-numbers language-js"><code class="language-js">   <span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>            name<span class="token punctuation">:</span> <span class="token string">'庚子初年,天下大乱,疫情危机'</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// vm对象  vm代理data中的数据</span>        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 存取描述符</span>            <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> data<span class="token punctuation">.</span>name  <span class="token comment" spellcheck="true">// 返回data中的数据</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 设置值的时候 要去修改data中的值</span>                data<span class="token punctuation">.</span>name <span class="token operator">=</span> value            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>name<span class="token punctuation">)</span>        vm<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'春暖花开,一切如常'</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上面代码中,我们实现了 vm中的数据代理了 data中的name 直接改vm就是改data</p></blockquote><p><strong><code>总结</code></strong>: 我们在 set和get的存取描述符中 代理了 data中的数据, </p><p>MVVM =&gt; 数据代理  =&gt; Object.defineProperty =&gt;存取描述符get/set =&gt; 代理数据</p><p>MVVM不但要获取这些数据,并且将这些数据 进行 响应式的更新到DOM中, 也就是 数据变化时,我们要把数据<strong><code>反映</code></strong>到视图上</p><blockquote><p>通过调试我们发现,我们是可以在set函数里面监听到数据的变化的,只需要在数据变化的时候, 通知对应的视图来更新就可以了</p></blockquote><p>那么 怎么通知 ? 用什么技术来做 ? 下一小节中我们将带来发布订阅模式</p><h2 id="发布订阅模式的介绍"><a href="#发布订阅模式的介绍" class="headerlink" title="发布订阅模式的介绍"></a>发布订阅模式的介绍</h2><blockquote><p>发布订阅模式为何物?</p></blockquote><p>其实我们早已用过很多遍,  发布 /订阅 即 有人<strong><code>发布消息</code></strong>, 有人 <strong><code>订阅消息</code></strong>,到了 数据层面 就是 多  =&gt; 多</p><p>即   A程序 可以触发多个消息  也可以订阅 多个消息</p><blockquote><p>在黑马头条项目1 和项目2 中我们 曾经 用过一个<strong><code>eventBus</code></strong> 就是发布订阅模式的体现</p></blockquote><p>这个模式我们拿来做什么?</p><blockquote><p>上个小节,我们已经能够捕捉数据的变化,接下来,我们就要尝试在数据变化的时候通过 发布订阅这个模式 来改变我们的视图</p></blockquote><p>我们先写出这个发布订阅核心代码的几个要素 </p><blockquote><p>首先,我们希望 可以通过实例化 得到 发布订阅对象  </p><p>发布消息 $emit</p><p>订阅消息 $on</p></blockquote><p>根据上述思想,我们得到如下代码</p><pre class="line-numbers language-js"><code class="language-js">      <span class="token comment" spellcheck="true">//  创建一个构造函数</span>      <span class="token keyword">function</span> Events <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//    订阅消息 监听消息</span>      Events<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$on <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//   发布消息</span>      Events<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$emit <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="发布订阅模式的实现"><a href="#发布订阅模式的实现" class="headerlink" title="发布订阅模式的实现"></a>发布订阅模式的实现</h2><pre class="line-numbers language-js"><code class="language-js">   <span class="token comment" spellcheck="true">//    希望通过实例化 得到 发布订阅 管理器</span>        <span class="token comment" spellcheck="true">// 创建一个构造函数</span>        <span class="token keyword">function</span> <span class="token function">Events</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//  构造函数</span>            <span class="token comment" spellcheck="true">// 需要监听事件 需要去触发事件</span>            <span class="token comment" spellcheck="true">// 需要一个 对象来存储 事件名称 和事件参数</span>            <span class="token comment" spellcheck="true">// { (事件名1): [回调函数1, 回调函数2,回调函数3...]    }</span>            <span class="token comment" spellcheck="true">// { (发工资事件): [A回调函数, B回调函数, C ,D ,E ...], (扣工资事件), (涨工资事件)  }</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// this指的是当前实例 subs里面存储的就是当前对象中放置的所有的事件 和回调函数</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 原型方法 $emit(触发事件)  $on(监听事件)</span>        <span class="token comment" spellcheck="true">// 触发一个事件</span>        <span class="token comment" spellcheck="true">// $emit("selectChange", 若干参数) ...params 就表示从第二个参数后面的所有的参数</span>        Events<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$emit <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>eventName<span class="token punctuation">,</span> <span class="token operator">...</span>params<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//  去执行对应的回调函数</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">[</span>eventName<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">[</span>eventName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// fn(...params) // 直接执行fn函数  调用fn的对象 window</span>                <span class="token comment" spellcheck="true">//  如果改变函数中的this指向 </span>                <span class="token comment" spellcheck="true">// call  apply bind </span>                <span class="token comment" spellcheck="true">// fn.call(this, ...params)  // n个参数</span>                <span class="token comment" spellcheck="true">// fn.apply(this, [...params]) // apply第二个参数是个数组</span>                fn<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>params<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 此时只是返回一个 改变了this指向函数 并不会执行</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 监听事件触发</span>        <span class="token comment" spellcheck="true">// eventName (监听事件名) fn(该事件触发时 调用的回调函数)</span>        Events<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$on <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>eventName<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// if (this.subs[eventName]) {</span>            <span class="token comment" spellcheck="true">//     this.subs[eventName].push(fn) // 将函数加到数组中</span>            <span class="token comment" spellcheck="true">// } else {</span>            <span class="token comment" spellcheck="true">//     // this.subs[eventName] = []</span>            <span class="token comment" spellcheck="true">//     // this.subs[eventName].push(fn)</span>            <span class="token comment" spellcheck="true">//     this.subs[eventName] = [fn]</span>            <span class="token comment" spellcheck="true">//     //this.subs[eventName].push(fn)</span>            <span class="token comment" spellcheck="true">// }</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">[</span>eventName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">[</span>eventName<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">[</span>eventName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Events</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 实例化 事件管理器</span>        event<span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span><span class="token string">"change"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 希望 执行function函数时  里面的this 指向的是 事件管理器</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>            <span class="token function">alert</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token string">'-'</span> <span class="token operator">+</span> b <span class="token operator">+</span> <span class="token string">'-'</span> <span class="token operator">+</span> c<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 先开启监听 才能 去触发事件 否则监听不到</span>        <span class="token comment" spellcheck="true">// console.log(event)</span>        <span class="token keyword">function</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 触发change事件</span>            event<span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">"change"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里用到了call/apply/bind方法修改函数内部的this指向</p></blockquote><blockquote><p>利用发布订阅模式可以实现当事件触发时会通知到很多人去做事情,Vue中做的事情是更新DOM</p></blockquote><h2 id="MVVM实现-DOM复习"><a href="#MVVM实现-DOM复习" class="headerlink" title="MVVM实现-DOM复习"></a>MVVM实现-DOM复习</h2><blockquote><p>我们学习了 Object.defineProperty  和  发布订阅模式,  几乎拥有了手写一个MVVM的能力, </p><p>但是在实现MVVM之前,我们还是复习一下 View中也就是 Dom中的含义及结构</p></blockquote><p>DOM是什么?</p><blockquote><p>文档对象模型 document</p></blockquote><p>Dom的作用是什么?</p><blockquote><p>可以通过<strong><code>对象</code></strong>去操作页面元素</p></blockquote><p>Dom中的对象节点都有什么类型</p><blockquote><p>可以通过下面的一个小例子检查</p></blockquote><pre class="line-numbers language-html"><code class="language-html">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>众志成城,共抗疫情<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">='</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span><span class="token property">font-weight</span><span class="token punctuation">:</span> bold<span class="token punctuation">;</span></span><span class="token punctuation">'</span></span><span class="token punctuation">></span></span>老高:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>祝所有同学前程似锦<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">       <span class="token keyword">var</span> app <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">)</span>       console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>通过上面的输出查看, 我们可以发现</p></blockquote><p>元素类型的节点类型 nodeType 为1 文本类型为 3, document对象里面的每个内容都是<strong><code>节点</code></strong></p><p>childNodes  是所有的节点  children指的 是所有的元素 =&gt; nodeType =1 的节点</p><p>所有的子节点都放在 childNodes 这个属性下,childNodes是伪数组 =&gt; 伪数组不具有数组方法. 有length属性</p><blockquote><p>所有标签的属性集合是什么?</p></blockquote><p>attributes  =&gt; 放置了所有的属性</p><blockquote><p>分析DOM对象做什么呢? 我们前面准备的数据捕获和 发布订阅就是为了来更新DOM的</p></blockquote><p>接下来我们开始手写一个MVVM示例</p><p>手写一个vuejs 的简易版  Object.defineProperty =&gt; 新增属性 .修改属性  数据代理 </p><p>发布订阅 =&gt; 发布事件  订阅事件 </p><p>Dom =&gt; 更新视图</p><h2 id="MVVM实现-实现Vue的构造函数和数据代理"><a href="#MVVM实现-实现Vue的构造函数和数据代理" class="headerlink" title="MVVM实现-实现Vue的构造函数和数据代理"></a>MVVM实现-实现Vue的构造函数和数据代理</h2><blockquote><p>挑战来了,我们要手写 一个简易的<strong><code>vuejs</code></strong>, 提升我们自身的技术实力.</p></blockquote><blockquote><p>我们要实现mvvm的构造函数</p><p>构造函数 模仿vuejs 分别有 data /el </p><p>data最终被代理给当前的vm实例, 即可以通过 vm访问,也可以通过 this.$data访问</p></blockquote><pre class="line-numbers language-js"><code class="language-js"> <span class="token comment" spellcheck="true">// 实现Vue的构造函数</span>        <span class="token comment" spellcheck="true">// options 表示构造参数的选项</span>        <span class="token keyword">function</span> <span class="token function">Vue</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果是字符串 就用 选择器选择 如果不是 就认为是 dom对象</span>            <span class="token comment" spellcheck="true">// vue中所有的属性 都以$开头</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$el <span class="token operator">=</span> <span class="token keyword">typeof</span> options<span class="token punctuation">.</span>el <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">:</span> options<span class="token punctuation">.</span>el            <span class="token comment" spellcheck="true">// 原来在vue中 this.$data获取数据</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$data <span class="token operator">=</span> options<span class="token punctuation">.</span>data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 将选项中data赋值给 this.$data</span>            <span class="token comment" spellcheck="true">// 下一步 要代理$data中的数据</span>            <span class="token comment" spellcheck="true">// this.name  等价于 this.$data.name</span>            <span class="token comment" spellcheck="true">// this 代理 this.$data中所有的属性  用  Object.defineProperty</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$proxyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 代理数据 把 $data中数据 用 this 代理</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 代理数据方法  目的是 this 代理所有的this.$data中的属性</span>        <span class="token comment" spellcheck="true">// 数据代理</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$proxyData <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// this 就是当前的vm实例</span>            Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// key 就是当掐你data中的每个属性</span>                Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 数据描述符 存取描述符</span>                    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 返回这个key的值</span>                        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 返回$data中的数据</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                    <span class="token keyword">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 如果 设置的值 和原来的值 一样的话  就没有 必要设置了</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value  <span class="token comment" spellcheck="true">// 设置值给$data中的数据</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MVVM实现-数据劫持Observer"><a href="#MVVM实现-数据劫持Observer" class="headerlink" title="MVVM实现-数据劫持Observer"></a>MVVM实现-数据劫持Observer</h2><blockquote><p>OK,接下来这一步非常关键,我们要做<strong><code>数据劫持</code></strong>, 劫持谁? 为什么要劫持?</p></blockquote><p>上小节代码中, 我们可以通过 vm.name= ‘值’ 也可以通过 vm.$data.name = ‘值’, 那么在哪里捕捉数据的变化呢?</p><blockquote><p>不论是 this.data 还是 this.$data 改的都是$data的数据,所以我们需要对 $data的数据进行<strong><code>劫持</code></strong>, 也就是监听它的set</p></blockquote><p>数据劫持意味着 :   我们要监控MVVM中的 Model的数据层的变化</p><pre class="line-numbers language-js"><code class="language-js">  <span class="token comment" spellcheck="true">// 数据劫持   要劫持 $data的数据变化 因为需要在数据变化时  => 视图更新</span>        <span class="token comment" spellcheck="true">// 此方法的目的是 劫持数据的更新  在更新的时候 通知视图</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$observer <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 先要获取每个属性的初始值 </span>                <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 此时value是 初始值</span>                Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>                    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> value <span class="token comment" spellcheck="true">// 返回值 </span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span>                    <span class="token keyword">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span>                        value <span class="token operator">=</span> newValue  <span class="token comment" spellcheck="true">// 设置新值</span>                        <span class="token comment" spellcheck="true">// 一旦进入到这个位置 表示 数据变化  => 视图变化 数据变化了 => 视图 渲染  =>发布订阅模式 来通知视图</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在构造函数中完成对数据的劫持</p></blockquote><pre class="line-numbers language-js"><code class="language-js">   <span class="token comment" spellcheck="true">// 实现Vue的构造函数</span>        <span class="token comment" spellcheck="true">// options 表示构造参数的选项</span>        <span class="token keyword">function</span> <span class="token function">Vue</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果是字符串 就用 选择器选择 如果不是 就认为是 dom对象</span>            <span class="token comment" spellcheck="true">// vue中所有的属性 都以$开头</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$el <span class="token operator">=</span> <span class="token keyword">typeof</span> options<span class="token punctuation">.</span>el <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">:</span> options<span class="token punctuation">.</span>el            <span class="token comment" spellcheck="true">// 原来在vue中 this.$data获取数据</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$data <span class="token operator">=</span> options<span class="token punctuation">.</span>data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 将选项中data赋值给 this.$data</span>            <span class="token comment" spellcheck="true">// 下一步 要代理$data中的数据</span>            <span class="token comment" spellcheck="true">// this.name  等价于 this.$data.name</span>            <span class="token comment" spellcheck="true">// this 代理 this.$data中所有的属性  用  Object.defineProperty</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$proxyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 代理数据 把 $data中数据 用 this 代理</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$observer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 完成数据劫持</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MVVM实现-编译模板Compiler-设计结构"><a href="#MVVM实现-编译模板Compiler-设计结构" class="headerlink" title="MVVM实现-编译模板Compiler-设计结构"></a>MVVM实现-编译模板Compiler-设计结构</h2><p>代理 :  $data中的所有数据都代理给了 this</p><p>劫持 : $data中的数据变化</p><blockquote><p>现在我们基本实现了 实例化数据,并且完成了对数据的代理和劫持,接下来我们需要实现几个方法 </p><p>数据变化时 =&gt; 根据最新数据把模板转化成最新的对象</p><p>判断节点是否是文本节点</p><p>判断节点是否是 元素节点</p><p>判断是否是指令  v-model / v-text</p><p>处理元素节点  </p><p>处理文本节点</p><p>所以我们定义下面几个方法</p></blockquote><pre class="line-numbers language-js"><code class="language-js">        <span class="token comment" spellcheck="true">// 编辑模板的总方法 需要在 构造函数时执行</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$complie <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 处理文本类型的节点</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$complieTextNode <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 处理元素类型的节点</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$complieElementNode <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 判断 一个节点是否是 文本节点</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$isTextNode <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 是否是元素节点</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$isElementNode <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 判断是一个属性是否是指令 判断的依据是 以v-开头</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$isDirective <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MVVM实现-编译模板Compiler实现基本的框架逻辑"><a href="#MVVM实现-编译模板Compiler实现基本的框架逻辑" class="headerlink" title="MVVM实现-编译模板Compiler实现基本的框架逻辑"></a>MVVM实现-编译模板Compiler实现基本的框架逻辑</h2><blockquote><p>我们已经通过构造函数拿到了$el,也就是页面的dom元素,接下来我们可以实现 一下编译的基本逻辑</p></blockquote><p>注意:  <strong><code>文本节点就不再有子节点了 因为文本就是最终的体现</code></strong></p><p>   <strong><code>元素节点 一定还有子节点</code></strong></p><pre class="line-numbers language-js"><code class="language-js">  <span class="token comment" spellcheck="true">// 编辑模板的总方法 需要在 构造函数时执行</span>        <span class="token comment" spellcheck="true">// 这个方法 要处理 所有的节点  递归  递归就是自身调用自身 但是请切记 递归的方法体 一定要有条件限制 否则 死循环</span>        <span class="token comment" spellcheck="true">// rootnode 是本地递归调用的一个起点</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$complie <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>rootnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 拿到rootnode 先要获取rootnode的子节点</span>            <span class="token keyword">let</span> nodes <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>rootnode<span class="token punctuation">.</span>childNodes<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 伪数组 => 真正数组</span>            nodes<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>node <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 判断 当前节点类型 如果是文本节点  就不再有 子节点了</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$isTextNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//    如果当前的node是文本节点  就不需要再对此node 下的子节点进行处理了</span>                    <span class="token comment" spellcheck="true">// 只需要处理该节点即可</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$complieTextNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 处理文本类型节点</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$isElementNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 如果是节点是一个元素节点 表示它肯定还有下一个节点 </span>                    <span class="token comment" spellcheck="true">// 先处理 当前元素的内容</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$complieElementNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 处理元素类型的节点</span>                    <span class="token comment" spellcheck="true">// 此时就要调用自身的方法 递归</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$complie</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 调用自身的方法 传入当前node 作为下一个找寻的起点 自身调用自身 知道 所有的childNodes的长度为0</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 处理文本类型的节点</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$complieTextNode <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 处理元素类型的节点</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$complieElementNode <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 判断 一个节点是否是 文本节点  用nodeType === 3 </span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$isTextNode <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> node<span class="token punctuation">.</span>nodeType <span class="token operator">===</span> <span class="token number">3</span> <span class="token comment" spellcheck="true">// true 文本节点 false 不是文本节点</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 是否是元素节点 nodeType ===1 元素节点</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$isElementNode <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> node<span class="token punctuation">.</span>nodeType <span class="token operator">===</span> <span class="token number">1</span> <span class="token comment" spellcheck="true">// true 元素节点 false 不是元素节点</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 判断是一个属性是否是指令 判断的依据是 以v-开头</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$isDirective <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上述代码的基本逻辑就是 碰到 文本节点就用文本节点的方法处理  碰到元素节点 用元素节点的方法处理 </p><p>如果碰到元素节点,就表示<strong><code>还没完</code></strong>  还需要调用下一级的查找</p></blockquote><h2 id="MVVM实现-编译模板Compiler-处理文本节点"><a href="#MVVM实现-编译模板Compiler-处理文本节点" class="headerlink" title="MVVM实现-编译模板Compiler-处理文本节点"></a>MVVM实现-编译模板Compiler-处理文本节点</h2><pre class="line-numbers language-js"><code class="language-js">        <span class="token comment" spellcheck="true">// 处理文本类型的节点</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$complieTextNode <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 处理文本节点  把文本中的插值表达式 中的变量   替换成 $data中的值 也就是this中的值</span>            <span class="token keyword">const</span> text <span class="token operator">=</span> node<span class="token punctuation">.</span>textContent <span class="token comment" spellcheck="true">// 文本内容</span>            <span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token operator">/</span>\<span class="token punctuation">{</span>\<span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">+</span><span class="token operator">?</span><span class="token punctuation">)</span>\<span class="token punctuation">}</span>\<span class="token punctuation">}</span><span class="token operator">/</span>g  <span class="token comment" spellcheck="true">// 匹配所有的 {{ 内容  }}  ? 非贪婪模式  {{ name }}  {{  age }}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//  如果此时能够匹配正则表达式</span>                <span class="token comment" spellcheck="true">// </span>                <span class="token keyword">const</span> key <span class="token operator">=</span> RegExp<span class="token punctuation">.</span>$<span class="token number">1</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// key是要替换的变量名</span>                <span class="token comment" spellcheck="true">// console.log(RegExp.$1.trim())    // 获取第一个匹配的内容</span>                node<span class="token punctuation">.</span>textContent <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 直接将 this中的name替换 视图中的 {{ name }}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>提示: 实际开发时正则不需要记 但是要能看懂 </p></blockquote><h2 id="MVVM实现-编译模板Compiler-处理元素节点"><a href="#MVVM实现-编译模板Compiler-处理元素节点" class="headerlink" title="MVVM实现-编译模板Compiler-处理元素节点"></a>MVVM实现-编译模板Compiler-处理元素节点</h2><pre class="line-numbers language-js"><code class="language-js">        <span class="token comment" spellcheck="true">// 处理元素类型的节点</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$complieElementNode <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 当处理的节点是元素标签时 此时 处理指令</span>            <span class="token comment" spellcheck="true">// 所有的标签的属性在 attributes</span>            <span class="token comment" spellcheck="true">// 解析 判断 属性是否是指令 如果是指令 处理指令  v-text v-model</span>            <span class="token keyword">let</span> attrs <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>attributes<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 伪数组 =>真数组 所有的属性</span>            attrs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>attr <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 判断当前的属性是否是指令</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$isDirective</span><span class="token punctuation">(</span>attr<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// v-text  v-model</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>attr<span class="token punctuation">.</span>name <span class="token operator">===</span> <span class="token string">'v-text'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//  </span>                        node<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">// 获取v-text的属性名 // 将 变量的值赋值给 div的属性</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>attr<span class="token punctuation">.</span>name <span class="token operator">===</span> <span class="token string">'v-model'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// v-model是双向绑定 绑定的是元素的value值 表单的value</span>                        node<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">// 此时node表示就是input</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MVVM实现-数据驱动视图-发布订阅管理器"><a href="#MVVM实现-数据驱动视图-发布订阅管理器" class="headerlink" title="MVVM实现-数据驱动视图-发布订阅管理器"></a>MVVM实现-数据驱动视图-发布订阅管理器</h2><blockquote><p>目前响应式数据有了, 编译模板也有了, 我们需要在数据变化的时候编译模板</p><p>之前讲了, 这一步需要 通过发布订阅来做 ,所以我们在Vue的基础上实现发布订阅</p></blockquote><pre class="line-numbers language-js"><code class="language-js">        <span class="token comment" spellcheck="true">// 手写一个mvvm 简易版的vuejs</span>        <span class="token comment" spellcheck="true">// options就是选项 所有vue属性都带$</span>        <span class="token keyword">function</span> Vue <span class="token punctuation">(</span>options<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 事件管理器</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$options <span class="token operator">=</span> options  <span class="token comment" spellcheck="true">// 放置选项</span>           <span class="token keyword">this</span><span class="token punctuation">.</span>$el <span class="token operator">=</span> <span class="token keyword">typeof</span> options<span class="token punctuation">.</span>el <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">?</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">:</span> options<span class="token punctuation">.</span>el           <span class="token comment" spellcheck="true">// 将dom对象赋值给$el 和官方vuejs保持一致</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>$data <span class="token operator">=</span> options<span class="token punctuation">.</span>data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">//  数据代理 希望 vm能够代理 $data的数据 </span>         <span class="token comment" spellcheck="true">// 希望 vm.name 就是$data.name</span>         <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$proxyData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 代理数据  把$data中数据 代理给vm实例</span>         <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$observer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 数据劫持  劫持 $data中的数据变化</span>         <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$compile</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$el<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 模板第一次编译渲染 递归的要求 这里必须传入参数 </span>         <span class="token comment" spellcheck="true">// 递归是一种简单的算法 => 一般用在处理树形数据,嵌套数据 中国/北京/海淀/中关村/知春路/海淀桥/982/人</span>         <span class="token comment" spellcheck="true">// 递归其实就是函数自身调用自身 => 传入下一次递归的条件 => 两次递归条件一样 => 死循环了</span>        <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// Vue的发布订阅管理器 $on $emit </span>      <span class="token comment" spellcheck="true">//  监听事件</span>      Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$on <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>eventName<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">//   事件名 => 回调函数  => 触发某个事件的时候 找到这个事件对应的回调函数 并且执行</span>        <span class="token comment" spellcheck="true">//  if(this.subs[eventName]) {</span>        <span class="token comment" spellcheck="true">//      this.subs[eventName].push(fn)</span>        <span class="token comment" spellcheck="true">//  }else {</span>        <span class="token comment" spellcheck="true">//      this.subs[eventName] = [fn]</span>        <span class="token comment" spellcheck="true">//  }</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">[</span>eventName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">[</span>eventName<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">[</span>eventName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 触发事件</span>  Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$emit <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>eventName<span class="token punctuation">,</span> <span class="token operator">...</span>params<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//  拿到了事件名 应该去我们的开辟的空间里面 找有没有回调函数</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">[</span>eventName<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//   有人监听你的事件</span>            <span class="token comment" spellcheck="true">// 调用别人的回调函数</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">[</span>eventName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>fn <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 改变this指向</span>               <span class="token comment" spellcheck="true">//  fn(...params) // 调用该回调函数 并且传递参数</span>                 <span class="token comment" spellcheck="true">// 三种方式 改变回调函数里的this指向</span>               <span class="token comment" spellcheck="true">//   fn.apply(this, [...params]) // apply 参数 [参数列表]</span>              <span class="token comment" spellcheck="true">//  fn.call(this, ...params) // 若干参数</span>               fn<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>params<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// bind用法 bind并不会执行函数 而是直接将函数this改变</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MVVM实现-数据变化时-驱动视图变化"><a href="#MVVM实现-数据变化时-驱动视图变化" class="headerlink" title="MVVM实现-数据变化时 驱动视图变化"></a>MVVM实现-数据变化时 驱动视图变化</h2><blockquote><p>现在万事俱备,只欠东风</p><p>我们的数据代理,数据劫持,模板编译, 事件发布订阅统统搞定 现在只需要在数据变化时 ,通过事件发布,然后</p><p>通知 数据进行编译即可</p></blockquote><pre class="line-numbers language-js"><code class="language-js">        <span class="token comment" spellcheck="true">// 数据劫持</span>        Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$observer <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 要劫持谁 ? $data</span>            <span class="token comment" spellcheck="true">// 遍历 $data中的所有key</span>            Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// 劫持 =>劫持数据的变化 -> 监听 data中的数据的变化 => set方法</span>               <span class="token comment" spellcheck="true">// obj / prop / desciptor</span>               <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 重新开辟一个空间  value的空间</span>               Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">// 描述 => 描述符有几种 ? 数据描述符(value,writable) 存取描述符 (get/set)</span>                   <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token keyword">return</span> value                   <span class="token punctuation">}</span><span class="token punctuation">,</span>                   <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                      <span class="token keyword">if</span><span class="token punctuation">(</span>newValue <span class="token operator">===</span> value<span class="token punctuation">)</span> <span class="token keyword">return</span>                       value <span class="token operator">=</span> newValue                    <span class="token comment" spellcheck="true">//   一旦进入set方法 表示 MVVM中的 M 发生了变化  data变化了</span>                    <span class="token comment" spellcheck="true">// MVVVM => Model =>  发布订阅模式  => 更新Dom视图</span>                      <span class="token comment" spellcheck="true">// 整体编译只执行一次 通过发布订阅模式来做 触发一个事件 视图层监听一个事件</span>                     <span class="token comment" spellcheck="true">// 触发一个事件</span>                     <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 把属性当成事件名 触发一个事件</span>                   <span class="token punctuation">}</span>               <span class="token punctuation">}</span><span class="token punctuation">)</span>             <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>监听数据改变</p></blockquote><pre class="line-numbers language-js"><code class="language-js">    <span class="token comment" spellcheck="true">// 编译模板 数据发生变化  => 模板数据更新到最新</span>       <span class="token comment" spellcheck="true">// 编译模板的一个总方法 构造函数执行时执行</span>        <span class="token comment" spellcheck="true">// rootnode是传入本次循环的根节点 => 找rootnode下所有的子节点 => 子节点 => 子节点=> 子节点 > 子节点 ...  找到没有子节点为止</span>       Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$compile <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>rootnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">let</span> nodes <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>rootnode<span class="token punctuation">.</span>childNodes<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 是一个伪数组 将伪数组转成真数组</span>         nodes<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>node <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//  循环每个节点 判断节点类型 如果你是文本节点 就要用文本节点的处理方式 如果元素节点就要元素节点的处理方式</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$isTextNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果是文本节点</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$compileTextNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 处理文本节点 当前的node不再有 子节点 没有必要继续找了</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$isElementNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果是元素节点</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$compileElementNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 处理元素节点</span>                <span class="token comment" spellcheck="true">// 如果是元素节点 下面一定还有子节点 只有文本节点才是终点</span>                <span class="token comment" spellcheck="true">// 递归了 => 自身调用自身</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$compile</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 传参数 保证一层一层找下去 找到 node.chidNodes的长度为0的时候 自动停止</span>                <span class="token comment" spellcheck="true">// 可以保证 把 $el下的所有节点都遍历一遍</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span>       <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 处理文本节点 nodeType =3</span>       Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$compileTextNode <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// console.log(node.textContent)</span>            <span class="token comment" spellcheck="true">// 拿到文本节点内容之后 要做什么事情 {{ name }}  => 真实的值 </span>            <span class="token comment" spellcheck="true">// 正则表达式 </span>            <span class="token keyword">const</span> text <span class="token operator">=</span> node<span class="token punctuation">.</span>textContent <span class="token comment" spellcheck="true">// 拿到文本节点的内容 要看一看 有没有插值表达式</span>             <span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token operator">/</span>\<span class="token punctuation">{</span>\<span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">+</span><span class="token operator">?</span><span class="token punctuation">)</span>\<span class="token punctuation">}</span>\<span class="token punctuation">}</span><span class="token operator">/</span>g  <span class="token comment" spellcheck="true">// 将匹配所有的 {{ 未知内容 }}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果能匹配 说明 此时这个文本里有插值表达式</span>                 <span class="token comment" spellcheck="true">// 表示 上一个匹配的正则表达式的值</span>                <span class="token keyword">const</span> key <span class="token operator">=</span> RegExp<span class="token punctuation">.</span>$<span class="token number">1</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// name属性 => 取name的值 $1取的是第一个的key</span>                 node<span class="token punctuation">.</span>textContent <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span>  <span class="token keyword">this</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token punctuation">)</span>                   <span class="token comment" spellcheck="true">// 获取属性的值 并且替换 文本节点中的插值表达式</span>                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 如果 key这个属性所代表的值发生了变化 回调函数里更新视图</span>                    node<span class="token punctuation">.</span>textContent <span class="token operator">=</span> text<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 把原来的带大括号的内容替换成最新值 赋值给textContent</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 处理元素节点 nodeType = 1的时候是元素节点</span>       Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$compileElementNode <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 指令 v-text  v-model  => 数据变化  => 视图更新 更新数据变化 </span>           <span class="token comment" spellcheck="true">// v-text = '值' => innerText上  textContent</span>           <span class="token comment" spellcheck="true">// 拿到该node所有的属性 </span>          <span class="token keyword">let</span> attrs <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>attributes<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 把所有的属性转化成数组</span>        <span class="token comment" spellcheck="true">// 循环每个属性  属性是否带 v- 如果带 v- 表示指令</span>            attrs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>attr <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$isDirective</span><span class="token punctuation">(</span> attr<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//   判断指令类型</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>attr<span class="token punctuation">.</span>name <span class="token operator">===</span> <span class="token string">'v-text'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// v-text的指令的含义是 v-text后面的表达的值 作用在 元素的innerText或者textContent上</span>                      node<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">// 赋值 attr.value => v-text="name"</span>                      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                        node<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">//此时数据已经更新</span>                      <span class="token punctuation">}</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>attr<span class="token punctuation">.</span>name <span class="token operator">===</span> <span class="token string">'v-model'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 表示我要对当前节点进行双向绑定</span>                      node<span class="token punctuation">.</span>value <span class="token operator">=</span>  <span class="token keyword">this</span><span class="token punctuation">[</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">// v-model要给value赋值 并不是textContent</span>                      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                        node<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">//此时数据已经更新</span>                      <span class="token punctuation">}</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span>               <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 如果以 v-开头表示 就是指令</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>然后我们写个例子来测试一把</p></blockquote><h2 id="MVVM实现-视图变化更新数据"><a href="#MVVM实现-视图变化更新数据" class="headerlink" title="MVVM实现-视图变化更新数据"></a>MVVM实现-视图变化更新数据</h2><blockquote><p>最后我们希望实现双向绑定,即视图改变时 数据同时变化</p></blockquote><pre class="line-numbers language-js"><code class="language-js">       <span class="token comment" spellcheck="true">// 处理元素节点 nodeType = 1的时候是元素节点</span>       Vue<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$compileElementNode <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 指令 v-text  v-model  => 数据变化  => 视图更新 更新数据变化 </span>           <span class="token comment" spellcheck="true">// v-text = '值' => innerText上  textContent</span>           <span class="token comment" spellcheck="true">// 拿到该node所有的属性 </span>          <span class="token keyword">let</span> attrs <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>attributes<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 把所有的属性转化成数组</span>        <span class="token comment" spellcheck="true">// 循环每个属性  属性是否带 v- 如果带 v- 表示指令</span>            attrs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>attr <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$isDirective</span><span class="token punctuation">(</span> attr<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//   判断指令类型</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>attr<span class="token punctuation">.</span>name <span class="token operator">===</span> <span class="token string">'v-text'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// v-text的指令的含义是 v-text后面的表达的值 作用在 元素的innerText或者textContent上</span>                      node<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">// 赋值 attr.value => v-text="name"</span>                      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                        node<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">//此时数据已经更新</span>                      <span class="token punctuation">}</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>attr<span class="token punctuation">.</span>name <span class="token operator">===</span> <span class="token string">'v-model'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 表示我要对当前节点进行双向绑定</span>                      node<span class="token punctuation">.</span>value <span class="token operator">=</span>  <span class="token keyword">this</span><span class="token punctuation">[</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">// v-model要给value赋值 并不是textContent</span>                      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$on</span><span class="token punctuation">(</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                        node<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">//此时数据已经更新</span>                      <span class="token punctuation">}</span><span class="token punctuation">)</span>                      node<span class="token punctuation">.</span>oninput <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//   需要把当前最新的节点的值 赋值给 本身的数据</span>                        <span class="token keyword">this</span><span class="token punctuation">[</span>attr<span class="token punctuation">.</span>value<span class="token punctuation">]</span> <span class="token operator">=</span>  node<span class="token punctuation">.</span>value  <span class="token comment" spellcheck="true">// 视图 发生 => 数据发生变化</span>                      <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 如果一个元素绑定了v-model指令 应该监听这个元素的值改变事件</span>                    <span class="token punctuation">}</span>               <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 如果以 v-开头表示 就是指令</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>介绍MVVM</p><p>数据  =&gt;  视图</p><p>视图  =&gt;  视图</p><p>Object.defineProperty   代理数据  劫持数据</p><p>this.$data  =&gt;  this</p><p>劫持数据 劫持  this.$data数据的修改 =&gt;  因为要在数据变化时 实现 视图的更新</p><p>Vue的响应式数据是怎么实现的? </p><p>Object.defineProperty  =&gt; 劫持了数据的set  =&gt; 发布订阅模式  =&gt; 通知对应的视图进行更新</p><p>Diff 算法 虚拟DOM   =&gt; 面试中 十有八九会问倒</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2020/03/31/test/"/>
      <url>/2020/03/31/test/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vscode-效率提升</title>
      <link href="/2020/03/01/vscode-xiao-lu-ti-sheng/"/>
      <url>/2020/03/01/vscode-xiao-lu-ti-sheng/</url>
      
        <content type="html"><![CDATA[<h1 id="vscode效率提升"><a href="#vscode效率提升" class="headerlink" title="vscode效率提升"></a>vscode效率提升</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="行-的操作："><a href="#行-的操作：" class="headerlink" title="行 的操作："></a><strong>行</strong> 的操作：</h3><blockquote><ul><li>重开一行：光标在行尾的话，回车即可；不在行尾，<code>Ctrl + enter</code> 向下重开一行；<code>shift + Ctrl + enter</code> 则是在上一行重开一行</li><li>删除一行：光标没有选择内容时，<code>ctrl + x</code> 剪切一行；<code>shift + Ctrl + k</code> 直接删除一行</li><li>移动一行：<code>alt + ↑</code> 向上移动一行；<code>alt + ↓</code> 向下移动一行</li><li>复制一行：<code>shift + alt + ↓</code> 向下复制一行；<code>shift + alt + ↑</code> 向上复制一行</li></ul></blockquote><h3 id="对于-词-的操作："><a href="#对于-词-的操作：" class="headerlink" title="对于 词 的操作："></a>对于 <strong>词</strong> 的操作：</h3><blockquote><ul><li><strong>选中一个词：<code>Ctrl + d</code></strong></li><li>跳转到单词起始位置<code>Ctrl + ←</code> </li><li>跳转到单词末尾位置<code>Ctrl  + →</code></li></ul></blockquote><h3 id="搜索或者替换："><a href="#搜索或者替换：" class="headerlink" title="搜索或者替换："></a>搜索或者替换：</h3><blockquote><ul><li><code>cmd + f</code> ：搜索</li><li><code>cmd + alt + f</code>： 替换</li><li><code>cmd + shift + f</code>：在项目内搜索</li></ul></blockquote><h3 id="格式调整"><a href="#格式调整" class="headerlink" title="格式调整"></a>格式调整</h3><blockquote><ul><li>代码行缩进C<code>trl+[， Ctrl+]   ,</code>或者<code>Tab , Shift+Tab</code></li><li><strong>折叠打开代码块 Ctrl+Shift+[， Ctrl+Shift+]</strong></li><li>Ctrl+C Ctrl+V如果不选中，默认复制或剪切一整行</li><li><strong>代码格式化：<code>Shift+Alt+F</code></strong></li></ul></blockquote><h3 id="同时打开多个编辑器（查看多个文件）"><a href="#同时打开多个编辑器（查看多个文件）" class="headerlink" title="同时打开多个编辑器（查看多个文件）"></a>同时打开多个编辑器（查看多个文件）</h3><blockquote><ul><li>新建文件 Ctrl+N</li><li>历史打开文件之间切换<code>Ctrl+Tab，Alt+Left，Alt+Right</code></li><li>切出一个新的编辑器（最多3个）Ctrl+\，也可以按住Ctrl鼠标点击Explorer里的文件名</li><li>左中右3个编辑器的快捷键Ctrl+1 Ctrl+2 Ctrl+3</li><li><strong>3个编辑器之间循环切换 Ctrl+`</strong></li><li><em>*编辑器换位置，Ctrl+k然后按Left或Right</em></li></ul></blockquote><h3 id="显示相关"><a href="#显示相关" class="headerlink" title="显示相关"></a><strong>显示相关</strong></h3><blockquote><ul><li>全屏：F11</li><li>放大效果：Ctrl +  / Ctrl  -</li><li>侧边栏显/隐：<code>Ctrl+B</code></li><li><strong>预览markdown <code>Ctrl+Shift+V</code></strong></li></ul></blockquote><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><blockquote><p>Ctrl + / –  行注释</p><p>Shift + Alt + A  – 注释选中内容</p></blockquote><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="Chinese-Simplified-Language-Pack-for-Visual-Studio-Code"><a href="#Chinese-Simplified-Language-Pack-for-Visual-Studio-Code" class="headerlink" title="Chinese (Simplified) Language Pack for Visual Studio Code"></a>Chinese (Simplified) Language Pack for Visual Studio Code</h3><blockquote><p>VS Code的中文（简体）语言包。安装后，同时按下Ctrl + Shift + P打开命令面板，之后输入”config”，配置显示语言即可。</p></blockquote><h3 id="Live-Server"><a href="#Live-Server" class="headerlink" title="Live Server"></a><code>Live Server</code></h3><blockquote><p>保存代码后自动刷新页面</p></blockquote><h3 id="Material-Theme"><a href="#Material-Theme" class="headerlink" title="Material Theme"></a>Material Theme</h3><blockquote><p>VS Code最受欢迎、最悠久的主题插件。</p></blockquote><h3 id="Material-Icon-Theme"><a href="#Material-Icon-Theme" class="headerlink" title="Material Icon Theme"></a><strong>Material Icon Theme</strong></h3><blockquote><p>文件管理器（左侧）的 icon 小图标</p></blockquote><h3 id="Markdown插件"><a href="#Markdown插件" class="headerlink" title="Markdown插件"></a>Markdown插件</h3><p><code>Markdown All in One</code></p><p><code>Markdown Preview Github Styling</code>  </p><blockquote><p>第一个插件，是一个组合包，一股脑把最常用的Markdown优化都给你装好；第二个插件，则是Github使用的Markdown渲染样式，不是特别华丽，很朴素，很简洁的样式，因为很多人用Markdown都是为了使用Github Pages，所以这个样式特别受欢迎。使用这个样式，在本地就能预览Markdown文件最终在Github Pages中显示的效果。 </p></blockquote><h2 id="设置代码片段"><a href="#设置代码片段" class="headerlink" title="设置代码片段"></a>设置代码片段</h2><h3 id="创建自己的代码片段"><a href="#创建自己的代码片段" class="headerlink" title="创建自己的代码片段"></a>创建自己的代码片段</h3><blockquote><p>为提高开发效率可创建自己的代码片段</p><p>1、点击设置，打开用户代码片段即可开始创建自己的代码片段；</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-预编译</title>
      <link href="/2020/02/22/javascript-yu-bian-yi/"/>
      <url>/2020/02/22/javascript-yu-bian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h1><h2 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h2><blockquote><p><code>imply globle</code> 暗示全局变量 :  未声明直接赋值的的变量归<code>window</code>所有 </p></blockquote><blockquote><p>一切声明的全局变量 , 全是<code>window</code>的属性.</p></blockquote><blockquote><p><code>window</code>就是全局的域</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//window  {</span><span class="token comment" spellcheck="true">//       a :123</span><span class="token comment" spellcheck="true">//}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>  <span class="token operator">===</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote><p>预编译发生在函数执行的前一刻</p><p>四部曲:</p><blockquote><ol><li><p>创建AO 对象 Activation Object (执行期上下文)</p></li><li><p>找形参和变量声明 , 将变量和形参名作为AO属性名,值为<code>undefined</code></p></li><li><p>将实参和形参统一</p></li><li><p>在函数体里面找函数声明, 值赋予函数体 </p></li></ol></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> fn <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//123</span>    <span class="token keyword">function</span> a <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//123 </span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//function</span>    <span class="token keyword">function</span> d <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><blockquote><p>预编译发生在全局执行的前一刻</p><p>三部曲</p><p>全局预编译    GO === window</p><ol><li>创建GO</li><li>变量名作为AO的属性名, 值为<code>undefined</code></li><li>在函数体里面找函数声明, 值赋予函数体 </li></ol></blockquote><pre class="line-numbers language-js"><code class="language-js">global <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>global<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//undefined</span>    global <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>global<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//200</span>    <span class="token keyword">var</span> global <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> global<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-正则表达式</title>
      <link href="/2020/02/18/javascript-zheng-ze-biao-da-shi/"/>
      <url>/2020/02/18/javascript-zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式-RegExp"><a href="#正则表达式-RegExp" class="headerlink" title="正则表达式(RegExp)"></a>正则表达式(RegExp)</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/abc/igm</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//字面量定义规则</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true   //正则表达式的方法 , 参数为字符串 , 如果符合则返回true</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//["abc"]  // 字符串的方法,参数为正则表达式 , 返回找到的字符串</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">"abc"</span> <span class="token punctuation">,</span> <span class="token string">"igm"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 构造函数定义规则</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>i</code> 忽略大小写</p><p><code>g</code> 全局匹配</p><p><code>m</code> 多行匹配</p><blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/^a/gm</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ^a 以a开头  g 全局查找  m 换行匹配</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"abc\na"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// `\n`表示换行 ,</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//["a", "a"]  //有m则返回两个a , 去掉则返回一个a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><p><code>^</code>以什么打头 如果放到 []里面则表示非</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/[^a]/</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//非a 查找不是a的单个字符</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token regex">/abc/</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ["b"]   如果加上 g 则返回["b" , "c"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>()</code>优先计算     子表达式    会把括号中匹配的信息也返回</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/(abc|bcd)/</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//匹配abc或者bcd</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>$</code> 以什么结尾</p></blockquote></blockquote><h2 id="表达式-和-元字符"><a href="#表达式-和-元字符" class="headerlink" title="表达式 和 元字符"></a>表达式 和 元字符</h2><blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/[能取到的范围]/</span><span class="token punctuation">;</span> \w <span class="token operator">===</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span>9A<span class="token operator">-</span>z_<span class="token punctuation">]</span> \W <span class="token operator">===</span>\w\s <span class="token comment" spellcheck="true">//空白字符 空格 \n换行符  \f换页符  \r回车符  \t制表符 \v垂直制表符</span>\S <span class="token comment" spellcheck="true">//非空白字符  </span>\d  <span class="token operator">===</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span>\D  <span class="token comment" spellcheck="true">//非数字</span>\b  <span class="token comment" spellcheck="true">//单词边界</span>\B  <span class="token comment" spellcheck="true">//非单词边界</span><span class="token comment" spellcheck="true">//存在字符\w和\W相邻,那么这两个字符之间就有单词边界 , 包括字符串首尾</span>    <span class="token keyword">var</span> str6 <span class="token operator">=</span> <span class="token string">"abc_d,123中文_d3=efg汉字a"</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> reg6 <span class="token operator">=</span> <span class="token regex">/[\d\D]\b/g</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str6<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg6<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//["d", ",", "3", "文", "3", "=", "g", "字", "a"]  // 匹配的是 右边存在单词边界的字符</span> <span class="token punctuation">.</span>  <span class="token operator">===</span> <span class="token punctuation">[</span><span class="token operator">^</span>\r\n<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">//非回车换行符的任意字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><blockquote><p><code>+</code>  一次以上 <code>{1,}</code></p><p><code>*</code> 任意次   <code>{0,}</code></p><p><code>?</code>  0 个 或 1个 <code>{0,1}</code></p><p>默认贪婪匹配 量词后边 用 <code>?</code>修饰表示非贪婪</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><blockquote><p><code>reg.exec();</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/ab/g</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 不加 g lastIndex不会变 , 每次匹配的都是第一个ab</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"abababab"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[ab] //第一个ab  reg.lastIndex 变为2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[ab] //从游标为2的地方匹配第二个ab   reg.lastIndex 变为4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><blockquote><p><code>str.split(reg)</code>    – 按正则表达式拆分字符串</p><p><code>str.replace</code></p><pre class="line-numbers language-js"><code class="language-js">str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span>  <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//把字符串中找到的第一个 a 替换成 b</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/a/g</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg <span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这样可以实现把所有的 a 替换成 b 如果把 g 去掉 也只能替换第一个 a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>str.toUpperCase()</code>  //把字符串 str中的字母全变成大写</p><p><code>str.toLowerCase()</code> //字符串字母变小写</p></blockquote><h2 id="正向预查-或者-正向断言"><a href="#正向预查-或者-正向断言" class="headerlink" title="正向预查  或者  正向断言"></a>正向预查  或者  正向断言</h2><blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"abaaaa"</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/a(?=b)/g</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// (?=b)不参与选择 , 只参与限定 限定 a 的后边要跟着b </span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/a(?!b)/g</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// (?=b)不参与选择 , 只参与限定 限定 a 的后边不是 b </span>str<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ["a"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><blockquote><p>检验字符串首尾是否含有数字</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/^\d | \d$/</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>匹配四个重复值</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/(\w)\1\1\1/g</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// \1 引用第一个表达式中匹配的值  \2 就是第二个 依次类推</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把 <code>aabb</code> 这种形式的字符串反过来变成 <code>bbaa</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"aabb"</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg  <span class="token operator">=</span> <span class="token regex">/(\w)\1(\w)\2/g</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg <span class="token punctuation">,</span> <span class="token string">"$2$2$1$1"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这里如果就是要替换成 $ 的话 要写 $$ ,类似于转义</span><span class="token comment" spellcheck="true">//另外的方法</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/(\w)\1(\w)\2/g</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>$ <span class="token punctuation">,</span> $<span class="token number">1</span> <span class="token punctuation">,</span> $<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//三个参数一次接收 整个表达式返回结果 , 第一个子表达式结果 , 第二个子表达式结果</span>    <span class="token keyword">return</span> $<span class="token number">2</span> <span class="token operator">+</span> $<span class="token number">2</span> <span class="token operator">+</span> $<span class="token number">1</span> <span class="token operator">+</span> $<span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把 // the-first-name 变成小驼峰命名式 // theFirstName</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"the-first-name"</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/-(\w)/g</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>$ <span class="token punctuation">,</span> $<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> $<span class="token number">1</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串去重</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"aaaabbbccc"</span><span class="token punctuation">;</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token regex">/(\w)\1*/g</span><span class="token punctuation">;</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token string">"$1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把 1000000 变成 1.000.000</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"1000000"</span><span class="token keyword">var</span> reg <span class="token operator">=</span> <span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">=</span><span class="token punctuation">(</span>\B<span class="token punctuation">)</span><span class="token punctuation">(</span>\d<span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">+</span>$<span class="token punctuation">)</span><span class="token operator">/</span>g  <span class="token comment" spellcheck="true">//匹配后边跟的是一个非单词边界和3的倍数个数字的空白字符</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS定时器</title>
      <link href="/2020/02/13/javascript-ding-shi-qi/"/>
      <url>/2020/02/13/javascript-ding-shi-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><blockquote><p>都是全局对象window上的方法 , 内部函数this指向window</p><p>注意:</p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token string">"console.log('a');"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//每隔1000毫秒会打印一次字符串a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><blockquote><p>设置循环定时器</p><p><code>setInterval</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 定时器时间不准</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>清除循环定时器</p><p><code>clearInterval</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">clearInterval</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>设置单次执行定时器</p><p><code>setTimeout</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//延时1000毫秒执行,只执行一次</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>清除单次执行定时器</p><p><code>clearTimeout</code></p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScripe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript模式</title>
      <link href="/2020/02/05/javascript-mo-shi/"/>
      <url>/2020/02/05/javascript-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript模式"><a href="#JavaScript模式" class="headerlink" title="JavaScript模式"></a>JavaScript模式</h1><h2 id="for循环优化"><a href="#for循环优化" class="headerlink" title="for循环优化"></a>for循环优化</h2><blockquote><p>每次访问数组的长度是非常耗时的 , 所以我们将已经遍历过的数组或容器的长度缓存起来,如以下代码//</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>max <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i <span class="token operator">&lt;</span> max <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//对arr进行处理    </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>第二种 : 使用最少的变量 , 逐步减至0</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> i <span class="token punctuation">,</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//省略第三个参数,通过用 i-- 至 0 来终止循环</span>    <span class="token comment" spellcheck="true">//处理arr</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//while循环实现</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//梳理arr[i]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>我们提倡用正常的for循环来处理数组 , 用for - in 循环来处理对象</p></blockquote><h2 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h2><blockquote><p>Object的<code>hasOwnProperty()</code>方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。 </p></blockquote><pre class="line-numbers language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//查看person对象是否包含自身(非继承)属性 : name;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="圣杯模式"><a href="#圣杯模式" class="headerlink" title="圣杯模式"></a>圣杯模式</h2><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">inherit</span><span class="token punctuation">(</span>Target<span class="token punctuation">,</span>Origin<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">function</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//定义一个空方法</span>    F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Origin<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//让空方法的原型等于父亲的原型</span>    Target<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//需要实现继承的方法的原型指向 new F();  -- 这样就实现了对象值传递</span>    Target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constuctor <span class="token operator">=</span> Target<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果不更改构造器的话,Target的构造器会指向Origin , 所以手动更改指向为自身</span>    Target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>uber <span class="token operator">=</span> Origin<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//添加 uber 属性指明真实继承自哪里</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>利用闭包实现变量私有化</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> inherit <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> F <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//利用闭包特性隐藏此方法</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>Target <span class="token punctuation">,</span> Origin<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//在立即执行函数中 return 此方法形成闭包</span>        F<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Origin<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>        Target<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constuctor <span class="token operator">=</span> Target<span class="token punctuation">;</span>        Target<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>uber <span class="token operator">=</span> Origin<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><blockquote><p><code>instanceof</code> A 对象 是不是 B 构造函数构造出来的</p></blockquote><pre class="line-numbers language-js"><code class="language-js">A <span class="token keyword">instanceof</span> <span class="token class-name">B</span><span class="token comment" spellcheck="true">// 看A对象的原型链上 有没有 B 的原型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="区分数组还是对象"><a href="#区分数组还是对象" class="headerlink" title="区分数组还是对象"></a>区分数组还是对象</h2><blockquote><p>通过<code>constructor</code> 构造器来区分</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// function Array(){};</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// function Object(){};</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>instanceof</code></p></blockquote><pre class="line-numbers language-js"><code class="language-js">arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><code>toString</code></p></blockquote><pre class="line-numbers language-js"><code class="language-js">Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "[object Array]"</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "[object Object]"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>ES 5 新增 <code>Array.isArray([]); //true</code>  参数为数组时返回 <code>true</code></p></blockquote><h2 id="命名模式"><a href="#命名模式" class="headerlink" title="命名模式"></a>命名模式</h2><blockquote><p>构造函数首字母大写</p><p>函数名是多个单词的时候 , 构造函数使用大驼峰命名法 , 普通函数使用小驼峰命名法</p><p>变量是多个单词 , 使用小写用<code>_</code>隔开 ,  或者也使用小驼峰命名法</p><p>使用全部大写的方式表示一个常量 , 来表示不要进行修改 , 或者通过全部大写来表示全局变量</p><p>使用下划线前缀声明私有函数[方法] 和 属性.</p></blockquote><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><blockquote><p>当以<code>new</code>操作符调用构造函数时 , 函数内部将会发生以下情况 : </p><ol><li>创建一个空对象并且<code>this</code>变量引用了该对象 , 同时还继承了该函数的原型.</li><li>属性和方法被加入到<code>this</code>引用的对象中.</li><li>新创建的对象由<code>this</code>所引用 , 并且最后隐式地返回<code>this</code> (如果没有显式的返回其他对象).</li></ol><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//以上情况看起来就像是在后台发生了如下事情: </span><span class="token keyword">var</span> Person <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> <span class="token keyword">this</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用对象字面量模式创建一个新对象</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 向this添加属性和方法</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="arguments-callee"><a href="#arguments-callee" class="headerlink" title="arguments.callee"></a>arguments.callee</h2><blockquote><p>指向函数自身的引用</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> test <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>argument<span class="token punctuation">.</span>callee<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//test 这个函数本身</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h2><blockquote><p>被调用环境的引用</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> test <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> demo <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>demo<span class="token punctuation">.</span>caller<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// test这个函数自身</span><span class="token punctuation">}</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="clone-复制-浅拷贝-深拷贝"><a href="#clone-复制-浅拷贝-深拷贝" class="headerlink" title="clone - 复制-浅拷贝-深拷贝"></a>clone - 复制-浅拷贝-深拷贝</h2><blockquote><p>clone - 浅拷贝</p></blockquote><pre class="line-numbers language-js"><code class="language-js">   <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>       name <span class="token punctuation">:</span> <span class="token string">"zhanglei"</span><span class="token punctuation">,</span>       age <span class="token punctuation">:</span> <span class="token number">18</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token keyword">function</span> <span class="token function">clone</span><span class="token punctuation">(</span>origin <span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">var</span> target <span class="token operator">=</span> target <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果传入了target则使用target,否则使用{}</span>       <span class="token keyword">for</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> origin<span class="token punctuation">)</span> <span class="token punctuation">{</span>            target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> origin<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> target<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token function">clone</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>clone - 深拷贝</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>    name<span class="token punctuation">:</span> <span class="token string">"zhanglei"</span><span class="token punctuation">,</span>    age<span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">,</span>    hobby<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//空对象</span><span class="token comment" spellcheck="true">// 通过函数实现 , 把对象 a 中的所有的数据深拷贝到 b 中</span><span class="token keyword">function</span> extend <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//先获取 a 对象中每个属性的值</span>        <span class="token keyword">var</span> item <span class="token operator">=</span> a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//判断这个属性的值是不是数组</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>item instenceof Array<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果是数组 , 那么在 b 对象中添加一个新的属性,并且这个属性值也是数组</span>            b<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//调用这个方法, 把 a 对象中这个数组的属性一个一个的复制到 b 对象的这个数组属性中</span>            <span class="token function">extend</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>b<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>item instenceof Object<span class="token punctuation">)</span><span class="token punctuation">{</span>            b<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token function">extend</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> b<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果是普通的数据 , 直接复制到 b 对象的这个属性中</span>            b<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">extend</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组中的常用方法"><a href="#数组中的常用方法" class="headerlink" title="数组中的常用方法"></a>数组中的常用方法</h2><h3 id="改变原数组"><a href="#改变原数组" class="headerlink" title="改变原数组"></a>改变原数组</h3><blockquote><p><code>push</code> 从后边添加,并返回添加后的数组长度,可以添加多个,用<code>,</code>隔开</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,2,3]</span><span class="token comment" spellcheck="true">//手写push方法</span>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>push <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>pop</code>把数组的最后一位剪切出来.返回剪切的值,和<code>push</code>相对应</p><p><code>shift</code>从前边减</p><p><code>unshift</code> 从前边加</p><p><code>sort</code>排序 , 默认按照 ASCII码排序  视频第27个 ,时间50分钟</p><pre class="line-numbers language-js"><code class="language-js"><span class="token comment" spellcheck="true">//1. 必须写俩形参</span><span class="token comment" spellcheck="true">//2. 看返回值</span>    <span class="token comment" spellcheck="true">//1.当返回值为负数时,那么前面的数放在前面</span>    <span class="token comment" spellcheck="true">//2.为正数 , 那么后面的数在前</span>    <span class="token comment" spellcheck="true">//3.为0 . 不动</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//return a - b; 升序</span>    <span class="token comment" spellcheck="true">//return b - a; 降序</span>    <span class="token comment" spellcheck="true">//return Math.random() - 0.5; 打乱顺序</span>    <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,3,4,5,10];</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>reverse</code> 翻转顺序</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [3,2,1]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>splice</code> 切片</p><blockquote><p>参数: 从第几位开始 , 截取多少长度 , 在切口处添加数据</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,2,3,4,5]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h3 id="不改变原数组"><a href="#不改变原数组" class="headerlink" title="不改变原数组"></a>不改变原数组</h3><blockquote><p><code>concat</code> 连接两个数组</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,2,3,4]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>join</code>数组转换成字符串</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">var</span> str <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>str<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//"1-2-3";</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>split</code>字符串的方法,把字符串按照参数拆分成数组,与<code>join</code>互逆</p><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"1-2-3"</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>arr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//["1","2","3"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>toString</code></p><p><code>slice</code></p><blockquote><p>参数1  从该位开始截取</p><p>参数2  截取到该位</p><blockquote><p>不写第二个参数 , 则截取到最后</p><p>不写参数,则整个截取</p></blockquote></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newArr<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[2,3]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt"></a>charCodeAt</h2><blockquote><p>作用：返回指定位置的字符的Unicode编码。这个返回值在0~65535之间的整数。</p><p>可以判断返回值是否大于255,来判断时候是中文 </p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"zl张磊"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">retBytes</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> mun <span class="token operator">=</span> str<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">chatCodeAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           num<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">reBytes</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><blockquote><p>看起来像数组 , 但是不具有数组操作的一些方法  视频第28个 </p><p>DOM元素全是类数组</p></blockquote><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><blockquote><p>利用对象 , 让数组的值为对象的属性名循环添加属性,最后取出对象名就可以</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span>max <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>max<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    obj<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>    arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 添加到数组的原型方法中</span>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>unique <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> obj <span class="token operator">=</span>  <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//声明一个空对象用来存放</span>        arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//声明一个空数组</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           obj<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><blockquote><p>把原始值包装成对象</p><p>原始值本身没有属性 , 但是原始值调用属性时会 根据原始值类型 </p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 实际执行是: `new String('abc').length` 执行完之后就会进行删除</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Object-create-创建对象"><a href="#Object-create-创建对象" class="headerlink" title="Object.create() - 创建对象"></a>Object.create() - 创建对象</h2><blockquote><p>Object.create(prototype, definedProperty);</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> demo <span class="token operator">=</span> <span class="token punctuation">{</span>    name <span class="token operator">=</span> <span class="token string">"张磊"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> Objgect<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>demo<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 创建一个空对象 , 对象的原型就是`demo` , 并返回</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>一旦经历了<code>var</code>的操作 , 所得出的属性 , window ,这种属性叫做不可配置的属性(不能delete)</p><p>形参也相当于是<code>var</code>声明的变量</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">var</span> mun <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">delete</span> mun<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span>window<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">delete</span> num<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>视频第30个 , 15分</p><blockquote><ol><li>预编译 <code>this</code>指向<code>window</code></li><li>谁调用的 <code>this</code>就指向谁</li><li><code>call</code> <code>apply</code> 改变<code>this</code>指向</li><li>全局 中  <code>this</code> 指向 <code>window</code></li></ol></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token keyword">function</span> Person <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> Student <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> sex<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//隐式把函数的原型赋值给this</span>    <span class="token comment" spellcheck="true">//var this = Object.create(Student.prototype);</span>    Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span>   <span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 改变Person的this指向调用Person</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>a 函数中包含 b 函数 , 只要 b 函数被返回到 a 函数的外边 , 就会形成闭包 , b 就会拿到 a 的执行上下文</p></blockquote><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><blockquote><ol><li>变量和形参声明提升</li><li>形参和实参相统一</li><li>函数声明提升 - 函数名作为属性名,函数体作为属性值</li><li>函数执行 - 预编译过得语句将会跳过执行 </li></ol></blockquote><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try {} catch {} finally {}"></a>try {} catch {} finally {}</h2><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><blockquote><ol><li>EvalError : eval() 的使用与定义不一致</li><li>RangeError :数值越界</li><li>ReferenceError :非法或不能识别的引用数值</li><li>SyntaxError : 发生语法解析错误</li><li>TypeError : 操作数类型错误</li><li>URLError : URL 处理函数使用不当</li></ol></blockquote><h2 id="es-5-严格模式"><a href="#es-5-严格模式" class="headerlink" title="es 5 严格模式"></a>es 5 严格模式</h2><blockquote><p>如果使用<code>es5</code>严格模式, name<code>es3</code> 和     <code>es5</code> 产生的冲突部分就用<code>es5</code> , 否则会用<code>es3</code></p></blockquote><blockquote><p>启用方式 : </p><p><code>&quot;use strict&quot;</code></p><blockquote><p>变量必须声明</p><p>局部方法预编译的时候里面的<code>this</code>不再指向<code>window</code> , 必须被赋值<code>new</code> 或者<code>.call</code></p><p>拒绝重复的属性和参数</p></blockquote><blockquote><p>为什么使用字符串, 而不是用方法调用呢?</p><blockquote><p>为了兼容老版本浏览器, 因为直接写<code>es5</code> 的方法会报错 , 而字符串老版本不能识别的情况下也不会报错</p></blockquote></blockquote></blockquote><h3 id="with"><a href="#with" class="headerlink" title="with(){}"></a>with(){}</h3><blockquote><p>改变作用域链最顶端 , 找变量最先往这里找, 简化代码</p></blockquote><pre class="line-numbers language-ja"><code class="language-ja">document.write("a");with(document){    write("a"); // 在with里边就可以直接写write了.}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>修改原型链如果原型链很长会整个修改, 影响效率 <code>es5</code>不能使用 ,</p><p><code>arguments</code> 的一些属性和方法 :  <code>caller</code> <code>callee</code> 也不可以在<code>es 5</code> 严格模式下使用</p></blockquote><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><blockquote><p>能把字符串当成代码执行</p></blockquote><pre class="line-numbers language-js"><code class="language-js"><span class="token function">eval</span><span class="token punctuation">(</span>'console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器音乐插件 - Listen 1</title>
      <link href="/2020/01/31/yin-le-cha-jian/"/>
      <url>/2020/01/31/yin-le-cha-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="Listen-1-Chrome-Extension-V2-5-1"><a href="#Listen-1-Chrome-Extension-V2-5-1" class="headerlink" title="Listen 1 (Chrome Extension) V2.5.1"></a>Listen 1 (Chrome Extension) V2.5.1</h1><p>（最后更新于2019年09月07日）</p><p><a href="LICENSE"><img src="https://img.shields.io/badge/license-MIT-brightgreen.svg" alt="Software License"></a></p><p><a href="https://github.com/listen1/listen1_chrome_extension/blob/master/README_EN.md" target="_blank" rel="noopener">English Version</a></p><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>当我发现找个想听的歌因为版权听不了，需要打开好几个网站开始搜索，来回切换让我抓狂的时候，我知道是时候该做点什么了。</p><p>妈妈再也不用担心我找不到我想听的歌了。这里包含了网易云音乐，虾米，QQ音乐, 酷狗音乐，酷我音乐的曲库，够全够大了吧。</p><p>搜歌，听歌，就用 <code>Listen1</code>。</p><p>还有精选歌单哦。</p><h2 id="Chrome安装"><a href="#Chrome安装" class="headerlink" title="Chrome安装"></a>Chrome安装</h2><ol><li>下载项目的zip文件，<a href="https://pan.baidu.com/s/1UAbIrSmP5cOX4SX85pq0kQ" target="_blank" rel="noopener">点击下载</a> , 提取码 : <code>jj9q</code>解压到本地</li><li>chrome右上角的设置按钮下找到更多工具，打开<code>扩展程序</code></li><li>选择 <code>加载已解压的扩展程序</code>(如果没有显示先选中<code>开发者模式</code>)，选中解压后的文件夹，完成！</li></ol><h2 id="Firefox打包安装"><a href="#Firefox打包安装" class="headerlink" title="Firefox打包安装"></a>Firefox打包安装</h2><h3 id="打包xpi文件（或在release页面下载已经打包好的xpi文件）"><a href="#打包xpi文件（或在release页面下载已经打包好的xpi文件）" class="headerlink" title="打包xpi文件（或在release页面下载已经打包好的xpi文件）"></a>打包xpi文件（或在release页面下载已经打包好的xpi文件）</h3><ol><li>将根目录下manifest_firefox.json替换manifest.json</li><li><code>cd listen1_chrome_extension</code></li><li><code>zip -r ../listen1.xpi *</code></li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>打开Firefox，加载xpi文件，完成安装</li></ol><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p><code>2019-09-07</code></p><ul><li>修复migu无法播放的bug</li></ul><p><code>2019-08-09</code></p><ul><li>增加深色主题</li></ul><p><code>2019-07-03</code></p><ul><li>修复咪咕音乐无法播放的bug</li></ul><p><code>2019-06-24</code></p><ul><li>增加咪咕音乐</li><li>修复网易音乐无法播放的bug</li><li>修复酷狗音乐无法播放的bug</li></ul><p><code>2019-06-23</code></p><ul><li>修复无法连接到github的bug</li></ul><p><code>2019-05-26</code></p><ul><li>修复酷狗音乐无法播放的bug</li></ul><p><code>2019-04-26</code></p><ul><li>修复虾米音乐无法播放的bug</li><li>修复播放器未在页面底端显示的bug</li></ul><p><code>2019-03-03</code></p><ul><li>修复删除单个歌曲导致歌单所有歌曲消失的bug</li><li>修复删除单个歌单导致所有歌单消失的bug</li></ul><p><code>2019-02-26</code></p><ul><li>修复qq音乐歌单无法显示的bug</li></ul>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript同步和异步</title>
      <link href="/2020/01/23/javascript-tong-bu-he-yi-bu/"/>
      <url>/2020/01/23/javascript-tong-bu-he-yi-bu/</url>
      
        <content type="html"><![CDATA[<h1 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h1><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><blockquote><p>所谓同步编程,就是计算机一行一行按顺序依次执行代码,是一种典型的请求-响应模型.</p><p>当前代码比较耗时会阻塞后续代码的执行,当请求调用一个函数或者方法后,需等待其响应返回,然后执行后续代码.</p></blockquote><p><strong>类似于生活中规范的排队,即使前面的人动作很慢,后面的人也要等着.</strong></p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><blockquote><p>一般情况下,同步编程,代码依次执行能很好的保证程序的执行,</p><p>但是在某些场景中,比如读取文件内容,或者请求服务器接口数据,这些请求需要根据返回的数据内容,来执行后续操作,</p><p>等待数据返回的时间中,JavaScript是不能处理页面交互,滚动等操作的,</p><p>所以需要异步编程来解决这个问题,JavaScript执行异步任务时,不需要等待响应返回,可以继续执行其他任务,</p><p>而在响应返回时,会得到通知,并执行回调或者事件处理程序.</p><p>CPU不用等待而继续执行,  其实是交给,硬盘,光驱,声卡,网卡,显卡这些硬件, 他们是可以不消耗CPU资源而自动与内存交换数据的，这也是实现异步的基本条件，当数据交互完成，会告诉CPU执行完了,再触发指定的回调函数</p><p>就像打游戏要买一块好的显卡,因为涉及到大量的I/O操作应该就是为了对CPU能力的补充</p><p>当处理CPU走不开的异步操作就要通过线程池开启一个新的线程去完成,就变成了多线程</p></blockquote><p><strong>类似于排队的人有的人没带钱,需要找朋友来帮他付钱,需要时间比较长,就让后面的人先买,等他朋友来了再付钱,朋友就类似于硬盘和显卡.</strong></p><blockquote><p>简单描述下线程池:</p><p>线程池：基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</p></blockquote><h1 id="单线程和多线程"><a href="#单线程和多线程" class="headerlink" title="单线程和多线程"></a>单线程和多线程</h1><blockquote><p>说道这里稍微提一下单线程和多线程,</p><p>单线程就可以理解为你自己排队买吃的.</p><p>多线程就是你这边在排队买东西,你想买很多东西,但是排一次队只能买一个,</p><p>但是买东西的窗口有很多个,你就让你朋友去帮你排队买另一个这就形成了多线程</p><p>线程就可以理解为买东西排的队伍.</p><p>把你比作一个程序的话,通过朋友你就实现了同时占用两个线程</p><p>如果地方足够大的话,你还可以让你的家人帮你排别的队伍.</p><p>买东西的地方就可以理解为CPU.</p><p>线程补充介绍 : <a href="https://blog.csdn.net/hr10230322/article/details/78642898" target="_blank" rel="noopener">点击链接</a></p></blockquote><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>多线程<ul><li>最大的问题在于线程本身的调度和运行需要很多的时间,因此不建议创建太大量的线程;</li><li>共享资源的调度比较难,涉及到<a href="https://blog.csdn.net/hd12370/article/details/82814348" target="_blank" rel="noopener">死锁</a>,上锁等相关的概念</li></ul></li><li>异步<ul><li>最大的问题在于回调,这增加了软件设计上的难度</li></ul></li></ul><blockquote><p>在实际设计时,我们可以将两者结合起来:</p><blockquote><p>当需要执行I/O操作时,使用异步操作比使用线程 + 同步I/O操作更合适</p><p>I/O操作不仅包括了直接的文件,网络的读写,还包括数据库操作,WebServer,HttpRequest以及.netRemoting等跨进程的调用</p><p>异步特别适用于大多数I/O密集型的应用程序</p></blockquote><blockquote><p>而线程的适用范围则是那种需要长时间CPU运算的场合,例如耗时较长的图形处理和算法执行</p><p>但是往往由于适用线程编程的简单和符合习惯,所以很多朋友往往会使用线程来执行耗时较长的I/O操作</p><p>这样在只有少数几个并发操作的时候还无伤大雅,如果需要处理大量的并发操作时就不合适了</p></blockquote></blockquote><h1 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h1><p><strong>而JavaScript其实是单线程的<code>(只有一个队伍)</code>,但是又想实现多线程的效果,所以有了异步</strong></p><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p><strong>多线程可以实现边走路边打电话, 也就是同一时刻多任务同时进行 ,也就是并行</strong></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><em><em>而异步则是跑步跑不动了,但是我还没跑完,在我恢复体力之前去吃点东西,等恢复体力了再回来跑 , 虽然我不能同时吃饭和跑步,但是吃饭和跑步事件都发生了,也就是并发 </em></em></p><h1 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>异步编程实现并发执行的的基础是基于事件循环的并发模型</p><p>再讲并发模型之前先简单介绍下堆栈与队列</p><p><img src="1579733173618.png" alt="堆栈与队列"></p><h3 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h3><p>随便堆砌数据,没有顺序,通常存储对象(引用类型)</p><h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h3><p>类似于口袋,先放进去的在最底下,想拿出来就要把后放进去的一个一个拿出来<code>(先进后出)</code>,</p><p>通常存储函数参数和基本类型值变量<code>(按值访问)</code></p><h3 id="队列-queue"><a href="#队列-queue" class="headerlink" title="队列(queue)"></a>队列(queue)</h3><p><code>先进先出</code>的顺序存储数据结构</p><p><strong>待处理消息的列表，每条消息都关联一个回调函数。</strong></p><p>　　<strong>JavaScript是单线程的（多进程/多线程往往有更大的内存开销、上下文切换开销和数据竞争问题等），这意味着需要有一个队列保存异步执行的代码。</strong></p><p>　　I、入队操作。例如，某个按钮被按下时，它的事件处理器代码被添加到队列；接收到某个Ajax响应时，回调函数的代码被添加到队列；<strong>对于定时器，当指定时间过去后将其回调函数的代码添加到队列。</strong></p><p>　　II、出队操作。<strong>队列中没有任何代码是立刻执行的，但一旦进程空闲（此时栈为空）则尽快执行</strong>。进程每次从队列中取出一条消息并调用其回调函数（<strong>异步操作的结果通过回调函数获得</strong>）。这使得栈变为非空。当栈再次变为空时，表示该消息处理完毕。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>得名于它通常的实现方式：</p><pre><code>// 所谓事件循环，就像代码从一个循环中不断取出而运行一样while (queue.waitForMessage()) { queue.processNextMessage(); }  // waitForMessage()：当前没有消息时执行同步等待</code></pre><h2 id="模型特点："><a href="#模型特点：" class="headerlink" title="模型特点："></a>模型特点：</h2><h3 id="完整运行（Run-to-completion）："><a href="#完整运行（Run-to-completion）：" class="headerlink" title="完整运行（Run-to-completion）："></a><strong>完整运行</strong>（Run-to-completion）：</h3><p>每条消息处理完成后，再处理其他消息。</p><p>　　进入一个函数后，只有在它完整运行后才会“切换”到其他代码，从而无需担心函数操作的数据被意外修改。</p><p>　　不足之处在于，如果一条消息处理时间过长，则Web应用程序无法响应用户的交互操作，浏览器将提示”a script is taking too long to run”。一个好的做法是缩短消息处理过程，并尽可能把一条消息“切分”为多条。</p><p>　　例子：</p><pre><code>setTimeout(function cb() { console.log(&#39;5 seconds timeout&#39;); }, 5000);setTimeout(function cb() { console.log(&#39;9 seconds timeout&#39;); }, 9000);setTimeout(function cb() { console.log(&#39;7 seconds timeout&#39;); }, 7000);setTimeout(function cb() { console.log(&#39;3 seconds timeout&#39;); }, 3000);for(var start = +new Date; +new Date - start &lt;= 10000; ) {}  // “模拟”睡眠</code></pre><p>　　运行大约10s后，输出：</p><pre><code>3 seconds timeout5 seconds timeout7 seconds timeout9 seconds timeout</code></pre><h3 id="从不阻塞"><a href="#从不阻塞" class="headerlink" title="从不阻塞"></a>从不阻塞</h3><p>（也有例外，如alert或同步XHR，但最好避免使用它们）：I/O的处理一般借助于事件和回调函数，因此当应用程序在等待一个IndexedDB查询或一个XHR请求返回时，它仍可以处理其他事情。</p><h1 id="JS执行环境中的两个结构"><a href="#JS执行环境中的两个结构" class="headerlink" title="JS执行环境中的两个结构"></a>JS执行环境中的两个结构</h1><p><a href="https://www.jianshu.com/p/36a7775b04ec" target="_blank" rel="noopener">消息队列(messagequeue)</a></p><p>消息队列也叫任务队列(taskqueue) : 存储待处理消息及对应的回调函数或事件处理程序.</p><p><a href="https://blog.csdn.net/qq_41973396/article/details/88696343" target="_blank" rel="noopener">执行栈(executioncontextstack)</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git快速上手</title>
      <link href="/2020/01/21/git-kuai-su-shang-shou/"/>
      <url>/2020/01/21/git-kuai-su-shang-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="Git教程"><a href="#Git教程" class="headerlink" title="Git教程"></a>Git教程</h1><blockquote><p>如果之前了解过想复习一下,直接看总结就可以了</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="设置Name和Email地址"><a href="#设置Name和Email地址" class="headerlink" title="设置Name和Email地址"></a>设置Name和Email地址</h2><p>安装完成后，还需要最后一步设置，在命令行输入：</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"Your Name"</span>$ git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"email@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p></blockquote><h1 id="本地版本库"><a href="#本地版本库" class="headerlink" title="本地版本库"></a>本地版本库</h1><p>选择一个合适的地方，创建一个空目录：</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ mkdir learngit$ cd learngit$ <span class="token function">pwd</span><span class="token operator">/</span>Users<span class="token operator">/</span>michael<span class="token operator">/</span>learngit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>pwd</code>命令用于显示当前目录。在我的Mac上，这个仓库位于<code>/Users/michael/learngit</code>。</p><p> <strong>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</strong> </p></blockquote><p>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ git initInitialized empty Git repository in <span class="token operator">/</span>Users<span class="token operator">/</span>michael<span class="token operator">/</span>learngit<span class="token operator">/</span><span class="token punctuation">.</span>git<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><p><strong>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</strong> </p></blockquote><h2 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h2><blockquote><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><p>使用Windows的童鞋要特别注意：</p><p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="http://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a>代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：</p></blockquote><p>先添加:</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># 单个文件</span>$ git add readme<span class="token punctuation">.</span>txt <span class="token comment" spellcheck="true"># 多个文件</span>$ git add readme<span class="token punctuation">.</span>txt readmeCN<span class="token punctuation">.</span>txt<span class="token comment" spellcheck="true"># 全部添加</span>$ git add <span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="把文件提交到本地版本库"><a href="#把文件提交到本地版本库" class="headerlink" title="把文件提交到本地版本库"></a>把文件提交到本地版本库</h2><p>再提交:</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ git commit <span class="token operator">-</span>m <span class="token string">"wrote a readme file"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p></blockquote><blockquote><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ git add file1<span class="token punctuation">.</span>txt$ git add file2<span class="token punctuation">.</span>txt file3<span class="token punctuation">.</span>txt$ git commit <span class="token operator">-</span>m <span class="token string">"add 3 files."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># 查看本地库文件状态</span>$ git status<span class="token comment" spellcheck="true"># 文件当前文件改了什么,查看一下再提交就比较放心</span>$ git <span class="token function">diff</span> readme<span class="token punctuation">.</span>txt <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li></ul></blockquote><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># 回退到上一版</span>$ git reset <span class="token operator">--</span>hard HEAD^<span class="token comment" spellcheck="true"># 回退到上上一版</span>$ git reset <span class="token operator">--</span>hard HEAD^^<span class="token comment" spellcheck="true"># 回退到指定版</span>$ git reset <span class="token operator">--</span>hard commit_id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li><li>用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。 </li></ul></blockquote><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><blockquote><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p></blockquote><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><pre class="line-numbers language-powershell"><code class="language-powershell">$ git checkout <span class="token operator">--</span> readme<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell">$ git reset HEAD readme<span class="token punctuation">.</span>txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192" target="_blank" rel="noopener">版本回退</a>一节，不过前提是没有推送到远程库。</p></blockquote><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre class="line-numbers language-powershell"><code class="language-powershell">$ <span class="token function">rm</span> file<span class="token comment" spellcheck="true"># 删除工作区 , 可以直接用用git checkout -- &lt;file> 恢复</span>$ git <span class="token function">rm</span> file<span class="token comment" spellcheck="true"># 不仅删除了工作区文件，而且还添加到了暂存区，需要先git reset HEAD &lt;file>，然后再git checkout -- &lt;file></span>&amp; git <span class="token function">rm</span> file&amp; git commit <span class="token operator">-</span>m <span class="token string">"说明注释"</span><span class="token comment" spellcheck="true"># 彻底删除 , 先删除工作区和暂存区,再提交到master分支(仓库)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果你用的rm删除文件，那就相当于只删除了工作区的文件，如果想要恢复，直接用git checkout – <file>就可以 2.如果你用的是git rm删除文件，那就相当于不仅删除了文件，而且还添加到了暂存区，需要先git reset HEAD <file>，然后再git checkout – <file> 3.如果你想彻底把版本库的删除掉，先git rm，再git commit 就ok了 </file></file></file></p></blockquote><h1 id="本地仓库总结"><a href="#本地仓库总结" class="headerlink" title="本地仓库总结"></a>本地仓库总结</h1><blockquote><p>Git管理的文件分为：工作区，版本库，版本库又分为暂存区stage和暂存区分支master(仓库)</p><p>工作区&gt;&gt;&gt;&gt;暂存区&gt;&gt;&gt;&gt;仓库</p><p>git add把文件从工作区&gt;&gt;&gt;&gt;暂存区，git commit把文件从暂存区&gt;&gt;&gt;&gt;仓库，</p><p>git diff查看工作区和暂存区差异，</p><p>git diff –cached查看暂存区和仓库差异，</p><p>git diff HEAD 查看工作区和仓库的差异，</p><p>git add的反向命令git checkout，撤销工作区修改，即把暂存区最新版本转移到工作区，</p><p>git commit的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区。</p></blockquote><blockquote><p><strong>新建git本地仓库：</strong></p><p><code>git init</code> </p><p>新建一个.git文件，有这个文件就是一个git仓库</p><p><strong>git本地仓库分三个区来区别操作（这个思路太重要了）：</strong> </p><p><strong>工作区：</strong> 就是一个多了.git文件的文件夹，不要想太多，就按Linux操作文件夹的方法正常操作 </p><p><strong>暂存区：</strong> 暂时讲了两种操作暂存区的方法：</p><p> 1.存入暂存区:</p><p><code>git add filename</code>  //添加文件</p><p><code>git rm filename</code>   //删除文件</p><p> 这两条都是修改暂存区 </p><p>2.递交暂存区</p><p> <code>git commit -m &quot;log说明一般写改动是什么&quot;</code> </p><p>别忘了正常来说一般对暂存区修改以后一定要commit一下<br><strong>版本库：</strong><code>git commit</code>以后的最终版本存入地方，git最重要的一个地方，因为只有版本库的修改才可以跟踪</p><p>另外有几个命令查看状态也很重要： </p><p><code>git status</code></p><p>查看当前git仓库与上一次commit之后的版本库的一切修改，包括工作区的修改和暂存区的修改（这种信息是不详细的） 很人性化的是，<code>git status</code>会提示你下一步可能会做的事，比如你对工作区做了修改，他可能会提示下一步要git add或者</p><p><code>git checkout  filename</code></p><p>， 你刚执行完git add以后，git status跟踪的暂存区的修改，他又会提示你下一步可能要提交git commit或者</p><p><code>git reset HEAD &lt; filename &gt;</code> </p><p><code>git diff filename</code></p><p>这个命令返回的是你对工作区的修改，别想太多，和什么对比并不重要，你只要知道什么时候他会有信息返回，返回什么信息！什么时候有返回呢！你对工作区已经存在的文件修改<!--（但是没有存入暂存区，也就是说没有git add或者git rm，所以一定要纠结的话，他比较的的确是暂存区和工作区的区别）-->的话有返回<strong>（新建文件git diff看不到）</strong>，返回什么，返回修改的详细信息，+是新添的行-是删去的行</p><p> <code>git diff --cached filename</code></p><p>这个命令是查看你对暂存区的修改，也就是你<code>git add</code>或者<code>git rm</code>以后，<code>git diff</code>的返回信息就用<code>git diff --cached</code>来用了（这也是为什么这两个命令一样，只有参数不一样的原因，因为其实干的都是一件事，只是<code>git diff</code>针对的对象是工作区，<code>git diff --cached</code>针对的对象是暂存区） </p><p><code>git log</code></p><p><strong>当前版本之前</strong>的commit日志记录，也就是说当前版本是回退回来的版本的话，当前版本之后的提交与回退都看不到（有个很重要的commit ID）</p><p><code>git reflog</code></p><p>包括版本回退、版本提交的日志，信息相较于<code>git log</code>会比较简单 </p><p><strong>这样把命令的针对对象分为三个区来理解，现在看撤销操作就很容易了：</strong></p><p> 1.针对工作区的撤销（必须保证没有git add/git rm之前）： </p><p><code>git checkout -- filename</code> </p><p>2.针对暂存区的撤销（必须是git add/git rm以后才行） </p><p><code>git reset HEAD filename</code> </p><p>顺便想起git reset的另一种用法，参数不一样啦，那肯定也是撤销操作，当然就是撤销提交，回退版本啦</p><p><code>git reset --hard （HEAD^^^^）/commit id</code></p></blockquote><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><blockquote><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 </p></blockquote><p><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 提供Git仓库托管服务 , 注册一个GitHub账号，就可以免费获得Git远程仓库 ,自行点击链接注册</p><blockquote><p>本地Git仓库和GitHub仓库之间的传输是通过SSH加密的 ,所以需要设置下SSH Key</p></blockquote><blockquote><p>第1步：<strong>创建SSH Key</strong>。在用户主目录下<code>C:\Users\zl</code><!--用户主目录在windows中就是 C:\Users\Administrator\，或者你新建了一个用户，那就是 C:\Users\用户名\--> ，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell">$ ssh<span class="token operator">-</span>keygen <span class="token operator">-</span>t rsa <span class="token operator">-</span>C <span class="token string">"youremail@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“<strong>Add SSH Key”</strong>，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p></blockquote><h2 id="本地文件添加到远程仓库"><a href="#本地文件添加到远程仓库" class="headerlink" title="本地文件添加到远程仓库"></a>本地文件添加到远程仓库</h2><ul><li>找到“Create a new repo”按钮，创建一个新的仓库： </li><li>在Repository name填入名称</li><li>其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库 </li></ul><p>在本地的<code>learngit</code>仓库下运行命令：</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ git remote add origin git@github<span class="token punctuation">.</span>com:michaelliao<span class="token operator">/</span>learngit<span class="token punctuation">.</span>git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>请千万注意，把上面的<code>michaelliao</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell">$ git push <span class="token operator">-</span>u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样 </p></blockquote><blockquote><p>从现在起，只要本地作了提交，就可以通过命令：</p></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell">$ git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="克隆别人的Git远程仓库到自己的仓库"><a href="#克隆别人的Git远程仓库到自己的仓库" class="headerlink" title="克隆别人的Git远程仓库到自己的仓库"></a>克隆别人的Git远程仓库到自己的仓库</h2><ul><li>在本地新建文件夹克隆下来</li><li>删除<code>.git</code>文件</li><li>然后在自己的GitHub上新建一个仓库</li><li>在本地仓库执行</li></ul><pre class="line-numbers language-powershell"><code class="language-powershell">$ git init$ git remote add origin 新建的仓库地址$ git add <span class="token punctuation">.</span>$ git commit <span class="token operator">-</span>m <span class="token string">"提交全部"</span>$ git push <span class="token operator">-</span>u origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h2><blockquote><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><pre><code>The authenticity of host &#39;github.com (xx.xx.xx.xx)&#39; can&#39;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)?</code></pre><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><pre><code>Warning: Permanently added &#39;github.com&#39; (RSA) to the list of known hosts.</code></pre><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/" target="_blank" rel="noopener">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p></blockquote><blockquote><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p></blockquote><h2 id="从远程库克隆到本地"><a href="#从远程库克隆到本地" class="headerlink" title="从远程库克隆到本地"></a>从远程库克隆到本地</h2><ul><li>第一步<ul><li>新建一个仓库,勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件： </li></ul></li><li>第二步<ul><li><code>$ git clone 仓库的URL</code></li></ul></li></ul><blockquote><p>URL我们一般选取SSH 相较于 http 而言 方便不用每次都输入用户名密码,而且传输速度快</p><p>除非公司只支持 http 才会选用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue文档风格的Typora主题</title>
      <link href="/2020/01/21/vue-wen-dang-feng-ge-de-typora-zhu-ti/"/>
      <url>/2020/01/21/vue-wen-dang-feng-ge-de-typora-zhu-ti/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/ThirtyZhang/ypora-vue-theme" target="_blank" rel="noopener">typora-vue-theme</a>是 Typora Markdown 文档编辑器中一款类似<a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>文档风格的主题。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a>是一款支持实时预览的 Markdown 编辑器和阅读器，支持<code>Windows</code>、<code>macOS</code>、<code>Linux</code>三大平台。Typora 作为一款合格的 Markdown 编辑器，支持图片、列表、表格、代码、公式、目录等功能，同时这款软件还支持（一键）动态预览功能，让一切都变得如此干净、纯粹。并且有多种主题模板。<strong>typora-vue-theme就是参考了Vue文档风格而开发的一个 Typora 自定义主题</strong>。</p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><ol><li>下载本主题<strong><a href="https://github.com/ThirtyZhang/ypora-vue-theme" target="_blank" rel="noopener">typora-vue-theme</a></strong>中的<code>vue.css</code>、<code>vue-dark.css</code>文件和包含字体的<code>vue</code>文件夹；</li><li>打开 Typora，点击“<strong>偏好设置</strong>” =&gt; “<strong>打开主题文件夹</strong>”按钮，将弹出 Typora 的主题文件夹；</li><li>将下载好的<code>vue.css</code>和<code>vue-dark.css</code>文件和包含字体的<code>vue</code>文件夹放到 Typora 的主题文件夹中；</li><li>关闭并重新打开 Typora，从菜单栏中选择 “<strong>主题</strong>” =&gt; “<strong>Vue</strong>” 或者 “<strong>Vue Dark</strong>” 即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建个人博客</title>
      <link href="/2020/01/21/hexo-da-jian-ge-ren-bo-ke/"/>
      <url>/2020/01/21/hexo-da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<div align="center"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=864622002&auto=1&height=66"></iframe></div><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="添加国内镜像源"><a href="#添加国内镜像源" class="headerlink" title="添加国内镜像源"></a>添加国内镜像源</h2><p>如果没有梯子的话，可以使用阿里的国内镜像进行加速,不使用的话可能会有下载过慢或下载失败的问题</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ npm config <span class="token function">set</span> registry https:<span class="token operator">/</span><span class="token operator">/</span>registry<span class="token punctuation">.</span>npm<span class="token punctuation">.</span>taobao<span class="token punctuation">.</span>org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="认识-Hexo"><a href="#认识-Hexo" class="headerlink" title="认识 Hexo"></a>认识 Hexo</h2><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架，可以让你快速建立一个博客。</p></blockquote><blockquote><p>Hexo 使用 Node.js 编写。得益于 Node.js，使得 Hexo 生成上百个页面游刃有余。</p></blockquote><blockquote><p>Hexo 支持 GFM (GitHub Flavored Markdown) 的大部分功能。如果你不喜欢 Markdown ，你还可以换一个 Hexo 渲染插件。</p></blockquote><blockquote><p>Hexo 有许多插件，可以进行各种操作。</p></blockquote><h2 id="学习-Hexo-之前，你需要有："><a href="#学习-Hexo-之前，你需要有：" class="headerlink" title="学习 Hexo 之前，你需要有："></a>学习 Hexo 之前，你需要有：</h2><ul><li>Node.js 基本知识</li><li>Git 基本知识</li><li>Markdown 基本知识</li><li>Html、css、JavaScript 基本知识</li><li>······</li></ul><p>当然了，你可别被吓跑了。除了 Markdown ，其他都不用熟练掌握（事实上如果你不注意排版连 Markdown 都不用掌握，但最好还是学学吧 : <strong><a href="https://thirtyzhang.github.io/2020/01/21/markdown-yu-fa/">Markdown语法 </a></strong>）。如果你完全不会以上划线部分的知识，也没关系。只是简单地建个可以发文章的博客就好了。如果你要更上一层楼，那么以上被划掉的知识就是必备的啦~</p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>在安装 Hexo 之前，你需要安装以下两个工具：</p><ul><li><strong><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></strong></li><li><strong><a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a></strong></li></ul><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> ：<code>brew install git</code>;或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li><li>Linux (Arch 系列)：<code>sudo pacman -S git</code></li></ul><p>提醒</p><p>由于墙的原因，从上面的链接下载 git for windows 最好挂上一个代理，否则下载速度十分缓慢。也可以参考<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">这个页面</a>，收录了存储于百度云的下载地址。</p><p>提醒</p><p>如果你是 CentOS 服务器上的，可以直接使用 <a href="https://github.com/PasserByJia/HexoOneClickInstallation" target="_blank" rel="noopener">HexoOneClickInstallation</a> 这个脚本快速安装 Hexo。</p><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。</p><p>cURL:</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ curl https:<span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>creationix<span class="token operator">/</span>nvm<span class="token operator">/</span>v0<span class="token punctuation">.</span>33<span class="token punctuation">.</span>11<span class="token operator">/</span>install<span class="token punctuation">.</span>sh <span class="token punctuation">|</span> sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Wget:</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ wget <span class="token operator">-</span>qO<span class="token operator">-</span> https:<span class="token operator">/</span><span class="token operator">/</span>raw<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>creationix<span class="token operator">/</span>nvm<span class="token operator">/</span>v0<span class="token punctuation">.</span>33<span class="token punctuation">.</span>11<span class="token operator">/</span>install<span class="token punctuation">.</span>sh <span class="token punctuation">|</span> sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><pre class="line-numbers language-powershell"><code class="language-powershell">$ nvm install stable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">安装程序</a> 来安装。</p><h2 id="安装-Hexo-1"><a href="#安装-Hexo-1" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>安装好后，即可使用 npm 完成 Hexo 的安装。</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># 下面这两个命令好像是一样的效果,任选一个就可以了</span>$ npm install <span class="token operator">-</span>g hexo<span class="token operator">-</span><span class="token function">cli</span>$ npm install hexo<span class="token operator">-</span><span class="token function">cli</span> <span class="token operator">-</span>g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>输入<code>npm install</code>安装必备的组件 </p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="建立网站"><a href="#建立网站" class="headerlink" title="建立网站"></a>建立网站</h2><p>安装好 Hexo 后即可建立你的网站。</p><p>首先建立一个文件夹。</p><pre class="line-numbers language-powershell"><code class="language-powershell">mkdir &lt;your_blog_name>  <span class="token comment" spellcheck="true"># 建立你的网站根目录，名字可以自己修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后往这个文件夹里安装 Hexo。</p><pre class="line-numbers language-powershell"><code class="language-powershell">hexo init &lt;your_blog_name><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再执行</p><pre class="line-numbers language-powershell"><code class="language-powershell">hexo s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>浏览器输入</p><pre class="line-numbers language-powershell"><code class="language-powershell">http:<span class="token operator">/</span><span class="token operator">/</span>localhost:4000<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以本地访问了</p><p>这样就建立好网站了！</p><p><strong>网站建立好后还需要做一些个性化配置,如:修改网站默认内容改为自己的内容</strong></p><p>此部分内容可能过期，请见 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">Hexo 官方文档</a>。</p><p>在 Hexo 根目录 <code>_config.yml</code> 这个文件里配置！</p><p>警告</p><p>在 YAML 语法中，冒号后面必须要有一个空格才能继续写下去。</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><pre><code># Sitetitle:            subtitle: description: keywords:author: language: timezone: </code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>keywords</code></td><td>网站关键词</td></tr><tr><td><code>author</code></td><td>作者名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言</td></tr><tr><td><code>timezone</code></td><td>网站时区：详见<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">时区列表</a></td></tr></tbody></table><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><pre><code># URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: root: permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls:  trailiing_index: true</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>url</code></td><td>网址</td></tr><tr><td><code>root</code></td><td>网站根目录</td></tr><tr><td><code>permalink</code></td><td>文章的永久链接格式</td></tr><tr><td><code>permalink_defaults</code></td><td>永久链接中各部分的默认值</td></tr><tr><td><code>pretty_urls</code></td><td>改写 <code>permalink</code> 的值来美化 URL</td></tr><tr><td><code>pretty_urls.trailing_index</code></td><td>是否在永久链接中保留尾部的 <code>index.html</code>，<code>false</code> 时去除</td></tr></tbody></table><p>提醒</p><p>如果你的网站在子目录中，如：<code>https://yoursite.com/blog</code> ，就把你的 <code>url</code> 设为 <code>http://yoursite.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p><p>例如：</p><pre><code># 比如，一个页面的永久链接是 http://example.com/foo/bar/index.htmlpretty_urls:  trailing_index: false# 此时页面的永久链接会变为 http://example.com/foo/bar/</code></pre><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><pre><code># Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: README.md</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>source_dir</code></td><td>资源文件夹</td></tr><tr><td><code>public_dir</code></td><td>公共文件夹</td></tr><tr><td><code>tag_dir</code></td><td>标签文件夹</td></tr><tr><td><code>archive_dir</code></td><td>归档文件夹</td></tr><tr><td><code>category_dir</code></td><td>分类文件夹</td></tr><tr><td><code>code_dir</code></td><td>Include code 文件夹</td></tr><tr><td><code>i18n_dir</code></td><td>国际化文件夹</td></tr><tr><td><code>skip_render</code></td><td>跳过文件的渲染。匹配到的文件将直接复制到 <code>public</code> 目录中。您可使用 <a href="https://github.com/micromatch/micromatch#extended-globbing" target="_blank" rel="noopener">glob</a> 表达式来匹配路径。</td></tr></tbody></table><p>提醒</p><p>一般情况下，这部分是不需要修改的。</p><p>例如：</p><pre><code>skip_render: &quot;mypage/**/*&quot;# 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 &#39;public&#39; 目录# 你也可以用这种方法来跳过对指定文章文件的渲染skip_render: &quot;_posts/test-post.md&quot;# 这将会忽略对 &#39;test-post.md&#39; 的渲染</code></pre><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><pre><code># Writingnew_post_name: :title.md # File name of new postsdefault_layout: postauto_spacing: falsetitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tab  enable: true  field: site  exclude: []filename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight:  enable: true  line_number: true  auto_detect: false  tab_replace:</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>new_post_name</code></td><td>新文章的文件名称</td></tr><tr><td><code>default_layout</code></td><td>预设布局</td></tr><tr><td><code>auto_spacing</code></td><td>在中文和英文之间加入空格</td></tr><tr><td><code>titlecase</code></td><td>把标题转换为 title case</td></tr><tr><td><code>external_link</code></td><td>在新标签中打开链接</td></tr><tr><td><code>external_link.enable</code></td><td>在新标签中打开链接</td></tr><tr><td><code>external_link.field</code></td><td>适用于整个网站或仅文章</td></tr><tr><td><code>external_link.exclude</code></td><td>排除主机名。在适用时指定子域，包括 <code>www</code></td></tr><tr><td><code>filename_case</code></td><td>把文件名称转换为 (1) 小写或 (2) 大写</td></tr><tr><td><code>render_drafts</code></td><td>显示草稿</td></tr><tr><td><code>post_asset_folder</code></td><td>启动 <a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">Asset 文件夹</a></td></tr><tr><td><code>relative_link</code></td><td>把链接改为与根目录的相对位址</td></tr><tr><td><code>future</code></td><td>显示未来的文章</td></tr><tr><td><code>highlight</code></td><td>代码块的设置</td></tr><tr><td><code>highlight.enable</code></td><td>开启语法高亮</td></tr><tr><td><code>highlight.auto_detect</code></td><td>如果未指定语言，则启用自动检测</td></tr><tr><td><code>highlight.line_number</code></td><td>显示行数</td></tr><tr><td><code>highlight.tab_replace</code></td><td>用 n 个空格替换 tabs；如果值为空，则不会替换 tabs</td></tr></tbody></table><h3 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h3><pre><code># Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>default_category</code></td><td>默认分类</td></tr><tr><td><code>category_map</code></td><td>分类别名</td></tr><tr><td><code>tag_map</code></td><td>标签别名</td></tr></tbody></table><h3 id="日期-时间格式"><a href="#日期-时间格式" class="headerlink" title="日期 / 时间格式"></a>日期 / 时间格式</h3><pre><code># Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ssuse_date_for_updated: true</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>date_format</code></td><td>日期格式</td></tr><tr><td><code>time_format</code></td><td>时间格式</td></tr><tr><td><code>use_date_for_updated</code></td><td>如果前面没有提供更新日期，则使用 <code>post.updated</code> 中的发布日期。通常与 Git 工作流一起使用。</td></tr></tbody></table><p>提醒</p><p>Hexo 使用 <a href="http://momentjs.com/" target="_blank" rel="noopener">Moment.js</a> 来解析和显示时间。</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><pre><code># Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>per_page</code></td><td>每页显示的文章量 (0 = 关闭分页功能)</td></tr><tr><td><code>pagination_dir</code></td><td>分页目录</td></tr></tbody></table><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><pre><code># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: theme_config: deploy:meta_generator:</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>theme</code></td><td>当前主题名称。值为 <code>false</code> 时禁用主题</td></tr><tr><td><code>theme_config</code></td><td>主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置。</td></tr><tr><td><code>deploy</code></td><td>部署的设置</td></tr><tr><td><code>meta_generator</code></td><td><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签。</td></tr></tbody></table><p>提醒</p><p>下一篇文章将会提到 部署。</p><h1 id="Hexo-命令详解"><a href="#Hexo-命令详解" class="headerlink" title="Hexo 命令详解"></a>Hexo 命令详解</h1><p>下面介绍一些 Hexo 的基本命令。</p><h3 id="hexo-init-folder"><a href="#hexo-init-folder" class="headerlink" title="hexo init [folder]"></a><code>hexo init [folder]</code></h3><p>这个命令是 Hexo 初始化命令。<code>[folder]</code> 表示你要初始化的文件夹。如果你要初始化本地，直接 <code>hexo init .</code> 。</p><h3 id="hexo-new-layout-lt-title-gt"><a href="#hexo-new-layout-lt-title-gt" class="headerlink" title="hexo new [layout] &lt;title&gt;"></a><code>hexo new [layout] &lt;title&gt;</code></h3><p>这个命令是新建文章或页面用的命令。其中 <code>[layout]</code> 表示他的模板（即页面或者文章），<code>&lt;title&gt;</code> 表示标题。</p><p>用法：</p><ol><li><code>hexo new post 001</code> ，表示新建了一个标题为 <code>001</code> 的文章。</li><li><code>hexo new page 001</code> ，表示新建了一个标题为 <code>001</code> 的页面。</li></ol><p>如果你不想在终端中新建文章或页面，可以直接在 <code>博客根目录/source/_post/</code> 目录下创建 Markdown 文件写<strong>文章</strong>。或者在 <code>博客根目录/source/</code> 目录下创建一个文件夹，然后在新文件夹里创建 <code>index.md</code> 写<strong>页面</strong>即可。</p><p>提醒</p><p>当你新建页面后，页面的链接就是你页面所在的文件夹的名字。</p><p>例如：我在 <code>博客根目录/source/</code> 下新建了一个名为 <code>test</code> 的文件夹，然后在 <code>test</code> 文件夹下写 Markdown 文件，那么这个页面的链接就是 <code>网址/test</code>。</p><h3 id="hexo-server"><a href="#hexo-server" class="headerlink" title="hexo server"></a><code>hexo server</code></h3><p>当你要在本地查看网站的时候，就可以用这个命令。</p><p>默认在 <code>http://localhost:8080/</code> 这里，可能会不同，注意提示信息即可。</p><p>提醒</p><p>如果你想要换端口号（上面的 <code>8080</code> 就是端口号），可以在终端里输入 <code>hexo s -p 端口号</code>。</p><h3 id="hexo-generate"><a href="#hexo-generate" class="headerlink" title="hexo generate"></a><code>hexo generate</code></h3><p>这个命令是生成网站静态文件的时候用的，生成后网页将会放在根目录下面的 <code>public</code> 文件夹里。</p><h3 id="hexo-deploy"><a href="#hexo-deploy" class="headerlink" title="hexo deploy"></a><code>hexo deploy</code></h3><p>这个命令用来部署网站，使用此命令将会把生成好的页面（即 <code>public</code> 文件夹里的内容）部署到指定的地方上。</p><h3 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a><code>hexo clean</code></h3><p>这个命令用来清空 <code>public</code> 文件夹。</p><h3 id="hexo-version"><a href="#hexo-version" class="headerlink" title="hexo version"></a><code>hexo version</code></h3><p>这个命令用来输出你所使用的 Hexo 目前的版本号</p><h1 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h1><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>如果没有账号，请点此前往 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 注册一个 GitHub 账号。</li><li>新建一个公开仓库，仓库名格式为 <code>your_username.github.io</code> 例如你的 GitHub 用户名是 <code>easyhexo</code>，那么你的仓库地址名称就应该是 <code>easyhexo.github.io</code></li><li>创建完成后记下该仓库的 HTTPS/SSH 地址 一般格式为 <code>https://github.com/your_username/your_reponame.git</code> 在下一步会用到。</li></ol><h3 id="安装部署插件"><a href="#安装部署插件" class="headerlink" title="安装部署插件"></a>安装<a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">部署插件</a></h3><pre><code>$ npm install hexo-deployer-git --save$ npm install hexo-server --save</code></pre><h3 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h3><p>如果你只是安装好了 Git 但没有配置过你的 Git ，那么现在需要做的第一件事情就是设置你的 Git 用户名和邮箱。 在 Git Bash 中执行以下两条命令配置你的用户名和邮箱，这里建议用户名和邮箱与你的 GitHub 用户名和邮箱保持一致。</p><pre><code>$ git config --global user.name &quot;Your_user_name&quot;$ git config --global user.email &quot;Your_email@example.com&quot;</code></pre><p>提醒</p><p>每次 Git 提交时都会附带这两条信息，用于记录是谁提交的更新，并且会随更新内容一起被记录到历史记录中。简单说，是用来标记的你的身份的~</p><p>用户名和邮箱根据你注册github的信息自行修改。</p><h3 id="然后生成密钥SSH-key："><a href="#然后生成密钥SSH-key：" class="headerlink" title="然后生成密钥SSH key："></a>然后生成密钥SSH key：</h3><pre><code>ssh-keygen -t rsa -C &quot;Your_email@example.com&quot;</code></pre><p>打开<a href="https://github.com/" target="_blank" rel="noopener">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>git bash中输入</p><pre><code>cat ~/.ssh/id_rsa.pub</code></pre><p>将输出的内容复制到框中，点击确定保存。</p><p>输入<code>ssh -T git@github.com</code>，出现你的用户名，那就成功了。</p><h3 id="配置站点-config-yml-文件"><a href="#配置站点-config-yml-文件" class="headerlink" title="配置站点 _config.yml 文件"></a>配置站点 <code>_config.yml</code> 文件</h3><pre><code>deploy:  type: git   # 类型填git  repo: &lt;repository url&gt; # 你的Github仓库地址  branch: master  # 分支名称。默认填写 master 如果您使用的是 GitHub ，程序会尝试自动检测。  message:  # 提交信息可以自定义，不填的则默认为提交时间</code></pre><pre><code>deploy:  type: git  repository: git@github.com:ThirtyZhang/ThirtyZhang.github.io.git  branch: master</code></pre><p>repository修改为你自己的github项目地址。<strong>(最好使用SSH的地址,因为使用Http更换电脑后可能找不到该git地址)</strong></p><h3 id="发布到-GitHub"><a href="#发布到-GitHub" class="headerlink" title="发布到 GitHub"></a>发布到 GitHub</h3><p>在本地的 Hexo 站点根目录下，执行如下命令即可部署到 GitHub Pages 上。</p><pre><code>$ hexo clean &amp;&amp; hexo d -g</code></pre><h1 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h1><p>首先在博客根目录下右键打开git bash</p><p>输入<code>hexo new post &quot;article title&quot;</code>，新建一篇文章。</p><p>然后打开<code>博客根目录\source\_posts</code>的目录，可以发现下面多了一个文件夹和一个<code>.md</code>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完markdown文件后，根目录下输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>可以本地预览效果，最后输入<code>hexo d</code>上传到github上。这时打开你的github.io主页就能看到发布的文章啦</p><h2 id="创建文章命令详细介绍"><a href="#创建文章命令详细介绍" class="headerlink" title="创建文章命令详细介绍"></a>创建文章命令详细介绍</h2><blockquote><p><code>hexo new [layout]</code></p><p>这个命令是新建文章或页面用的命令。其中 <code>[layout]</code> 表示他的模板（即页面或者文章），<code>&lt;title&gt;</code> 表示标题。</p><p>用法：</p><ol><li><code>hexo new post 001</code> ，表示新建了一个标题为 <code>001</code> 的文章。</li><li><code>hexo new page 001</code> ，表示新建了一个标题为 <code>001</code> 的页面。</li></ol><p>如果你不想在终端中新建文章或页面，可以直接在 <code>博客根目录/source/_post/</code> 目录下创建 Markdown 文件写<strong>文章</strong>。或者在 <code>博客根目录/source/</code> 目录下创建一个文件夹，然后在新文件夹里创建 <code>index.md</code> 写<strong>页面</strong>即可。</p><p>提醒</p><p>当你新建页面后，页面的链接就是你页面所在的文件夹的名字。</p><p>例如：我在 <code>博客根目录/source/</code> 下新建了一个名为 <code>test</code> 的文件夹，然后在 <code>test</code> 文件夹下写 Markdown 文件，那么这个页面的链接就是 <code>网址/test</code>。</p></blockquote><h1 id="推荐使用的主题链接"><a href="#推荐使用的主题链接" class="headerlink" title="推荐使用的主题链接"></a>推荐使用的主题链接</h1><p>推荐一个好用的主题地址</p><p><a href="https://github.com/ThirtyZhang/hexo-theme-matery" target="_blank" rel="noopener">自己克隆的</a></p><p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">原版的</a></p><p>下载后将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可</p><p>然后参照其中的<code>DEADME-CN.md</code>文件进行配置</p><h1 id="最后我搭建好的成品效果图"><a href="#最后我搭建好的成品效果图" class="headerlink" title="最后我搭建好的成品效果图"></a>最后我搭建好的成品效果图</h1><p>我个人的博客地址 : <a href="https://thirtyzhang.github.io/">点击访问</a></p><p><img src="1579682303863.png" alt="MyBlog"></p><h1 id="收藏博客"><a href="#收藏博客" class="headerlink" title="收藏博客"></a>收藏博客</h1><p><strong><a href="https://milyyy.github.io/" target="_blank" rel="noopener">milyyy</a></strong></p><p><a href="https://blinkfox.github.io/" target="_blank" rel="noopener">闪烁之狐</a></p><p><a href="https://godweiyang.com/" target="_blank" rel="noopener">韦阳的博客</a></p><h1 id="备份博客源文件"><a href="#备份博客源文件" class="headerlink" title="备份博客源文件"></a>备份博客源文件</h1><p>有时候我们想换一台电脑继续写博客，这时候就可以将博客目录下的所有源文件都上传到github上面。</p><p>首先在github博客仓库下新建一个分支<code>hexo</code>，然后<code>git clone</code>到本地，把<code>.git</code>文件夹拿出来，放在博客根目录下。</p><p>然后<code>git checkout hexo</code>切换到<code>hexo</code>分支，然后<code>git add .</code>，然后</p><p>，最后<code>git push origin hexo</code>提交就行了。</p><h1 id="推荐另一个教程作参考"><a href="#推荐另一个教程作参考" class="headerlink" title="推荐另一个教程作参考"></a>推荐另一个教程作参考</h1><h2 id="Hexo-Github博客搭建-完整小白教程"><a href="#Hexo-Github博客搭建-完整小白教程" class="headerlink" title="Hexo+Github博客搭建 完整小白教程"></a>Hexo+Github博客搭建 完整小白教程</h2><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-10" target="_blank" rel="noopener">https://godweiyang.com/2018/04/13/hexo-blog/#toc-heading-10</a> </p><p><strong>更多细节可查看官方文档</strong> : <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">hexo</a></p><h1 id="遇到的问题解决办法"><a href="#遇到的问题解决办法" class="headerlink" title="遇到的问题解决办法"></a>遇到的问题解决办法</h1><h2 id="端口占用"><a href="#端口占用" class="headerlink" title="端口占用"></a>端口占用</h2><ul><li>提示“FATAL Port 4000 has been used. Try other port instead.”<br> 在使用了$ hexo s命令预览博客效果后使用Control+C关闭<br> 解决办法：</li></ul><p>还不行就重新手动制定端口号</p><pre><code>$ hexo s -p 5000</code></pre><h2 id="未安装git部署插件"><a href="#未安装git部署插件" class="headerlink" title="未安装git部署插件"></a>未安装git部署插件</h2><ul><li>提示“ERROR Deployer not found: git”<br>解决办法：</li></ul><pre><code>$ npm install hexo-deployer-git --save</code></pre><h2 id="每次hexo-d-提交到GitHub-都会发送警告邮件"><a href="#每次hexo-d-提交到GitHub-都会发送警告邮件" class="headerlink" title="每次hexo d 提交到GitHub 都会发送警告邮件"></a>每次hexo d 提交到GitHub 都会发送警告邮件</h2><p><strong>Page build warning：Cannot use CNAMEs ending with github.io or github.com</strong></p><p>总结写在前面,如果你没有绑定域名,而是克隆的别人的文件,直接删除掉就可以了</p><p>路径 : <code>博客根目录/source</code></p><p><img src="1579706750493.png" alt="CNAME"></p><p>然后重新依次执行:</p><pre class="line-numbers language-powershell"><code class="language-powershell">hexo cleanhexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>就不会受到警告邮件了.</p><p>​       在设计自己blog的时候，大家都会先借鉴一下<a href="http://jekyllthemes.org/" target="_blank" rel="noopener">jkell模板</a>吧。我的这个blog也先clone了别人的架构，接下来慢慢修改填充自己的想法。</p><p>​       在我每次向github的远程仓库提交更新的时候，总会收到一封邮件：</p><blockquote><p> The page build completed successfully, but returned the following warning for the <code>master</code> branch:You cannot use CNAMEs ending with github.io or github.com. Instead, create a repository named ThirtyZhang.github.io. See <a href="https://help.github.com/articles/setting-up-your-pages-site-repository/" target="_blank" rel="noopener">https://help.github.com/articles/setting-up-your-pages-site-repository/</a></p><p> For information on troubleshooting Jekyll see:</p><p> <a href="https://help.github.com/articles/troubleshooting-jekyll-builds" target="_blank" rel="noopener">https://help.github.com/articles/troubleshooting-jekyll-builds</a></p><p> If you have any questions you can contact us by replying to this email.</p></blockquote><p>大概就是表示您不能使用以<code>github.io</code> 或者 <code>github.com</code> 结尾的CNAMEs文件 ,创建一个名为ThirtyZhang.github.io的存储库代替</p><p>刚接触<a href="http://jekyll.bootcss.com/" target="_blank" rel="noopener">jekyll</a>不久，对它的构建结构和语法都不是特别熟悉。访问了邮件中的链接，我发现这并不能解决我的问题。虽然有warning但是无伤大雅，毕竟程序员不怎么care warning。But 每次更新代码，都要收到github的邮件，我是不能忍受的！！！(<em>&gt;﹏&lt;</em>)</p><p>​       于是乎好好研究了下jekyll的目录结构以及CNAME，原来CNAME是用来绑定域名的。</p><p><strong>绑定到一级域名</strong></p><ol><li>首先在项目根目录下创建一个叫CNAME文件，里面写上自己的以及一级域名(<a href="http://www.youdomain.com" target="_blank" rel="noopener">www.youdomain.com</a>)</li><li>在你的域名管理页或者是DNS解析的地方，增加一个记录，记录类别为CNAME(Alias)类型。i.e.在DNS中为自己的域名增加一条A记录，指向207.97.227.245（github服务器）。</li><li>将项目提交到github上, wait a minute</li><li>baseurl应该为”/”</li><li>访问自己的域名,check一下</li></ol><p><strong>绑定到二级域名</strong></p><p>​       需要额外在DNS中增加一条CNAME，指向(github用户名).github.io，然后再CNAME文件中修改为自己的二级域名即可</p><p>​       有关这个问题的<a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/" target="_blank" rel="noopener">github官方帮助文档</a></p><p>​       之前clone jekyll模板的时候在项目中有个CNAME文件，刚开始不知道它的而作用就保留了。我还没有申请域名，现在看来这个文件不仅unnecessary而且是trouble maker。删除这个文件就没有警告了。O(∩_∩)O</p><h2 id="python3安装PIL失败"><a href="#python3安装PIL失败" class="headerlink" title="python3安装PIL失败"></a>python3安装PIL失败</h2><p>PIL其实只是python2的专利，它并没有跟随python的进化而进化。有大师为此，专门写了一个针对python3的pillow模块。</p><p>所以，如果需要安装python3对应的PIL，应该选择安装<code>pillow</code>。</p><hr><p><strong>如果文章对您有帮助,希望可以点击下方的打<code>赏</code>.</strong></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub国内访问加速</title>
      <link href="/2020/01/21/github-guo-nei-fang-wen-jia-su/"/>
      <url>/2020/01/21/github-guo-nei-fang-wen-jia-su/</url>
      
        <content type="html"><![CDATA[<h1 id="Github加速"><a href="#Github加速" class="headerlink" title="Github加速"></a>Github加速</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>修改系统hosts文件的办法，绕过国内dns解析，直接访问GitHub的CDN节点</p><p>访问网址时先搜索hosts文件，如果由网址对应的ip则不需要dns域名解析，因此可以将网址的ip配成静态ip，减少解析过程，提高访问速度。 </p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><strong>修改hosts</strong></p><blockquote><p>hosts文件最下面增加（win10的位置为C:\Windows\System32\drivers\etc，先拷到其他地方修改后再覆盖该文件夹hosts文件）：</p></blockquote><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># Github加速</span>192<span class="token punctuation">.</span>30<span class="token punctuation">.</span>253<span class="token punctuation">.</span>113     github<span class="token punctuation">.</span>com185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153    github<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io151<span class="token punctuation">.</span>101<span class="token punctuation">.</span>72<span class="token punctuation">.</span>133     assets<span class="token operator">-</span>cdn<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com151<span class="token punctuation">.</span>101<span class="token punctuation">.</span>185<span class="token punctuation">.</span>194    github<span class="token punctuation">.</span>global<span class="token punctuation">.</span>ssl<span class="token punctuation">.</span>fastly<span class="token punctuation">.</span>net203<span class="token punctuation">.</span>98<span class="token punctuation">.</span>7<span class="token punctuation">.</span>65 gist<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 13<span class="token punctuation">.</span>229<span class="token punctuation">.</span>189<span class="token punctuation">.</span>0 codeload<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>109<span class="token punctuation">.</span>153 desktop<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153 guides<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153 blog<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 18<span class="token punctuation">.</span>204<span class="token punctuation">.</span>240<span class="token punctuation">.</span>114 status<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153 developer<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153 services<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 192<span class="token punctuation">.</span>30<span class="token punctuation">.</span>253<span class="token punctuation">.</span>175 enterprise<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 34<span class="token punctuation">.</span>195<span class="token punctuation">.</span>49<span class="token punctuation">.</span>195 education<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153 pages<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com 34<span class="token punctuation">.</span>196<span class="token punctuation">.</span>237<span class="token punctuation">.</span>103 classroom<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com<span class="token comment" spellcheck="true"># Github加速结束</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>刷新系统DNS缓存</strong> </p><blockquote><p>打开<code>cmd console:</code></p><blockquote><p><code>Windows+X</code> 打开系统命令行（管理员身份）或 PowerShell </p></blockquote></blockquote><blockquote><p>执行：<code>ipconfig /flushdns</code></p></blockquote><p>到这里就完成了,下面介绍下获取最新地址方法</p><h2 id="获取GitHub官方CDN地址"><a href="#获取GitHub官方CDN地址" class="headerlink" title="获取GitHub官方CDN地址"></a>获取GitHub官方CDN地址</h2><p><strong>打开:</strong><a href="https://www.ipaddress.com/" target="_blank" rel="noopener"><a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a> </a></p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token comment" spellcheck="true"># Github加速</span>192<span class="token punctuation">.</span>30<span class="token punctuation">.</span>253<span class="token punctuation">.</span>113     github<span class="token punctuation">.</span>com185<span class="token punctuation">.</span>199<span class="token punctuation">.</span>108<span class="token punctuation">.</span>153    github<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io151<span class="token punctuation">.</span>101<span class="token punctuation">.</span>72<span class="token punctuation">.</span>133     assets<span class="token operator">-</span>cdn<span class="token punctuation">.</span>github<span class="token punctuation">.</span>com151<span class="token punctuation">.</span>101<span class="token punctuation">.</span>185<span class="token punctuation">.</span>194    github<span class="token punctuation">.</span>global<span class="token punctuation">.</span>ssl<span class="token punctuation">.</span>fastly<span class="token punctuation">.</span>net<span class="token comment" spellcheck="true"># Github加速结束</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查询上述IP后面的网址,更新前面的IP地址,并重新修改<code>hosts</code>文件</p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2020/01/21/markdown-yu-fa/"/>
      <url>/2020/01/21/markdown-yu-fa/</url>
      
        <content type="html"><![CDATA[<div align="middle"> <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28892385&auto=1&height=66"></iframe></div><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><table><thead><tr><th align="center"><strong>语法</strong></th></tr></thead><tbody><tr><td align="center"><code>#</code>一级标题</td></tr><tr><td align="center"><code>##</code>二级标题</td></tr><tr><td align="center"><code>###</code>三级标题</td></tr><tr><td align="center"><code>####</code>四级标题</td></tr><tr><td align="center"><code>#####</code>五级标题</td></tr><tr><td align="center"><code>######</code>六级标题</td></tr></tbody></table><p><img src="2.png" alt="png"></p><h2 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h2><p><code>*斜体*</code>  <em>斜体</em></p><p><code>_斜体_</code>  _斜体_</p><p><code>**粗体**</code>  <strong>粗体</strong></p><p><code>***加粗斜体***</code><strong><em>加粗斜体</em></strong></p><p><code>~~删除线~~</code>  <del>删除线</del></p><h2 id="插入图片或连接"><a href="#插入图片或连接" class="headerlink" title="插入图片或连接"></a>插入图片或连接</h2><blockquote><p>插入链接与插入图片的语法很像，区别在一个 <code>!</code>号</p><p>图片为：<code>![]()</code></p><p>链接为：<code>[]()</code></p></blockquote><p><code>[描述](图片路径或者URL)</code>  描述可以不写</p><h2 id="分割线三种方式"><a href="#分割线三种方式" class="headerlink" title="分割线三种方式"></a>分割线三种方式</h2><p>你可以在一行中用三个以上的星号<code>*</code>、减号<code>-</code>、底线<code>_</code>来建立一个分隔线，行内不能有其他东西。 </p><p><code>---</code></p><hr><p><code>***</code></p><hr><p><code>___</code></p><hr><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p><strong>行内式</strong>：如果在一个行内需要引用代码，只要用反引号`引起来就好（一般在ESC键下方，和~同一个键） </p><p>`用两个反引号` <code>行内/单行代码块</code></p><p><strong>多行代码块与语法高亮</strong>：在需要高亮的代码块的前一行及后一行使用三个单反引号“`”包裹 </p><p>```js</p><p>三个反引号可以表明代码语言,这里写的js</p><p>````</p><pre class="line-numbers language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我是js代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在被引用的文本前加上<code>&gt;</code>符号，以及一个空格就可以了，如一个<code>&gt;</code>符号会产生一次缩进</p><p><code>&gt;引用</code> </p><blockquote><p>引用</p></blockquote><p><code>&gt;&gt;引用</code></p><blockquote><blockquote><p>引用</p></blockquote></blockquote><p><code>&gt;&gt;&gt;引用</code></p><blockquote><blockquote><blockquote><p>引用</p></blockquote></blockquote></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><strong>无序列表</strong></p><p>使用 *，+，- 都可以表示无序列表。任意选用一个即可, 注意：符号后面一定要有一个空格，起到缩进的作用。 </p><p><code>- 无序列表</code>- </p><p><code>* 无序列表</code></p><p><code>+ 无序列表</code></p><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><p><strong>有序列表</strong></p><p>使用数字和一个英文句点表示有序列表。 注意：英文句点后面一定要有一个空格，起到缩进的作用。 </p><p><code>1.有序列表</code></p><p><code>2.有序列表</code></p><p><code>3.有序列表</code></p><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符\"></a>转义字符<code>\</code></h2><p>如果在使用符号时与Markdown语法冲突,可以在符号前面加上<code>\</code>即可正常显示</p><p>如在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><code>|姓名|性别|分数|</code></p><p><code>|:-:|:-:|:-:|</code></p><p><code>|小明|男|100|</code></p><p><code>|小明|男|100|</code></p><p>表格对齐方式：我们可以指定表格单元格的对齐方式，冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中 </p><table><thead><tr><th align="center">姓名</th><th align="center">性别</th><th align="center">分数</th></tr></thead><tbody><tr><td align="center">小明</td><td align="center">男</td><td align="center">100</td></tr><tr><td align="center">小明</td><td align="center">男</td><td align="center">100</td></tr></tbody></table><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Markdown语法学到这里日常已经够用了,下面介绍一款实时预览的 Markdown 文本编辑器</p><h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p>Typora 是一款<strong>支持实时预览的 Markdown 文本编辑器</strong>。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是<strong>完全免费</strong>的。 </p><p>点击下载:<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a></p><h2 id="GFM-标准"><a href="#GFM-标准" class="headerlink" title="GFM 标准"></a>GFM 标准</h2><p> <a href="https://github.github.com/gfm/" target="_blank" rel="noopener">GFM 标准</a>，它是由著名代码托管网站 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 所制定的。Typora 主要使用的也是 GFM 标准。同时，你还可以在 <code>文件 - 偏好设置 - Markdown 语法偏好 - 严格模式</code> 中将标准设置为「更严格地遵循 GFM 标准」。具体内容你可以在官方的 <a href="http://support.typora.io/Strict-Mode/" target="_blank" rel="noopener">这篇文档</a> 中查看。</p><h2 id="设置图片"><a href="#设置图片" class="headerlink" title="设置图片"></a>设置图片</h2><p>Typora 支持在拖动或 <code>Ctrl + V</code> 网络图片后自动将其保存到本地。你可以在 <code>文件 - 偏好设置 - 编辑器 - 图片插入</code> 中选择复制到哪个路径，什么情况下需要复制。</p><p><img src="3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 效率 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预习路线</title>
      <link href="/2020/01/20/yu-xi-lu-xian/"/>
      <url>/2020/01/20/yu-xi-lu-xian/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28285910&auto=1&height=66"></iframe></div><h1 id="预习路线"><a href="#预习路线" class="headerlink" title="预习路线"></a>预习路线</h1><ul><li>ajax  —  node  —  vue  — 小程序 — react </li></ul><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p><strong><a href="https://www.bilibili.com/video/av15657082" target="_blank" rel="noopener">Part1</a></strong>不看php可以从第37个视频开始看</p><p><strong><a href="https://www.bilibili.com/video/av15866060/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">Part2</a></strong></p><p><a href="https://pan.baidu.com/s/1w-lcQCMTNLuSEg0e_hpKuQ" target="_blank" rel="noopener">课件网盘链接</a> – 提取码:mc10</p><p>这个ajax的视频比较老了,,,</p><p>又另外找了一个备看</p><p><a href="https://www.bilibili.com/video/av22807707/?spm_id_from=333.788.videocard.4" target="_blank" rel="noopener">李南江亲授-jQuery+Ajax从放弃到知根知底</a></p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p><a href="https://www.bilibili.com/video/av81455397" target="_blank" rel="noopener">NodeJs全套视频教程</a></p><p><a href="https://pan.baidu.com/s/1DuXusxfxaiUscfvDb0a9LA" target="_blank" rel="noopener">课件网盘链接</a> – 提取码: nzys </p><h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><p><strong><a href="https://www.bilibili.com/video/av75420619/?spm_id_from=333.788.videocard.2" target="_blank" rel="noopener">Pink 老师推荐-Vue.js快速入门课程</a></strong> </p><p><strong><a href="https://www.bilibili.com/video/av50680998" target="_blank" rel="noopener">Vue-黑马程序员视频</a></strong> —&gt;p1–p199是2018经典vue基础+项目实战教程—p200至最后是2019年最新的vue全家桶(包含了比较流行的新技术)+项目实战教程</p><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://thirtyzhang.github.io/git">Git</a></p><p><a href="https://naotu.baidu.com/" target="_blank" rel="noopener">百度脑图</a></p><p><a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">BootCDN</a></p><p><a href="https://www.html.cn/doc/underscore/#throttle" target="_blank" rel="noopener">Underscore.js (1.9.1) 中文文档 </a></p><p><a href="https://aui.github.io/art-template/zh-cn/" target="_blank" rel="noopener">模板引擎</a></p><p><a href="https://www.bypass.cn/" target="_blank" rel="noopener">Bypass-分流抢票</a></p><h2 id="学习站点"><a href="#学习站点" class="headerlink" title="学习站点"></a>学习站点</h2><p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰</a></p><p><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰</a></p><p>git - 典型错误</p><p><img src="1.png" alt="png"></p><h2 id="手动封装数组方法"><a href="#手动封装数组方法" class="headerlink" title="手动封装数组方法"></a>手动封装数组方法</h2><pre class="line-numbers language-js"><code class="language-js">        <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function">myForEach</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//循环调用回调函数,遍历数组中的值</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>myForEach<span class="token punctuation">)</span><span class="token punctuation">;</span>        Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myForEach <span class="token operator">=</span> myForEach<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//把函数添加为Array的原型方法</span>        <span class="token comment" spellcheck="true">//调用</span>        arr<span class="token punctuation">.</span><span class="token function">myForEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>index<span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="典型错误"><a href="#典型错误" class="headerlink" title="典型错误"></a>典型错误</h2><p><strong>npm install</strong> 的时候出现错误：</p><p>npm ERR! Unexpected end of JSON input while parsing near ‘…”,”webpack-dev-server’<br>1<br>解决方案：</p><p>第一步：</p><p>npm cache clean –force<br>1<br>第二步：（再安装）</p><p>npm install</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标题</title>
      <link href="/2018/01/22/2017-conclusion/"/>
      <url>/2018/01/22/2017-conclusion/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
